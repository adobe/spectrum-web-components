<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shared: Spectrum Web Components</title>
    <style>
      body {
        margin: 0;
      }
      #body {
        display: grid;
        grid-template-columns: 256px auto;
      }
    </style>
  </head>
  <body>
    <div id="body">
      <docs-side-nav></docs-side-nav>
      <main id="layout-content" role="main">
        <h2>Description</h2>
<p>Shared mixins, tools, etc. that support developing Spectrum Web Components.</p>
<h3>Installation</h3>
<pre><code>npm install @spectrum-web-components/shared

# or

yarn add @spectrum-web-components/shared
</code></pre>
<h3>Focusable</h3>
<p>The <code>Focusable</code> subclass of <code>LitElement</code> adds some helpers method and lifecycle coverage in order to support passing focus to a container element inside of a custom element. The Focusable base class handles tabindex setting into shadowed elements automatically and is based heavily on the aybolit delegate-focus-mixin at https://github.com/web-padawan/aybolit/blob/master/packages/core/src/mixins/delegate-focus-mixin.js</p>
<pre><code class="language-js">import { Focusable } from '@spectrum-web-components/shared/lib/focusable';
import { html } from 'lit-element';

class FocusableButton extends Focusable {
    public static get styles(): CSSResultArray {
        return [...super.styles];
    }
    public get focusElement(): HTMLElement {
        /* istanbul ignore if */
        if (!this.shadowRoot) {
            return this;
        }
        return this.shadowRoot.querySelector('#button') as HTMLElement;
    }

    protected render(): TemplateResult {
        return html`
            &lt;button
                id=&quot;button&quot;
            &gt;
                Focus for this button is being managed by the focusable base class.
            &lt;/button&gt;
        `;
    }
}
</code></pre>
<h3>ObserverSlotText</h3>
<p>When working with <code>&lt;slot&gt;</code>s and their <code>slotchange</code> event, you will have the opportunity to capture when the nodes and/or elements in your element are added or removed. However, if the <code>textContent</code> of a text node changes, you will not receive the <code>slotchange</code> event because the slot hasn't actually received new nodes and/or elements in the exchange. When working with a lit-html binding <code>&lt;your-element&gt;${text}&lt;/your-element&gt;</code> that means you will not receive a <code>slotchange</code> event when the value of <code>text</code> goes from <code>text = ''</code> to <code>text = 'something'</code> or the other way. In these cases the <code>ObserveSlotText</code> can be leverages to apply a mutation observe onto your element that tracks <code>characterData</code> mutations so that you can resspond as desired.</p>
<pre><code class="language-js">import { ObserveSlotText } from '@spectrum-web-components/shared/lib/oberve-slot-text';
import { LitElement, html } from 'lit-element';

class ObserveSlotTextElement extends ObserveSlotText(LitElement, '#observing-slot') {
    protected render(): TemplateResult {
        return html`
            &lt;button
                id=&quot;button&quot;
            &gt;
                &lt;slot
                    id=&quot;observing-slot&quot;
                    @slotchange=${this.manageObservedSlot}
                &gt;&lt;/slot&gt;
            &lt;/button&gt;
        `;
    }
    protected updated(): void {
        console.log(this.slotHasContent); // =&gt; true when &lt;observing-slot-text-element&gt;Text&lt;/observing-slot-text-element&gt;
    }
}

customElements.define('observing-slot-text-element', ObserveSlotTextElement);
</code></pre>

      </main>
    </div>
  </body>
</html>