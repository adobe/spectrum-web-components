{
  "version": 3,
  "sources": ["iconset-svg.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n    html,\n    PropertyValues,\n    TemplateResult,\n} from '@spectrum-web-components/base';\nimport { query } from '@spectrum-web-components/base/src/decorators.js';\n\nimport { Iconset } from './iconset.dev.js'\n\nexport abstract class IconsetSVG extends Iconset {\n    private iconMap: Map<string, SVGSymbolElement> = new Map();\n\n    @query('slot')\n    private slotContainer?: HTMLSlotElement;\n\n    /**\n     * First updated handler just ensures we've processed any slotted symbols\n     */\n    public override updated(changedProperties: PropertyValues): void {\n        if (!this.slotContainer) {\n            return;\n        }\n        const currentSVGNodes = this.getSVGNodes(this.slotContainer);\n        this.updateSVG(currentSVGNodes);\n        super.updated(changedProperties);\n    }\n    /**\n     * Applies the requested icon from this iconset instance to the given element.\n     *\n     * @param el - the element to apply the icon to\n     * @param icon - the name of the icon within this set to apply.\n     */\n    public async applyIconToElement(\n        el: HTMLElement,\n        icon: string,\n        _size: string,\n        label: string\n    ): Promise<void> {\n        await this.updateComplete;\n        const iconSymbol = this.iconMap.get(icon);\n        if (!iconSymbol) {\n            throw new Error(`Unable to find icon ${icon}`);\n        }\n        // we cannot share a single SVG globally across shadowroot boundaries\n        // so copy the template node so we can inject it where we need it\n        const clonedNode = this.prepareSvgClone(iconSymbol);\n        clonedNode.setAttribute('role', 'img');\n        if (label) {\n            clonedNode.setAttribute('aria-label', label);\n        } else {\n            clonedNode.setAttribute('aria-hidden', 'true');\n        }\n        // append the svg to the node either in its shadowroot or directly into its dom\n        if (el.shadowRoot) {\n            el.shadowRoot.appendChild(clonedNode);\n        } else {\n            el.appendChild(clonedNode);\n        }\n    }\n\n    /**\n     * Returns a list of all icons in this iconset.\n     */\n    public getIconList(): string[] {\n        return [...this.iconMap.keys()];\n    }\n\n    protected prepareSvgClone(sourceSvg: SVGSymbolElement): SVGSVGElement {\n        const content = sourceSvg.cloneNode(true) as SVGSymbolElement;\n        // we're going to create a new svg element that will have our symbol geometry inside\n        const svg = document.createElementNS(\n            'http://www.w3.org/2000/svg',\n            'svg'\n        );\n        const viewBox = content.getAttribute('viewBox') || '';\n        // inline style isn't ideal but will work in all cases and means our icons don't need to know\n        // if they are svg or spritesheet provided\n        const cssText =\n            'pointer-events: none; display: block; width: 100%; height: 100%;';\n        svg.style.cssText = cssText;\n        // copy the viewbox and other properties into the svg\n        svg.setAttribute('viewBox', viewBox);\n        svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n        svg.setAttribute('focusable', 'false');\n        // move all the child nodes over to the svg\n        while (content.childNodes.length > 0) {\n            svg.appendChild(content.childNodes[0]);\n        }\n        return svg;\n    }\n    protected getSVGIconName(icon: string): string {\n        return icon;\n    }\n    protected getSanitizedIconName(icon: string): string {\n        return icon;\n    }\n    protected renderDefaultContent(): TemplateResult {\n        return html``;\n    }\n\n    protected override render(): TemplateResult {\n        return html`\n            <slot @slotchange=${this.onSlotChange}>\n                ${this.renderDefaultContent()}\n            </slot>\n        `;\n    }\n\n    protected updateSVG(nodes: SVGElement[]): void {\n        // iterate over the nodes that were passed in, and find all the top level symbols\n        const symbols = nodes.reduce((prev, svgNode) => {\n            const containedSymbols = svgNode.querySelectorAll('symbol');\n            prev.push(...containedSymbols);\n            return prev;\n        }, [] as SVGSymbolElement[]);\n        symbols.forEach((symbol) => {\n            this.iconMap.set(this.getSanitizedIconName(symbol.id), symbol);\n        });\n    }\n\n    protected getSVGNodes(slotTarget: HTMLSlotElement): SVGElement[] {\n        const nodes = slotTarget.assignedNodes({ flatten: true });\n        // find all the svg nodes\n        const svgNodes = nodes.filter((node) => {\n            return node.nodeName === 'svg';\n        }) as SVGElement[];\n        return svgNodes;\n    }\n\n    private onSlotChange(event: Event): void {\n        const slotTarget = event.target as HTMLSlotElement;\n        const svgNodes = this.getSVGNodes(slotTarget);\n        this.updateSVG(svgNodes);\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;AAYA;AAAA,EACI;AAAA,OAGG;AACP,SAAS,aAAa;AAEtB,SAAS,eAAe;AAEjB,aAAe,mBAAmB,QAAQ;AAAA,EAA1C;AAAA;AACH,SAAQ,UAAyC,oBAAI,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,EAQzC,QAAQ,mBAAyC;AAC7D,QAAI,CAAC,KAAK,eAAe;AACrB;AAAA,IACJ;AACA,UAAM,kBAAkB,KAAK,YAAY,KAAK,aAAa;AAC3D,SAAK,UAAU,eAAe;AAC9B,UAAM,QAAQ,iBAAiB;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,mBACT,IACA,MACA,OACA,OACa;AACb,UAAM,KAAK;AACX,UAAM,aAAa,KAAK,QAAQ,IAAI,IAAI;AACxC,QAAI,CAAC,YAAY;AACb,YAAM,IAAI,MAAM,uBAAuB,IAAI,EAAE;AAAA,IACjD;AAGA,UAAM,aAAa,KAAK,gBAAgB,UAAU;AAClD,eAAW,aAAa,QAAQ,KAAK;AACrC,QAAI,OAAO;AACP,iBAAW,aAAa,cAAc,KAAK;AAAA,IAC/C,OAAO;AACH,iBAAW,aAAa,eAAe,MAAM;AAAA,IACjD;AAEA,QAAI,GAAG,YAAY;AACf,SAAG,WAAW,YAAY,UAAU;AAAA,IACxC,OAAO;AACH,SAAG,YAAY,UAAU;AAAA,IAC7B;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKO,cAAwB;AAC3B,WAAO,CAAC,GAAG,KAAK,QAAQ,KAAK,CAAC;AAAA,EAClC;AAAA,EAEU,gBAAgB,WAA4C;AAClE,UAAM,UAAU,UAAU,UAAU,IAAI;AAExC,UAAM,MAAM,SAAS;AAAA,MACjB;AAAA,MACA;AAAA,IACJ;AACA,UAAM,UAAU,QAAQ,aAAa,SAAS,KAAK;AAGnD,UAAM,UACF;AACJ,QAAI,MAAM,UAAU;AAEpB,QAAI,aAAa,WAAW,OAAO;AACnC,QAAI,aAAa,uBAAuB,eAAe;AACvD,QAAI,aAAa,aAAa,OAAO;AAErC,WAAO,QAAQ,WAAW,SAAS,GAAG;AAClC,UAAI,YAAY,QAAQ,WAAW,CAAC,CAAC;AAAA,IACzC;AACA,WAAO;AAAA,EACX;AAAA,EACU,eAAe,MAAsB;AAC3C,WAAO;AAAA,EACX;AAAA,EACU,qBAAqB,MAAsB;AACjD,WAAO;AAAA,EACX;AAAA,EACU,uBAAuC;AAC7C,WAAO;AAAA,EACX;AAAA,EAEmB,SAAyB;AACxC,WAAO;AAAA,gCACiB,KAAK,YAAY;AAAA,kBAC/B,KAAK,qBAAqB,CAAC;AAAA;AAAA;AAAA,EAGzC;AAAA,EAEU,UAAU,OAA2B;AAE3C,UAAM,UAAU,MAAM,OAAO,CAAC,MAAM,YAAY;AAC5C,YAAM,mBAAmB,QAAQ,iBAAiB,QAAQ;AAC1D,WAAK,KAAK,GAAG,gBAAgB;AAC7B,aAAO;AAAA,IACX,GAAG,CAAC,CAAuB;AAC3B,YAAQ,QAAQ,CAAC,WAAW;AACxB,WAAK,QAAQ,IAAI,KAAK,qBAAqB,OAAO,EAAE,GAAG,MAAM;AAAA,IACjE,CAAC;AAAA,EACL;AAAA,EAEU,YAAY,YAA2C;AAC7D,UAAM,QAAQ,WAAW,cAAc,EAAE,SAAS,KAAK,CAAC;AAExD,UAAM,WAAW,MAAM,OAAO,CAAC,SAAS;AACpC,aAAO,KAAK,aAAa;AAAA,IAC7B,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EAEQ,aAAa,OAAoB;AACrC,UAAM,aAAa,MAAM;AACzB,UAAM,WAAW,KAAK,YAAY,UAAU;AAC5C,SAAK,UAAU,QAAQ;AAAA,EAC3B;AACJ;AAzHY;AAAA,EADP,MAAM,MAAM;AAAA,GAHK,WAIV;",
  "names": []
}
