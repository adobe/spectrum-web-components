{
  "version": 3,
  "sources": ["ActionGroup.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n    CSSResultArray,\n    html,\n    PropertyValues,\n    SizedMixin,\n    SpectrumElement,\n    TemplateResult,\n} from '@spectrum-web-components/base';\nimport {\n    property,\n    query,\n} from '@spectrum-web-components/base/src/decorators.js';\nimport { ActionButton } from '@spectrum-web-components/action-button';\nimport { RovingTabindexController } from '@spectrum-web-components/reactive-controllers/src/RovingTabindex.js';\nimport { MutationController } from '@lit-labs/observers/mutation-controller.js';\n\nimport styles from './action-group.css.js';\n\nconst EMPTY_SELECTION: string[] = [];\n\n/**\n * @element sp-action-group\n * @slot - the sp-action-button elements that make up the group\n *\n * @fires change - Announces that selection state has been changed by user\n */\nexport class ActionGroup extends SizedMixin(SpectrumElement, {\n    validSizes: ['xs', 's', 'm', 'l', 'xl'],\n    noDefaultSize: true,\n}) {\n    static override shadowRootOptions = {\n        ...SpectrumElement.shadowRootOptions,\n        delegatesFocus: true,\n    };\n    public static override get styles(): CSSResultArray {\n        return [styles];\n    }\n\n    public set buttons(buttons: ActionButton[]) {\n        /* c8 ignore next 1 */\n        if (buttons === this.buttons) return;\n        this._buttons = buttons;\n        this.rovingTabindexController.clearElementCache();\n    }\n\n    public get buttons(): ActionButton[] {\n        return this._buttons;\n    }\n\n    public _buttons: ActionButton[] = [];\n\n    protected _buttonSelector = 'sp-action-button, sp-action-menu';\n\n    constructor() {\n        super();\n\n        new MutationController(this, {\n            config: {\n                childList: true,\n                subtree: true,\n            },\n            callback: () => {\n                this.manageButtons();\n            },\n            skipInitial: true,\n        });\n    }\n\n    rovingTabindexController = new RovingTabindexController<ActionButton>(\n        this,\n        {\n            focusInIndex: (elements: ActionButton[]) => {\n                let firstEnabledIndex = -1;\n                const firstSelectedIndex = elements.findIndex((el, index) => {\n                    if (!elements[firstEnabledIndex] && !el.disabled) {\n                        firstEnabledIndex = index;\n                    }\n                    return el.selected && !el.disabled;\n                });\n                return elements[firstSelectedIndex]\n                    ? firstSelectedIndex\n                    : firstEnabledIndex;\n            },\n            elements: () => this.buttons,\n            hostDelegatesFocus: true,\n            isFocusableElement: (el: ActionButton) => !el.disabled,\n        }\n    );\n\n    @property({ type: Boolean, reflect: true })\n    public compact = false;\n\n    @property({ type: Boolean, reflect: true })\n    public emphasized = false;\n\n    @property({ type: Boolean, reflect: true })\n    public justified = false;\n\n    @property({ type: String })\n    public label = '';\n\n    @property({ type: Boolean, reflect: true })\n    public quiet = false;\n\n    @property({ type: String })\n    public selects: undefined | 'single' | 'multiple';\n\n    @property({ reflect: true, attribute: 'static-color' })\n    public staticColor?: 'white' | 'black';\n\n    @property({ type: Boolean, reflect: true })\n    public vertical = false;\n\n    private _selected: string[] = EMPTY_SELECTION;\n\n    set selected(selected: string[]) {\n        this.requestUpdate('selected', this._selected);\n        this._selected = selected;\n        this.updateComplete.then(() => {\n            this.applySelects();\n            this.manageChildren();\n        });\n    }\n\n    @property({ type: Array })\n    get selected(): string[] {\n        return this._selected;\n    }\n\n    @query('slot')\n    slotElement!: HTMLSlotElement;\n\n    private dispatchChange(old: string[]): void {\n        const applyDefault = this.dispatchEvent(\n            new Event('change', {\n                bubbles: true,\n                composed: true,\n                cancelable: true,\n            })\n        );\n\n        if (!applyDefault) {\n            this.setSelected(old);\n            this.buttons.map((button) => {\n                button.selected = this.selected.includes(button.value);\n            });\n        }\n    }\n\n    private setSelected(selected: string[], announce?: boolean): void {\n        /* c8 ignore next 1 */\n        if (selected === this.selected) return;\n\n        const old = this.selected;\n        this.requestUpdate('selected', old);\n        this._selected = selected;\n        if (!announce) return;\n        this.dispatchChange(old);\n    }\n\n    public override focus(options?: FocusOptions): void {\n        this.rovingTabindexController.focus(options);\n    }\n\n    private deselectSelectedButtons(): void {\n        this.buttons.forEach((button) => {\n            if (!button.selected) return;\n\n            button.selected = false;\n            button.tabIndex = -1;\n            button.setAttribute(\n                this.selects ? 'aria-checked' : /* c8 ignore */ 'aria-pressed',\n                'false'\n            );\n        });\n    }\n\n    private handleActionButtonChange(event: Event): void {\n        event.stopPropagation();\n        event.preventDefault();\n    }\n\n    private handleClick(event: Event): void {\n        const target = event.target as ActionButton;\n        if (typeof target.value === 'undefined') {\n            return;\n        }\n        switch (this.selects) {\n            case 'single': {\n                this.deselectSelectedButtons();\n                target.selected = true;\n                target.tabIndex = 0;\n                target.setAttribute('aria-checked', 'true');\n                this.setSelected([target.value], true);\n                break;\n            }\n            case 'multiple': {\n                const selected = [...this.selected];\n                target.selected = !target.selected;\n                target.setAttribute(\n                    'aria-checked',\n                    target.selected ? 'true' : 'false'\n                );\n                if (target.selected) {\n                    selected.push(target.value);\n                } else {\n                    selected.splice(this.selected.indexOf(target.value), 1);\n                }\n                this.setSelected(selected, true);\n\n                this.buttons.forEach((button) => {\n                    button.tabIndex = -1;\n                });\n\n                target.tabIndex = 0;\n\n                break;\n            }\n            default:\n                break;\n        }\n    }\n\n    private async applySelects(): Promise<void> {\n        await this.manageSelects(true);\n    }\n\n    private async manageSelects(applied?: boolean): Promise<void> {\n        if (!this.buttons.length) {\n            return;\n        }\n\n        const options = this.buttons;\n        switch (this.selects) {\n            case 'single': {\n                // single behaves as a radio group\n                this.setAttribute('role', 'radiogroup');\n                const selections: ActionButton[] = [];\n                const updates = options.map(async (option) => {\n                    await option.updateComplete;\n                    if (option instanceof ActionButton)\n                        option.setAttribute('role', 'radio');\n                    option.setAttribute(\n                        'aria-checked',\n                        option.selected ? 'true' : 'false'\n                    );\n                    if (option.selected) {\n                        selections.push(option);\n                    }\n                });\n                if (applied) break;\n                await Promise.all(updates);\n\n                const selected = selections.map((button) => {\n                    return button.value;\n                });\n\n                this.setSelected(selected || EMPTY_SELECTION);\n                break;\n            }\n            case 'multiple': {\n                // switching from single to multiple, remove role=\"radiogroup\"\n                if (this.getAttribute('role') === 'radiogroup') {\n                    this.removeAttribute('role');\n                }\n                const selection: string[] = [];\n                const selections: ActionButton[] = [];\n                const updates = options.map(async (option) => {\n                    await option.updateComplete;\n                    if (option instanceof ActionButton)\n                        option.setAttribute('role', 'checkbox');\n                    option.setAttribute(\n                        'aria-checked',\n                        option.selected ? 'true' : 'false'\n                    );\n                    if (option.selected) {\n                        selection.push(option.value);\n                        selections.push(option);\n                    }\n                });\n                if (applied) break;\n                await Promise.all(updates);\n                const selected = !!selection.length\n                    ? selection\n                    : EMPTY_SELECTION;\n                this.setSelected(selected);\n                break;\n            }\n            default:\n                // if user defines .selected\n                if (this.selected.length) {\n                    const selections: ActionButton[] = [];\n                    const updates = options.map(async (option) => {\n                        await option.updateComplete;\n                        if (option instanceof ActionButton)\n                            option.setAttribute('role', 'button');\n                        if (option.selected) {\n                            option.setAttribute('aria-pressed', 'true');\n                            selections.push(option);\n                        } else {\n                            option.removeAttribute('aria-pressed');\n                        }\n                    });\n                    if (applied) break;\n                    await Promise.all(updates);\n\n                    this.setSelected(\n                        selections.map((button) => {\n                            return button.value;\n                        })\n                    );\n                } else {\n                    this.buttons.forEach((option) => {\n                        if (option instanceof ActionButton)\n                            option.setAttribute('role', 'button');\n                    });\n                    break;\n                }\n        }\n\n        // When no other role is defined, use role=\"toolbar\", which is appropriate with roving tabindex.\n        if (!this.hasAttribute('role')) {\n            this.setAttribute('role', 'toolbar');\n        }\n    }\n\n    protected override render(): TemplateResult {\n        return html`\n            <slot role=\"presentation\" @slotchange=${this.manageButtons}></slot>\n        `;\n    }\n\n    protected override firstUpdated(changes: PropertyValues): void {\n        super.firstUpdated(changes);\n        this.addEventListener('click', this.handleClick);\n    }\n\n    protected override updated(changes: PropertyValues): void {\n        super.updated(changes);\n        if (changes.has('selects')) {\n            this.manageSelects();\n            this.manageChildren();\n            if (!!this.selects) {\n                this.shadowRoot.addEventListener(\n                    'change',\n                    this.handleActionButtonChange\n                );\n            } else {\n                this.shadowRoot.removeEventListener(\n                    'change',\n                    this.handleActionButtonChange\n                );\n            }\n        }\n        if (\n            changes.has('quiet') ||\n            changes.has('emphasized') ||\n            changes.has('size') ||\n            changes.has('staticColor')\n        ) {\n            this.manageChildren(changes);\n        }\n        // Update `aria-label` when `label` available or not first `updated`\n        if (\n            changes.has('label') &&\n            (this.label || typeof changes.get('label') !== 'undefined')\n        ) {\n            if (this.label.length) {\n                this.setAttribute('aria-label', this.label);\n            } else {\n                this.removeAttribute('aria-label');\n            }\n        }\n    }\n\n    private manageChildren(changes?: PropertyValues): void {\n        this.buttons.forEach((button) => {\n            if (this.quiet || changes?.get('quiet')) {\n                button.quiet = this.quiet;\n            }\n            if (this.emphasized || changes?.get('emphasized')) {\n                button.emphasized = this.emphasized;\n            }\n            if (this.staticColor || changes?.get('staticColor')) {\n                button.staticColor = this.staticColor;\n            }\n            if (this.selects || !this.hasManaged) {\n                button.selected = this.selected.includes(button.value);\n            }\n            if (\n                this.size &&\n                (this.size !== 'm' ||\n                    typeof changes?.get('size') !== 'undefined')\n            ) {\n                button.size = this.size;\n            }\n        });\n    }\n\n    private hasManaged = false;\n\n    private manageButtons = (): void => {\n        if (!this.slotElement) {\n            return;\n        }\n        const assignedElements = this.slotElement.assignedElements({\n            flatten: true,\n        });\n        const buttons = assignedElements.reduce((acc: unknown[], el) => {\n            if (el.matches(this._buttonSelector)) {\n                acc.push(el);\n            } else {\n                const buttonDescendents = Array.from(\n                    el.querySelectorAll(`:scope > ${this._buttonSelector}`)\n                );\n                acc.push(...buttonDescendents);\n            }\n            return acc;\n        }, []);\n        this.buttons = buttons as ActionButton[];\n        if (this.selects || !this.hasManaged) {\n            // <select> element merges selected so following paradigm here\n            const currentlySelectedButtons: string[] = [];\n            this.buttons.forEach((button: ActionButton) => {\n                if (button.selected) {\n                    currentlySelectedButtons.push(button.value);\n                }\n            });\n            this.setSelected(this.selected.concat(currentlySelectedButtons));\n        }\n        this.manageChildren();\n        this.manageSelects();\n        this.hasManaged = true;\n    };\n}\n"],
  "mappings": "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",
  "names": ["html", "SizedMixin", "SpectrumElement", "property", "query", "ActionButton", "RovingTabindexController", "MutationController", "styles", "EMPTY_SELECTION", "elements", "firstEnabledIndex", "firstSelectedIndex", "el", "index", "buttons", "acc", "buttonDescendents", "currentlySelectedButtons", "button", "selected", "old", "announce", "options", "event", "target", "applied", "selections", "updates", "option", "selection", "changes", "__decorateClass"]
}
