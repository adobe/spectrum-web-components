{
  "version": 3,
  "sources": ["ColorSlider.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n    CSSResultArray,\n    html,\n    PropertyValues,\n    TemplateResult,\n} from '@spectrum-web-components/base';\nimport {\n    ifDefined,\n    StyleInfo,\n    styleMap,\n} from '@spectrum-web-components/base/src/directives.js';\nimport {\n    property,\n    query,\n} from '@spectrum-web-components/base/src/decorators.js';\nimport { streamingListener } from '@spectrum-web-components/base/src/streaming-listener.js';\nimport { Focusable } from '@spectrum-web-components/shared/src/focusable.js';\nimport type { ColorHandle } from '@spectrum-web-components/color-handle';\nimport '@spectrum-web-components/color-handle/sp-color-handle.js';\nimport {\n    ColorController,\n    ColorTypes,\n} from '@spectrum-web-components/reactive-controllers/src/ColorController.js';\nimport { LanguageResolutionController } from '@spectrum-web-components/reactive-controllers/src/LanguageResolution.js';\n\nimport opacityCheckerBoardStyles from '@spectrum-web-components/opacity-checkerboard/src/opacity-checkerboard.css.js';\nimport styles from './color-slider.css.js';\n\n/**\n * @element sp-color-slider\n * @slot gradient - a custom gradient visually outlining the available color values\n * @fires input - The value of the Color Slider has changed.\n * @fires change - An alteration to the value of the Color Slider has been committed by the user.\n */\nexport class ColorSlider extends Focusable {\n    public static override get styles(): CSSResultArray {\n        return [opacityCheckerBoardStyles, styles];\n    }\n\n    @property({ type: String, reflect: true })\n    public override dir!: 'ltr' | 'rtl';\n\n    @property({ type: Boolean, reflect: true })\n    public override disabled = false;\n\n    @property({ type: Boolean, reflect: true })\n    public focused = false;\n\n    @query('.handle')\n    private handle!: ColorHandle;\n\n    @property({ type: String })\n    public label = 'hue';\n\n    @property({ type: Boolean, reflect: true })\n    public vertical = false;\n\n    private languageResolver = new LanguageResolutionController(this);\n\n    public colorController = new ColorController(this, { manageAs: 'hsv' });\n\n    @property({ type: Number })\n    public get value(): number {\n        return this.colorController.hue;\n    }\n\n    public set value(hue: number) {\n        this.colorController.hue = hue;\n    }\n\n    get sliderHandlePosition(): number {\n        return (this.colorController.hue / 360) * 100;\n    }\n\n    @property({ type: String })\n    public get color(): ColorTypes {\n        return this.colorController.colorValue;\n    }\n\n    public set color(color: ColorTypes) {\n        this.colorController.color = color;\n    }\n\n    @property({ type: Number })\n    public step = 1;\n\n    private get altered(): number {\n        return this._altered;\n    }\n\n    private set altered(altered: number) {\n        this._altered = altered;\n        this.step = Math.max(1, this.altered * 10);\n    }\n\n    private _altered = 0;\n\n    @query('input')\n    public input!: HTMLInputElement;\n\n    public override get focusElement(): HTMLInputElement {\n        return this.input;\n    }\n\n    private handleKeydown(event: KeyboardEvent): void {\n        const { key } = event;\n        this.focused = true;\n        this.altered = [event.shiftKey, event.ctrlKey, event.altKey].filter(\n            (key) => !!key\n        ).length;\n        let delta = 0;\n        switch (key) {\n            case 'ArrowUp':\n                delta = this.step;\n                break;\n            case 'ArrowDown':\n                delta = -this.step;\n                break;\n            case 'ArrowLeft':\n                delta = this.step * (this.isLTR ? -1 : 1);\n                break;\n            case 'ArrowRight':\n                delta = this.step * (this.isLTR ? 1 : -1);\n                break;\n            default:\n                return;\n        }\n        event.preventDefault();\n\n        const range = 360;\n        const mult = 100 / range;\n        const nextSliderHandlePosition = Math.min(\n            100,\n            Math.max(0, this.sliderHandlePosition + delta * mult)\n        );\n        this.value = 360 * (nextSliderHandlePosition / 100);\n\n        if (delta != 0) {\n            this.dispatchEvent(\n                new Event('input', {\n                    bubbles: true,\n                    composed: true,\n                })\n            );\n            this.dispatchEvent(\n                new Event('change', {\n                    bubbles: true,\n                    composed: true,\n                })\n            );\n        }\n    }\n\n    private handleInput(event: Event & { target: HTMLInputElement }): void {\n        const { valueAsNumber } = event.target;\n\n        this.value = valueAsNumber;\n    }\n\n    private handleChange(event: Event & { target: HTMLInputElement }): void {\n        this.handleInput(event);\n        this.dispatchEvent(\n            new Event('change', {\n                bubbles: true,\n                composed: true,\n            })\n        );\n    }\n\n    public override focus(focusOptions: FocusOptions = {}): void {\n        super.focus(focusOptions);\n        this.forwardFocus();\n    }\n\n    private forwardFocus(): void {\n        this.focused = this.hasVisibleFocusInTree();\n        this.input.focus();\n    }\n\n    private handleFocus(): void {\n        this.focused = true;\n    }\n\n    private handleBlur(): void {\n        if (this._pointerDown) {\n            return;\n        }\n        this.altered = 0;\n        this.focused = false;\n    }\n\n    private boundingClientRect!: DOMRect;\n    private _pointerDown = false;\n\n    private handlePointerdown(event: PointerEvent): void {\n        if (event.button !== 0) {\n            event.preventDefault();\n            return;\n        }\n        this._pointerDown = true;\n        this.colorController.savePreviousColor();\n        this.boundingClientRect = this.getBoundingClientRect();\n        (event.target as HTMLElement).setPointerCapture(event.pointerId);\n        if (event.pointerType === 'mouse') {\n            this.focused = true;\n        }\n    }\n\n    private handlePointermove(event: PointerEvent): void {\n        const nextsliderHandlePosition = this.calculateHandlePosition(event);\n        this.value = 360 * (nextsliderHandlePosition / 100);\n\n        this.dispatchEvent(\n            new Event('input', {\n                bubbles: true,\n                composed: true,\n                cancelable: true,\n            })\n        );\n    }\n\n    private handlePointerup(event: PointerEvent): void {\n        this._pointerDown = false;\n        (event.target as HTMLElement).releasePointerCapture(event.pointerId);\n\n        const applyDefault = this.dispatchEvent(\n            new Event('change', {\n                bubbles: true,\n                composed: true,\n                cancelable: true,\n            })\n        );\n        if (!applyDefault) {\n            this.colorController.restorePreviousColor();\n        }\n        // Retain focus on input element after mouse up to enable keyboard interactions\n        this.focus();\n        if (event.pointerType === 'mouse') {\n            this.focused = false;\n        }\n    }\n\n    /**\n     * Returns the value under the cursor\n     * @param: PointerEvent on slider\n     * @return: Slider value that correlates to the position under the pointer\n     */\n    private calculateHandlePosition(event: PointerEvent): number {\n        /* c8 ignore next 3 */\n        if (!this.boundingClientRect) {\n            return this.sliderHandlePosition;\n        }\n        const rect = this.boundingClientRect;\n        const minOffset = this.vertical ? rect.top : rect.left;\n        const offset = this.vertical ? event.clientY : event.clientX;\n        const size = this.vertical ? rect.height : rect.width;\n\n        const percent = Math.max(0, Math.min(1, (offset - minOffset) / size));\n        const sliderHandlePosition =\n            this.vertical || !this.isLTR ? 100 - 100 * percent : 100 * percent;\n\n        return sliderHandlePosition;\n    }\n\n    private handleGradientPointerdown(event: PointerEvent): void {\n        if (event.button !== 0) {\n            return;\n        }\n        event.stopPropagation();\n        event.preventDefault();\n        this.handle.dispatchEvent(new PointerEvent('pointerdown', event));\n        this.handlePointermove(event);\n    }\n\n    private get handlePositionStyles(): string {\n        return `${this.vertical ? 'inset-block-end' : 'inset-inline-start'}: ${\n            this.sliderHandlePosition\n        }%`;\n    }\n\n    private get getColorSliderStyle(): StyleInfo {\n        const orientation = this.vertical ? 'top' : 'right';\n        return {\n            background: `linear-gradient(to ${orientation}, var(--sp-color-slider-gradient, var(--sp-color-slider-gradient-fallback)))`,\n        };\n    }\n\n    protected override render(): TemplateResult {\n        return html`\n            <div\n                class=\"opacity-checkerboard checkerboard\"\n                role=\"presentation\"\n                @pointerdown=${this.handleGradientPointerdown}\n            >\n                <div\n                    class=\"gradient\"\n                    role=\"presentation\"\n                    style=${styleMap(this.getColorSliderStyle)}\n                >\n                    <slot name=\"gradient\"></slot>\n                </div>\n            </div>\n            <sp-color-handle\n                tabindex=${ifDefined(this.focused ? undefined : '0')}\n                @focus=${this.forwardFocus}\n                ?focused=${this.focused}\n                class=\"handle\"\n                color=\"hsl(${this.value}, 100%, 50%)\"\n                ?disabled=${this.disabled}\n                style=${this.handlePositionStyles}\n                ${streamingListener({\n                    start: ['pointerdown', this.handlePointerdown],\n                    streamInside: ['pointermove', this.handlePointermove],\n                    end: [\n                        ['pointerup', 'pointercancel', 'pointerleave'],\n                        this.handlePointerup,\n                    ],\n                })}\n            ></sp-color-handle>\n            <input\n                type=\"range\"\n                class=\"slider\"\n                min=\"0\"\n                max=\"360\"\n                aria-orientation=${ifDefined(\n                    this.vertical ? 'vertical' : undefined\n                )}\n                orient=${ifDefined(this.vertical ? 'vertical' : undefined)}\n                step=${this.step}\n                aria-label=${this.label}\n                .value=${String(this.value)}\n                aria-valuetext=${`${new Intl.NumberFormat(\n                    this.languageResolver.language,\n                    {\n                        maximumFractionDigits: 0,\n                        minimumIntegerDigits: 1,\n                        style: 'unit',\n                        unit: 'degree',\n                        unitDisplay: 'narrow',\n                    }\n                ).format(this.value)}`}\n                @input=${this.handleInput}\n                @change=${this.handleChange}\n                @keydown=${this.handleKeydown}\n            />\n        `;\n    }\n\n    protected override firstUpdated(changed: PropertyValues): void {\n        super.firstUpdated(changed);\n        this.boundingClientRect = this.getBoundingClientRect();\n        this.addEventListener('focus', this.handleFocus);\n        this.addEventListener('blur', this.handleBlur);\n    }\n}\n"],
  "mappings": "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",
  "names": ["html", "ifDefined", "styleMap", "property", "query", "streamingListener", "Focusable", "ColorController", "LanguageResolutionController", "opacityCheckerBoardStyles", "styles", "hue", "color", "altered", "event", "key", "delta", "mult", "nextSliderHandlePosition", "valueAsNumber", "focusOptions", "nextsliderHandlePosition", "rect", "minOffset", "offset", "size", "percent", "changed", "__decorateClass"]
}
