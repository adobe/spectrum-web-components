{
  "version": 3,
  "sources": ["OverlayNoPopover.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n    firstFocusableIn,\n    firstFocusableSlottedIn,\n} from '@spectrum-web-components/shared/src/first-focusable-in.js';\nimport type { SpectrumElement } from '@spectrum-web-components/base';\nimport { VirtualTrigger } from './VirtualTrigger.dev.js'\nimport { Constructor, OpenableElement } from './overlay-types.dev.js'\nimport {\n    guaranteedAllTransitionend,\n    nextFrame,\n    overlayTimer,\n} from './AbstractOverlay.dev.js'\nimport {\n    BeforetoggleClosedEvent,\n    BeforetoggleOpenEvent,\n    OverlayStateEvent,\n} from './events.dev.js'\nimport type { AbstractOverlay } from './AbstractOverlay.dev.js'\nimport { userFocusableSelector } from '@spectrum-web-components/shared';\n\nexport function OverlayNoPopover<T extends Constructor<AbstractOverlay>>(\n    constructor: T\n): T & Constructor<SpectrumElement> {\n    class OverlayWithNoPopover extends constructor {\n        protected override async managePopoverOpen(): Promise<void> {\n            await this.managePosition();\n        }\n\n        protected override async manageDelay(\n            targetOpenState: boolean\n        ): Promise<void> {\n            if (targetOpenState === false || targetOpenState !== this.open) {\n                overlayTimer.close(this);\n                return;\n            }\n            if (this.delayed) {\n                const cancelled = await overlayTimer.openTimer(this);\n                if (cancelled) {\n                    this.open = !targetOpenState;\n                }\n            }\n        }\n\n        protected override async ensureOnDOM(\n            _targetOpenState: boolean\n        ): Promise<void> {\n            // force the browser to paint\n            document.body.offsetHeight;\n        }\n\n        protected override async makeTransition(\n            targetOpenState: boolean\n        ): Promise<HTMLElement | null> {\n            if (this.open !== targetOpenState) {\n                return null;\n            }\n            let focusEl = null as HTMLElement | null;\n            const start = (el: OpenableElement, index: number) => (): void => {\n                if (targetOpenState !== this.open) {\n                    return;\n                }\n                el.open = targetOpenState;\n                if (index === 0) {\n                    const event = targetOpenState\n                        ? BeforetoggleOpenEvent\n                        : BeforetoggleClosedEvent;\n                    this.dispatchEvent(new event());\n                }\n                if (targetOpenState !== true) {\n                    return;\n                }\n                if (el.matches(userFocusableSelector)) {\n                    focusEl = el;\n                }\n                focusEl = focusEl || firstFocusableIn(el);\n                if (focusEl) {\n                    return;\n                }\n                const childSlots = el.querySelectorAll('slot');\n                childSlots.forEach((slot) => {\n                    if (!focusEl) {\n                        focusEl = firstFocusableSlottedIn(slot);\n                    }\n                });\n            };\n            const finish =\n                (el: OpenableElement, index: number) =>\n                async (): Promise<void> => {\n                    if (this.open !== targetOpenState) {\n                        return;\n                    }\n                    const eventName = targetOpenState\n                        ? 'sp-opened'\n                        : 'sp-closed';\n                    el.dispatchEvent(\n                        new OverlayStateEvent(eventName, this, {\n                            interaction: this.type,\n                        })\n                    );\n                    if (index > 0) {\n                        return;\n                    }\n                    const hasVirtualTrigger =\n                        this.triggerElement instanceof VirtualTrigger;\n                    this.dispatchEvent(\n                        new OverlayStateEvent(eventName, this, {\n                            interaction: this.type,\n                            publish: hasVirtualTrigger,\n                        })\n                    );\n                    if (this.triggerElement && !hasVirtualTrigger) {\n                        (this.triggerElement as HTMLElement).dispatchEvent(\n                            new OverlayStateEvent(eventName, this, {\n                                interaction: this.type,\n                                publish: true,\n                            })\n                        );\n                    }\n                    this.state = targetOpenState ? 'opened' : 'closed';\n                    this.returnFocus();\n                    // Ensure layout and paint are done and the Overlay is still closed before removing the slottable request.\n                    await nextFrame();\n                    await nextFrame();\n                    if (\n                        targetOpenState === this.open &&\n                        targetOpenState === false\n                    ) {\n                        this.requestSlottable();\n                    }\n                };\n            this.elements.forEach((el, index) => {\n                guaranteedAllTransitionend(\n                    el,\n                    start(el, index),\n                    finish(el, index)\n                );\n            });\n            return focusEl;\n        }\n    }\n    return OverlayWithNoPopover;\n}\n"],
  "mappings": ";AAWA;AAAA,EACI;AAAA,EACA;AAAA,OACG;AAEP,SAAS,sBAAsB;AAE/B;AAAA,EACI;AAAA,EACA;AAAA,EACA;AAAA,OACG;AACP;AAAA,EACI;AAAA,EACA;AAAA,EACA;AAAA,OACG;AAEP,SAAS,6BAA6B;AAE/B,gBAAS,iBACZ,aACgC;AAAA,EAChC,MAAM,6BAA6B,YAAY;AAAA,IAC3C,MAAyB,oBAAmC;AACxD,YAAM,KAAK,eAAe;AAAA,IAC9B;AAAA,IAEA,MAAyB,YACrB,iBACa;AACb,UAAI,oBAAoB,SAAS,oBAAoB,KAAK,MAAM;AAC5D,qBAAa,MAAM,IAAI;AACvB;AAAA,MACJ;AACA,UAAI,KAAK,SAAS;AACd,cAAM,YAAY,MAAM,aAAa,UAAU,IAAI;AACnD,YAAI,WAAW;AACX,eAAK,OAAO,CAAC;AAAA,QACjB;AAAA,MACJ;AAAA,IACJ;AAAA,IAEA,MAAyB,YACrB,kBACa;AAEb,eAAS,KAAK;AAAA,IAClB;AAAA,IAEA,MAAyB,eACrB,iBAC2B;AAC3B,UAAI,KAAK,SAAS,iBAAiB;AAC/B,eAAO;AAAA,MACX;AACA,UAAI,UAAU;AACd,YAAM,QAAQ,CAAC,IAAqB,UAAkB,MAAY;AAC9D,YAAI,oBAAoB,KAAK,MAAM;AAC/B;AAAA,QACJ;AACA,WAAG,OAAO;AACV,YAAI,UAAU,GAAG;AACb,gBAAM,QAAQ,kBACR,wBACA;AACN,eAAK,cAAc,IAAI,MAAM,CAAC;AAAA,QAClC;AACA,YAAI,oBAAoB,MAAM;AAC1B;AAAA,QACJ;AACA,YAAI,GAAG,QAAQ,qBAAqB,GAAG;AACnC,oBAAU;AAAA,QACd;AACA,kBAAU,WAAW,iBAAiB,EAAE;AACxC,YAAI,SAAS;AACT;AAAA,QACJ;AACA,cAAM,aAAa,GAAG,iBAAiB,MAAM;AAC7C,mBAAW,QAAQ,CAAC,SAAS;AACzB,cAAI,CAAC,SAAS;AACV,sBAAU,wBAAwB,IAAI;AAAA,UAC1C;AAAA,QACJ,CAAC;AAAA,MACL;AACA,YAAM,SACF,CAAC,IAAqB,UACtB,YAA2B;AACvB,YAAI,KAAK,SAAS,iBAAiB;AAC/B;AAAA,QACJ;AACA,cAAM,YAAY,kBACZ,cACA;AACN,WAAG;AAAA,UACC,IAAI,kBAAkB,WAAW,MAAM;AAAA,YACnC,aAAa,KAAK;AAAA,UACtB,CAAC;AAAA,QACL;AACA,YAAI,QAAQ,GAAG;AACX;AAAA,QACJ;AACA,cAAM,oBACF,KAAK,0BAA0B;AACnC,aAAK;AAAA,UACD,IAAI,kBAAkB,WAAW,MAAM;AAAA,YACnC,aAAa,KAAK;AAAA,YAClB,SAAS;AAAA,UACb,CAAC;AAAA,QACL;AACA,YAAI,KAAK,kBAAkB,CAAC,mBAAmB;AAC3C,UAAC,KAAK,eAA+B;AAAA,YACjC,IAAI,kBAAkB,WAAW,MAAM;AAAA,cACnC,aAAa,KAAK;AAAA,cAClB,SAAS;AAAA,YACb,CAAC;AAAA,UACL;AAAA,QACJ;AACA,aAAK,QAAQ,kBAAkB,WAAW;AAC1C,aAAK,YAAY;AAEjB,cAAM,UAAU;AAChB,cAAM,UAAU;AAChB,YACI,oBAAoB,KAAK,QACzB,oBAAoB,OACtB;AACE,eAAK,iBAAiB;AAAA,QAC1B;AAAA,MACJ;AACJ,WAAK,SAAS,QAAQ,CAAC,IAAI,UAAU;AACjC;AAAA,UACI;AAAA,UACA,MAAM,IAAI,KAAK;AAAA,UACf,OAAO,IAAI,KAAK;AAAA,QACpB;AAAA,MACJ,CAAC;AACD,aAAO;AAAA,IACX;AAAA,EACJ;AACA,SAAO;AACX;",
  "names": []
}
