{
  "version": 3,
  "sources": ["OverlayPopover.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n    firstFocusableIn,\n    firstFocusableSlottedIn,\n} from '@spectrum-web-components/shared/src/first-focusable-in.js';\nimport type { SpectrumElement } from '@spectrum-web-components/base';\nimport { VirtualTrigger } from './VirtualTrigger.dev.js'\nimport { Constructor, OpenableElement } from './overlay-types.dev.js'\nimport {\n    guaranteedAllTransitionend,\n    nextFrame,\n    overlayTimer,\n} from './AbstractOverlay.dev.js'\nimport {\n    BeforetoggleClosedEvent,\n    BeforetoggleOpenEvent,\n    OverlayStateEvent,\n} from './events.dev.js'\nimport type { AbstractOverlay } from './AbstractOverlay.dev.js'\nimport { userFocusableSelector } from '@spectrum-web-components/shared';\n\nconst supportsOverlayAuto = CSS.supports('(overlay: auto)');\n\nfunction isOpen(el: HTMLElement): boolean {\n    let popoverOpen = false;\n    try {\n        popoverOpen = el.matches(':popover-open');\n        // eslint-disable-next-line no-empty\n    } catch (error) {}\n    let open = false;\n    try {\n        open = el.matches(':open');\n        // eslint-disable-next-line no-empty\n    } catch (error) {}\n    return popoverOpen || open;\n}\n\nexport function OverlayPopover<T extends Constructor<AbstractOverlay>>(\n    constructor: T\n): T & Constructor<SpectrumElement> {\n    class OverlayWithPopover extends constructor {\n        protected override async manageDelay(\n            targetOpenState: boolean\n        ): Promise<void> {\n            if (targetOpenState === false || targetOpenState !== this.open) {\n                overlayTimer.close(this);\n                return;\n            }\n            if (this.delayed) {\n                const cancelled = await overlayTimer.openTimer(this);\n                if (cancelled) {\n                    this.open = !targetOpenState;\n                }\n            }\n        }\n\n        /**\n         * A popover should be hidden _after_ it is no longer on top-layer because\n         * the position metrics will have changed from when it was originally positioned.\n         */\n        private async shouldHidePopover(\n            targetOpenState: boolean\n        ): Promise<void> {\n            if (targetOpenState && this.open !== targetOpenState) {\n                return;\n            }\n            const update = async ({\n                newState,\n            }: { newState?: string } = {}): Promise<void> => {\n                if (newState === 'open') {\n                    return;\n                }\n                // When in a parent Overlay, this Overlay may need to position itself\n                // while closing in due to the parent _also_ closing which means the\n                // location can no longer rely on \"top layer over transform\" math.\n                await this.placementController.resetOverlayPosition();\n            };\n            if (!isOpen(this.dialogEl)) {\n                // The means the Overlay was closed from the outside, it is already off of top-layer\n                // so we need to position it in regards to this new state.\n                update();\n                return;\n            }\n            // `toggle` is an async event, so it's possible for this handler to run a frame late\n            this.dialogEl.addEventListener('toggle', update as EventListener, {\n                once: true,\n            });\n        }\n\n        private shouldShowPopover(targetOpenState: boolean): void {\n            let popoverOpen = false;\n            try {\n                popoverOpen = this.dialogEl.matches(':popover-open');\n                // eslint-disable-next-line no-empty\n            } catch (error) {}\n            let open = false;\n            try {\n                open = this.dialogEl.matches(':open');\n                // eslint-disable-next-line no-empty\n            } catch (error) {}\n            if (\n                targetOpenState &&\n                this.open === targetOpenState &&\n                !popoverOpen &&\n                !open &&\n                this.isConnected\n            ) {\n                this.dialogEl.showPopover();\n                this.managePosition();\n            }\n        }\n\n        protected override async ensureOnDOM(\n            targetOpenState: boolean\n        ): Promise<void> {\n            if (!supportsOverlayAuto) {\n                await this.shouldHidePopover(targetOpenState);\n            }\n            this.shouldShowPopover(targetOpenState);\n            await nextFrame();\n        }\n\n        protected override async makeTransition(\n            targetOpenState: boolean\n        ): Promise<HTMLElement | null> {\n            if (this.open !== targetOpenState) {\n                return null;\n            }\n            let focusEl = null as HTMLElement | null;\n            const start = (el: OpenableElement, index: number) => (): void => {\n                el.open = targetOpenState;\n                if (index === 0) {\n                    const event = targetOpenState\n                        ? BeforetoggleOpenEvent\n                        : BeforetoggleClosedEvent;\n                    this.dispatchEvent(new event());\n                }\n                if (!targetOpenState) {\n                    return;\n                }\n                if (el.matches(userFocusableSelector)) {\n                    focusEl = el;\n                }\n                focusEl = focusEl || firstFocusableIn(el);\n                if (focusEl) {\n                    return;\n                }\n                const childSlots = el.querySelectorAll('slot');\n                childSlots.forEach((slot) => {\n                    if (!focusEl) {\n                        focusEl = firstFocusableSlottedIn(slot);\n                    }\n                });\n            };\n            const finish =\n                (el: OpenableElement, index: number) =>\n                async (): Promise<void> => {\n                    if (this.open !== targetOpenState) {\n                        return;\n                    }\n                    const eventName = targetOpenState\n                        ? 'sp-opened'\n                        : 'sp-closed';\n                    if (index > 0) {\n                        el.dispatchEvent(\n                            new OverlayStateEvent(eventName, this, {\n                                interaction: this.type,\n                                publish: false,\n                            })\n                        );\n                        return;\n                    }\n                    const reportChange = async (): Promise<void> => {\n                        if (this.open !== targetOpenState) {\n                            return;\n                        }\n                        await nextFrame();\n                        const hasVirtualTrigger =\n                            this.triggerElement instanceof VirtualTrigger;\n                        this.dispatchEvent(\n                            new OverlayStateEvent(eventName, this, {\n                                interaction: this.type,\n                                publish: hasVirtualTrigger,\n                            })\n                        );\n                        el.dispatchEvent(\n                            new OverlayStateEvent(eventName, this, {\n                                interaction: this.type,\n                                publish: false,\n                            })\n                        );\n                        if (this.triggerElement && !hasVirtualTrigger) {\n                            (this.triggerElement as HTMLElement).dispatchEvent(\n                                new OverlayStateEvent(eventName, this, {\n                                    interaction: this.type,\n                                    publish: true,\n                                })\n                            );\n                        }\n                        this.state = targetOpenState ? 'opened' : 'closed';\n                        this.returnFocus();\n                        // Ensure layout and paint are done and the Overlay is still closed before removing the slottable request.\n                        await nextFrame();\n                        await nextFrame();\n                        if (\n                            targetOpenState === this.open &&\n                            targetOpenState === false\n                        ) {\n                            this.requestSlottable();\n                        }\n                    };\n                    if (this.open !== targetOpenState) {\n                        return;\n                    }\n                    const open = isOpen(this.dialogEl);\n                    if (targetOpenState !== true && open && this.isConnected) {\n                        this.dialogEl.addEventListener(\n                            'beforetoggle',\n                            () => {\n                                reportChange();\n                            },\n                            { once: true }\n                        );\n                        this.dialogEl.hidePopover();\n                    } else {\n                        reportChange();\n                    }\n                };\n            this.elements.forEach((el, index) => {\n                guaranteedAllTransitionend(\n                    el,\n                    start(el, index),\n                    finish(el, index)\n                );\n            });\n            return focusEl;\n        }\n    }\n    return OverlayWithPopover;\n}\n"],
  "mappings": "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",
  "names": []
}
