{
  "version": 3,
  "sources": ["InteractionController.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type { ReactiveController } from '@spectrum-web-components/base';\nimport { AbstractOverlay } from './AbstractOverlay.js';\n\nexport enum InteractionTypes {\n    click = 'click',\n    hover = 'hover',\n    longpress = 'longpress',\n}\n\nexport const lastInteractionType = Symbol('lastInteractionType');\n\nexport type ControllerOptions = {\n    overlay?: AbstractOverlay;\n    handleOverlayReady?: (overlay: AbstractOverlay) => void;\n    isPersistent?: boolean;\n};\n\ntype InteractionTarget = HTMLElement & {\n    [lastInteractionType]?: InteractionTypes;\n};\n\nexport class InteractionController implements ReactiveController {\n    abortController!: AbortController;\n\n    get activelyOpening(): boolean {\n        return false;\n    }\n\n    private handleOverlayReady?: (overlay: AbstractOverlay) => void;\n\n    // Holds optimistic open state when an Overlay is not yet present\n    private isLazilyOpen = false;\n\n    public get open(): boolean {\n        return this.overlay?.open ?? this.isLazilyOpen;\n    }\n\n    /**\n     * Set `open` against the associated Overlay lazily.\n     */\n    public set open(open: boolean) {\n        if (open === this.open) return;\n        this.isLazilyOpen = open;\n        if (this.overlay) {\n            // If there already is an Overlay, apply the value of `open` directly.\n            this.overlay.open = open;\n            this.target[lastInteractionType] = this.type;\n            return;\n        }\n        if (!open) {\n            // When `open` moves to `false` and there is not yet an Overlay,\n            // assume that no Overlay and a closed Overlay are the same and return early.\n            return;\n        }\n        // When there is no Overlay and `open` is moving to `true`, lazily import/create\n        // an Overlay and apply that state to it.\n        customElements\n            .whenDefined('sp-overlay')\n            .then(async (): Promise<void> => {\n                const { Overlay } = await import('./Overlay.js');\n                this.overlay = new Overlay();\n                this.overlay.open = true;\n                this.target[lastInteractionType] = this.type;\n            });\n        import('@spectrum-web-components/overlay/sp-overlay.js');\n    }\n\n    public get overlay(): AbstractOverlay {\n        return this._overlay;\n    }\n\n    public set overlay(overlay: AbstractOverlay | undefined) {\n        if (!overlay) return;\n        if (this.overlay === overlay) return;\n        if (this.overlay) {\n            this.overlay.removeController(this);\n        }\n        this._overlay = overlay;\n        this.overlay.addController(this);\n        this.initOverlay();\n        this.prepareDescription(this.target);\n        this.handleOverlayReady?.(this.overlay);\n    }\n\n    private _overlay!: AbstractOverlay;\n\n    protected isPersistent = false;\n\n    type!: InteractionTypes;\n\n    constructor(\n        public target: InteractionTarget,\n        { overlay, isPersistent, handleOverlayReady }: ControllerOptions\n    ) {\n        this.isPersistent = !!isPersistent;\n        this.handleOverlayReady = handleOverlayReady;\n        if (this.isPersistent) {\n            this.init();\n        }\n        this.overlay = overlay;\n    }\n\n    prepareDescription(_: HTMLElement): void {}\n\n    releaseDescription(): void {}\n\n    shouldCompleteOpen(): void {}\n\n    /* c8 ignore next 3 */\n    init(): void {\n        // Abstract init() method.\n    }\n\n    /* c8 ignore next 3 */\n    initOverlay(): void {\n        // Abstract initOverlay() method.\n    }\n\n    abort(): void {\n        this.releaseDescription();\n        this.abortController?.abort();\n    }\n\n    hostConnected(): void {\n        this.init();\n    }\n\n    hostDisconnected(): void {\n        if (!this.isPersistent) {\n            this.abort();\n        }\n    }\n}\n"],
  "mappings": "aAeO,WAAK,kBAAAA,IACRA,EAAA,MAAQ,QACRA,EAAA,MAAQ,QACRA,EAAA,UAAY,YAHJA,IAAA,sBAML,aAAM,oBAAsB,OAAO,qBAAqB,EAYxD,aAAM,qBAAoD,CAqE7D,YACWC,EACP,CAAE,QAAAC,EAAS,aAAAC,EAAc,mBAAAC,CAAmB,EAC9C,CAFS,YAAAH,EA5DX,KAAQ,aAAe,GAuDvB,KAAU,aAAe,GAQrB,KAAK,aAAe,CAAC,CAACE,EACtB,KAAK,mBAAqBC,EACtB,KAAK,cACL,KAAK,KAAK,EAEd,KAAK,QAAUF,CACnB,CA5EA,IAAI,iBAA2B,CAC3B,MAAO,EACX,CAOA,IAAW,MAAgB,CA7C/B,IAAAG,EAAAC,EA8CQ,OAAOA,GAAAD,EAAA,KAAK,UAAL,YAAAA,EAAc,OAAd,KAAAC,EAAsB,KAAK,YACtC,CAKA,IAAW,KAAKC,EAAe,CAC3B,GAAIA,IAAS,KAAK,KAElB,IADA,KAAK,aAAeA,EAChB,KAAK,QAAS,CAEd,KAAK,QAAQ,KAAOA,EACpB,KAAK,OAAO,mBAAmB,EAAI,KAAK,KACxC,MACJ,CACKA,IAOL,eACK,YAAY,YAAY,EACxB,KAAK,SAA2B,CAC7B,KAAM,CAAE,QAAAC,CAAQ,EAAI,KAAM,QAAO,cAAc,EAC/C,KAAK,QAAU,IAAIA,EACnB,KAAK,QAAQ,KAAO,GACpB,KAAK,OAAO,mBAAmB,EAAI,KAAK,IAC5C,CAAC,EACL,OAAO,gDAAgD,GAC3D,CAEA,IAAW,SAA2B,CAClC,OAAO,KAAK,QAChB,CAEA,IAAW,QAAQN,EAAsC,CAnF7D,IAAAG,EAoFaH,GACD,KAAK,UAAYA,IACjB,KAAK,SACL,KAAK,QAAQ,iBAAiB,IAAI,EAEtC,KAAK,SAAWA,EAChB,KAAK,QAAQ,cAAc,IAAI,EAC/B,KAAK,YAAY,EACjB,KAAK,mBAAmB,KAAK,MAAM,GACnCG,EAAA,KAAK,qBAAL,MAAAA,EAAA,UAA0B,KAAK,SACnC,CAoBA,mBAAmBI,EAAsB,CAAC,CAE1C,oBAA2B,CAAC,CAE5B,oBAA2B,CAAC,CAG5B,MAAa,CAEb,CAGA,aAAoB,CAEpB,CAEA,OAAc,CAlIlB,IAAAJ,EAmIQ,KAAK,mBAAmB,GACxBA,EAAA,KAAK,kBAAL,MAAAA,EAAsB,OAC1B,CAEA,eAAsB,CAClB,KAAK,KAAK,CACd,CAEA,kBAAyB,CAChB,KAAK,cACN,KAAK,MAAM,CAEnB,CACJ",
  "names": ["InteractionTypes", "target", "overlay", "isPersistent", "handleOverlayReady", "_a", "_b", "open", "Overlay", "_"]
}
