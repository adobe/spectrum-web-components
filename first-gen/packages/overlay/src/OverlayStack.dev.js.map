{
  "version": 3,
  "sources": ["OverlayStack.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { Overlay } from './Overlay.dev.js'\n\nconst supportsPopover = 'showPopover' in document.createElement('div');\n\nclass OverlayStack {\n    private get document(): Document {\n        return this.root.ownerDocument /* c8 ignore next */ || document;\n    }\n\n    private pointerdownPath?: EventTarget[];\n\n    private lastOverlay?: Overlay;\n\n    private root: HTMLElement = document.body;\n\n    stack: Overlay[] = [];\n\n    constructor() {\n        this.bindEvents();\n    }\n\n    bindEvents(): void {\n        this.document.addEventListener('pointerdown', this.handlePointerdown);\n        this.document.addEventListener('pointerup', this.handlePointerup);\n        this.document.addEventListener('keydown', this.handleKeydown);\n        this.document.addEventListener('scroll', this.handleScroll, {\n            capture: true,\n        });\n    }\n\n    private handleScroll = (event: Event): void => {\n        // Only handle document/body level scrolls\n        // Skip any component scrolls\n        if (\n            event.target !== document &&\n            event.target !== document.documentElement &&\n            event.target !== document.body\n        ) {\n            return;\n        }\n        // Update positions of all open overlays\n        this.stack.forEach((overlay) => {\n            if (overlay.open) {\n                // Don't close pickers on document scroll\n                if (\n                    overlay.type === 'auto' &&\n                    overlay.triggerElement instanceof HTMLElement &&\n                    overlay.triggerElement.closest('sp-picker, sp-action-menu')\n                ) {\n                    event.stopPropagation();\n                }\n                // Update the overlay's position by dispatching the update event\n                document.dispatchEvent(\n                    new CustomEvent('sp-update-overlays', {\n                        bubbles: true,\n                        composed: true,\n                        cancelable: true,\n                    })\n                );\n            }\n        });\n    };\n\n    private closeOverlay(overlay: Overlay): void {\n        const overlayIndex = this.stack.indexOf(overlay);\n        if (overlayIndex > -1) {\n            this.stack.splice(overlayIndex, 1);\n        }\n        overlay.open = false;\n    }\n\n    /**\n     * Cach the `pointerdownTarget` for later testing\n     *\n     * @param event {ClickEvent}\n     */\n    handlePointerdown = (event: Event): void => {\n        this.pointerdownPath = event.composedPath();\n        this.lastOverlay = this.stack[this.stack.length - 1];\n    };\n\n    /**\n     * Close all overlays that are not ancestors of this click event\n     *\n     * @param event {ClickEvent}\n     */\n    handlePointerup = (): void => {\n        // Test against the composed path in `pointerdown` in case the visitor moved their\n        // pointer during the course of the interaction.\n        // Ensure that this value is cleared even if the work in this method goes undone.\n        const composedPath = this.pointerdownPath;\n        this.pointerdownPath = undefined;\n        if (!this.stack.length) return;\n        if (!composedPath?.length) return;\n        const lastOverlay = this.lastOverlay;\n        this.lastOverlay = undefined;\n\n        const lastIndex = this.stack.length - 1;\n        const nonAncestorOverlays = this.stack.filter((overlay, i) => {\n            const inStack = composedPath.find(\n                (el) =>\n                    // The Overlay is in the stack\n                    el === overlay ||\n                    // The Overlay trigger is in the stack and the Overlay is a \"hint\"\n                    (el === overlay?.triggerElement &&\n                        'hint' === overlay?.type) ||\n                    // The last Overlay in the stack is not the last Overlay at `pointerdown` time and has a\n                    // `triggerInteraction` of \"longpress\", meaning it was opened by this poitner interaction\n                    (i === lastIndex &&\n                        overlay !== lastOverlay &&\n                        overlay.triggerInteraction === 'longpress')\n            );\n            return (\n                !inStack &&\n                !overlay.shouldPreventClose() &&\n                overlay.type !== 'manual' &&\n                // Don't close if this overlay is modal and not on top of the overlay stack.\n                !(overlay.type === 'modal' && lastOverlay !== overlay)\n            );\n        }) as Overlay[];\n        nonAncestorOverlays.reverse();\n        nonAncestorOverlays.forEach((overlay) => {\n            this.closeOverlay(overlay);\n            let parentToClose = overlay.parentOverlayToForceClose;\n            while (parentToClose) {\n                this.closeOverlay(parentToClose);\n                parentToClose = parentToClose.parentOverlayToForceClose;\n            }\n        });\n    };\n\n    handleBeforetoggle = (event: Event): void => {\n        const { target, newState: open } = event as Event & {\n            newState: string;\n        };\n        if (open === 'open') return;\n        this.closeOverlay(target as Overlay);\n    };\n\n    private handleKeydown = (event: KeyboardEvent): void => {\n        if (event.code !== 'Escape') return;\n        if (!this.stack.length) return;\n        const last = this.stack[this.stack.length - 1];\n        if (last?.type === 'page') {\n            event.preventDefault();\n            return;\n        }\n        if (last?.type === 'manual') {\n            // Manual overlays should close on \"Escape\" key, but not when losing focus or interacting with other parts of the page.\n            this.closeOverlay(last);\n            return;\n        }\n        if (supportsPopover) return;\n        if (!last) return;\n        this.closeOverlay(last);\n    };\n\n    /**\n     * Get an array of Overlays that all share the same trigger element.\n     *\n     * @param triggerElement {HTMLELement}\n     * @returns {Overlay[]}\n     */\n    overlaysByTriggerElement(triggerElement: HTMLElement): Overlay[] {\n        return this.stack.filter(\n            (overlay) => overlay.triggerElement === triggerElement\n        );\n    }\n\n    /**\n     * When overlays are added manage the open state of exisiting overlays appropriately:\n     * - 'modal': should close other non-'modal' and non-'manual' overlays\n     * - 'page': should close other non-'modal' and non-'manual' overlays\n     * - 'auto': should close other 'auto' overlays and other 'hint' overlays, but not 'manual' overlays\n     * - 'manual': shouldn't close other overlays\n     * - 'hint': shouldn't close other overlays and give way to all other overlays on a trigger\n     */\n    add(overlay: Overlay): void {\n        if (this.stack.includes(overlay)) {\n            const overlayIndex = this.stack.indexOf(overlay);\n            if (overlayIndex > -1) {\n                this.stack.splice(overlayIndex, 1);\n                this.stack.push(overlay);\n            }\n            return;\n        }\n        if (\n            overlay.type === 'auto' ||\n            overlay.type === 'modal' ||\n            overlay.type === 'page'\n        ) {\n            // manage closing open overlays\n            const queryPathEventName = 'sp-overlay-query-path';\n            const queryPathEvent = new Event(queryPathEventName, {\n                composed: true,\n                bubbles: true,\n            });\n            overlay.addEventListener(\n                queryPathEventName,\n                (event: Event) => {\n                    const path = event.composedPath();\n                    this.stack.forEach((overlayEl) => {\n                        const inPath = path.find((el) => el === overlayEl);\n                        if (\n                            !inPath &&\n                            overlayEl.type !== 'manual' &&\n                            overlayEl.type !== 'modal'\n                        ) {\n                            this.closeOverlay(overlayEl);\n                        }\n                    });\n                },\n                { once: true }\n            );\n            overlay.dispatchEvent(queryPathEvent);\n        } else if (overlay.type === 'hint') {\n            const hasPrevious = this.stack.some((overlayEl) => {\n                return (\n                    overlayEl.type !== 'manual' &&\n                    overlayEl.triggerElement &&\n                    overlayEl.triggerElement === overlay.triggerElement\n                );\n            });\n            if (hasPrevious) {\n                overlay.open = false;\n                return;\n            }\n            this.stack.forEach((overlayEl) => {\n                if (overlayEl.type === 'hint') {\n                    this.closeOverlay(overlayEl);\n                }\n            });\n        }\n        requestAnimationFrame(() => {\n            this.stack.push(overlay);\n            overlay.addEventListener('beforetoggle', this.handleBeforetoggle, {\n                once: true,\n            });\n        });\n    }\n\n    remove(overlay: Overlay): void {\n        this.closeOverlay(overlay);\n    }\n}\n\nexport const overlayStack = new OverlayStack();\n"],
  "mappings": "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",
  "names": []
}
