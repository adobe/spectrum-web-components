{
  "version": 3,
  "sources": ["OverlayNoPopover.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n    firstFocusableIn,\n    firstFocusableSlottedIn,\n} from '@spectrum-web-components/shared/src/first-focusable-in.js';\nimport type { SpectrumElement } from '@spectrum-web-components/base';\nimport { VirtualTrigger } from './VirtualTrigger.js';\nimport { Constructor, OpenableElement } from './overlay-types.js';\nimport {\n    guaranteedAllTransitionend,\n    nextFrame,\n    overlayTimer,\n} from './AbstractOverlay.js';\nimport {\n    BeforetoggleClosedEvent,\n    BeforetoggleOpenEvent,\n    OverlayStateEvent,\n} from './events.js';\nimport type { AbstractOverlay } from './AbstractOverlay.js';\nimport { userFocusableSelector } from '@spectrum-web-components/shared';\n\nexport function OverlayNoPopover<T extends Constructor<AbstractOverlay>>(\n    constructor: T\n): T & Constructor<SpectrumElement> {\n    class OverlayWithNoPopover extends constructor {\n        protected override async managePopoverOpen(): Promise<void> {\n            await this.managePosition();\n        }\n\n        protected override async manageDelay(\n            targetOpenState: boolean\n        ): Promise<void> {\n            if (targetOpenState === false || targetOpenState !== this.open) {\n                overlayTimer.close(this);\n                return;\n            }\n            if (this.delayed) {\n                const cancelled = await overlayTimer.openTimer(this);\n                if (cancelled) {\n                    this.open = !targetOpenState;\n                }\n            }\n        }\n\n        protected override async ensureOnDOM(\n            _targetOpenState: boolean\n        ): Promise<void> {\n            // force the browser to paint\n            document.body.offsetHeight;\n        }\n\n        protected override async makeTransition(\n            targetOpenState: boolean\n        ): Promise<HTMLElement | null> {\n            if (this.open !== targetOpenState) {\n                return null;\n            }\n            let focusEl = null as HTMLElement | null;\n            const start = (el: OpenableElement, index: number) => (): void => {\n                if (targetOpenState !== this.open) {\n                    return;\n                }\n                el.open = targetOpenState;\n                if (index === 0) {\n                    const event = targetOpenState\n                        ? BeforetoggleOpenEvent\n                        : BeforetoggleClosedEvent;\n                    this.dispatchEvent(new event());\n                }\n                if (targetOpenState !== true) {\n                    return;\n                }\n                if (el.matches(userFocusableSelector)) {\n                    focusEl = el;\n                }\n                focusEl = focusEl || firstFocusableIn(el);\n                if (focusEl) {\n                    return;\n                }\n                const childSlots = el.querySelectorAll('slot');\n                childSlots.forEach((slot) => {\n                    if (!focusEl) {\n                        focusEl = firstFocusableSlottedIn(slot);\n                    }\n                });\n            };\n            const finish =\n                (el: OpenableElement, index: number) =>\n                async (): Promise<void> => {\n                    if (this.open !== targetOpenState) {\n                        return;\n                    }\n                    const eventName = targetOpenState\n                        ? 'sp-opened'\n                        : 'sp-closed';\n                    el.dispatchEvent(\n                        new OverlayStateEvent(eventName, this, {\n                            interaction: this.type,\n                        })\n                    );\n                    if (index > 0) {\n                        return;\n                    }\n                    const hasVirtualTrigger =\n                        this.triggerElement instanceof VirtualTrigger;\n                    this.dispatchEvent(\n                        new OverlayStateEvent(eventName, this, {\n                            interaction: this.type,\n                            publish: hasVirtualTrigger,\n                        })\n                    );\n                    if (this.triggerElement && !hasVirtualTrigger) {\n                        (this.triggerElement as HTMLElement).dispatchEvent(\n                            new OverlayStateEvent(eventName, this, {\n                                interaction: this.type,\n                                publish: true,\n                            })\n                        );\n                    }\n                    this.state = targetOpenState ? 'opened' : 'closed';\n                    this.returnFocus();\n                    // Ensure layout and paint are done and the Overlay is still closed before removing the slottable request.\n                    await nextFrame();\n                    await nextFrame();\n                    if (\n                        targetOpenState === this.open &&\n                        targetOpenState === false\n                    ) {\n                        this.requestSlottable();\n                    }\n                };\n            this.elements.forEach((el, index) => {\n                guaranteedAllTransitionend(\n                    el,\n                    start(el, index),\n                    finish(el, index)\n                );\n            });\n            return focusEl;\n        }\n    }\n    return OverlayWithNoPopover;\n}\n"],
  "mappings": "aAWA,OACI,oBAAAA,EACA,2BAAAC,MACG,4DAEP,OAAS,kBAAAC,MAAsB,sBAE/B,OACI,8BAAAC,EACA,aAAAC,EACA,gBAAAC,MACG,uBACP,OACI,2BAAAC,EACA,yBAAAC,EACA,qBAAAC,MACG,cAEP,OAAS,yBAAAC,MAA6B,kCAE/B,gBAAS,iBACZC,EACgC,CAChC,MAAMC,UAA6BD,CAAY,CAC3C,MAAyB,mBAAmC,CACxD,MAAM,KAAK,eAAe,CAC9B,CAEA,MAAyB,YACrBE,EACa,CACb,GAAIA,IAAoB,IAASA,IAAoB,KAAK,KAAM,CAC5DP,EAAa,MAAM,IAAI,EACvB,MACJ,CACI,KAAK,SACa,MAAMA,EAAa,UAAU,IAAI,IAE/C,KAAK,KAAO,CAACO,EAGzB,CAEA,MAAyB,YACrBC,EACa,CAEb,SAAS,KAAK,YAClB,CAEA,MAAyB,eACrBD,EAC2B,CAC3B,GAAI,KAAK,OAASA,EACd,OAAO,KAEX,IAAIE,EAAU,KACd,MAAMC,EAAQ,CAACC,EAAqBC,IAAkB,IAAY,CAC9D,GAAIL,IAAoB,KAAK,KACzB,OAGJ,GADAI,EAAG,KAAOJ,EACNK,IAAU,EAAG,CACb,MAAMC,EAAQN,EACRL,EACAD,EACN,KAAK,cAAc,IAAIY,CAAO,CAClC,CAQA,GAPIN,IAAoB,KAGpBI,EAAG,QAAQP,CAAqB,IAChCK,EAAUE,GAEdF,EAAUA,GAAWd,EAAiBgB,CAAE,EACpCF,GACA,OAEeE,EAAG,iBAAiB,MAAM,EAClC,QAASG,GAAS,CACpBL,IACDA,EAAUb,EAAwBkB,CAAI,EAE9C,CAAC,CACL,EACMC,EACF,CAACJ,EAAqBC,IACtB,SAA2B,CACvB,GAAI,KAAK,OAASL,EACd,OAEJ,MAAMS,EAAYT,EACZ,YACA,YAMN,GALAI,EAAG,cACC,IAAIR,EAAkBa,EAAW,KAAM,CACnC,YAAa,KAAK,IACtB,CAAC,CACL,EACIJ,EAAQ,EACR,OAEJ,MAAMK,EACF,KAAK,0BAA0BpB,EACnC,KAAK,cACD,IAAIM,EAAkBa,EAAW,KAAM,CACnC,YAAa,KAAK,KAClB,QAASC,CACb,CAAC,CACL,EACI,KAAK,gBAAkB,CAACA,GACvB,KAAK,eAA+B,cACjC,IAAId,EAAkBa,EAAW,KAAM,CACnC,YAAa,KAAK,KAClB,QAAS,EACb,CAAC,CACL,EAEJ,KAAK,MAAQT,EAAkB,SAAW,SAC1C,KAAK,YAAY,EAEjB,MAAMR,EAAU,EAChB,MAAMA,EAAU,EAEZQ,IAAoB,KAAK,MACzBA,IAAoB,IAEpB,KAAK,iBAAiB,CAE9B,EACJ,YAAK,SAAS,QAAQ,CAACI,EAAIC,IAAU,CACjCd,EACIa,EACAD,EAAMC,EAAIC,CAAK,EACfG,EAAOJ,EAAIC,CAAK,CACpB,CACJ,CAAC,EACMH,CACX,CACJ,CACA,OAAOH,CACX",
  "names": ["firstFocusableIn", "firstFocusableSlottedIn", "VirtualTrigger", "guaranteedAllTransitionend", "nextFrame", "overlayTimer", "BeforetoggleClosedEvent", "BeforetoggleOpenEvent", "OverlayStateEvent", "userFocusableSelector", "constructor", "OverlayWithNoPopover", "targetOpenState", "_targetOpenState", "focusEl", "start", "el", "index", "event", "slot", "finish", "eventName", "hasVirtualTrigger"]
}
