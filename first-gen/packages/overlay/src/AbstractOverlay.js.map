{
  "version": 3,
  "sources": ["AbstractOverlay.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { SpectrumElement } from '@spectrum-web-components/base';\nimport { reparentChildren } from '@spectrum-web-components/shared/src/reparent-children.js';\n\nimport type {\n    OpenableElement,\n    OverlayOptions,\n    OverlayOptionsV1,\n    OverlayState,\n    OverlayTypes,\n    Placement,\n    TriggerInteractionsV1,\n} from './overlay-types.js';\nimport type { Overlay } from './Overlay.js';\nimport type { VirtualTrigger } from './VirtualTrigger.js';\nimport { OverlayTimer } from './overlay-timer.js';\nimport type { PlacementController } from './PlacementController.js';\nimport type { ElementResolutionController } from '@spectrum-web-components/reactive-controllers/src/ElementResolution.js';\n\nexport const overlayTimer = new OverlayTimer();\n\nexport const noop = (): void => {\n    return;\n};\n\n/**\n * Apply a \"transitionend\" listener to an element that may not transition but\n * guarantee the callback will be fired either way.\n *\n * @param el {HTMLElement} - Target of the \"transition\" listeners.\n * @param action {Function} - Method to trigger the \"transition\".\n * @param cb {Function} - Callback to trigger when the \"transition\" has ended.\n */\nexport const guaranteedAllTransitionend = (\n    el: HTMLElement,\n    action: () => void,\n    cb: () => void\n): void => {\n    const abortController = new AbortController();\n    const runningTransitions = new Map<string, number>();\n    const cleanup = (): void => {\n        abortController.abort();\n        cb();\n    };\n    let guarantee2: number;\n    let guarantee3: number;\n    // WebKit fires `transitionrun` a little earlier, the multiple guarantees here\n    // allow WebKit to be caught, but doesn't remove the animation listener until\n    // after it would have fired in Chromium.\n    const guarantee1 = requestAnimationFrame(() => {\n        guarantee2 = requestAnimationFrame(() => {\n            guarantee3 = requestAnimationFrame(() => {\n                cleanup();\n            });\n        });\n    });\n    const handleTransitionend = (event: TransitionEvent): void => {\n        if (event.target !== el) {\n            return;\n        }\n        runningTransitions.set(\n            event.propertyName,\n            (runningTransitions.get(event.propertyName) as number) - 1\n        );\n        if (!runningTransitions.get(event.propertyName)) {\n            runningTransitions.delete(event.propertyName);\n        }\n        if (runningTransitions.size === 0) {\n            cleanup();\n        }\n    };\n    const handleTransitionrun = (event: TransitionEvent): void => {\n        if (event.target !== el) {\n            return;\n        }\n        if (!runningTransitions.has(event.propertyName)) {\n            runningTransitions.set(event.propertyName, 0);\n        }\n        runningTransitions.set(\n            event.propertyName,\n            (runningTransitions.get(event.propertyName) as number) + 1\n        );\n        cancelAnimationFrame(guarantee1);\n        cancelAnimationFrame(guarantee2);\n        cancelAnimationFrame(guarantee3);\n    };\n    el.addEventListener('transitionrun', handleTransitionrun, {\n        signal: abortController.signal,\n    });\n    el.addEventListener('transitionend', handleTransitionend, {\n        signal: abortController.signal,\n    });\n    el.addEventListener('transitioncancel', handleTransitionend, {\n        signal: abortController.signal,\n    });\n    action();\n};\n\nexport function nextFrame(): Promise<void> {\n    return new Promise((res) => requestAnimationFrame(() => res()));\n}\n\n/**\n * Abstract Overlay base class so that property tyings and imperative API\n * interfaces can be held separate from the actual class definition.\n */\nexport class AbstractOverlay extends SpectrumElement {\n    protected async applyFocus(\n        _targetOpenState: boolean,\n        _focusEl: HTMLElement | null\n    ): Promise<void> {\n        return;\n    }\n    /* c8 ignore next 6 */\n    get delayed(): boolean {\n        return false;\n    }\n    set delayed(_delayed: boolean) {\n        return;\n    }\n    dialogEl!: HTMLDialogElement & {\n        showPopover(): void;\n        hidePopover(): void;\n    };\n    /* c8 ignore next 6 */\n    get disabled(): boolean {\n        return false;\n    }\n    set disabled(_disabled: boolean) {\n        return;\n    }\n    dispose = noop;\n    protected get elementResolver(): ElementResolutionController {\n        return this._elementResolver;\n    }\n    protected set elementResolver(controller) {\n        this._elementResolver = controller;\n    }\n    protected _elementResolver!: ElementResolutionController;\n    /* c8 ignore next 3 */\n    protected async ensureOnDOM(_targetOpenState: boolean): Promise<void> {\n        return;\n    }\n    elements!: OpenableElement[];\n    /* c8 ignore next 5 */\n    protected async makeTransition(\n        _targetOpenState: boolean\n    ): Promise<HTMLElement | null> {\n        return null;\n    }\n    protected async manageDelay(_targetOpenState: boolean): Promise<void> {\n        return;\n    }\n    /* c8 ignore next 3 */\n    protected async managePopoverOpen(): Promise<void> {\n        return;\n    }\n    /* c8 ignore next 3 */\n    protected managePosition(): void {\n        return;\n    }\n    protected offset: number | [number, number] = 0;\n    /* c8 ignore next 6 */\n    get open(): boolean {\n        return false;\n    }\n    set open(_open: boolean) {\n        return;\n    }\n    placement?: Placement;\n    protected get placementController(): PlacementController {\n        return this._placementController;\n    }\n    protected set placementController(controller) {\n        this._placementController = controller;\n    }\n    protected _placementController!: PlacementController;\n    receivesFocus!: 'true' | 'false' | 'auto';\n    protected requestSlottable(): void {}\n    protected returnFocus(): void {\n        return;\n    }\n    /* c8 ignore next 6 */\n    get state(): OverlayState {\n        return 'closed';\n    }\n    set state(_state: OverlayState) {\n        return;\n    }\n    protected _state!: OverlayState;\n    triggerElement!: HTMLElement | VirtualTrigger | null;\n    type!: OverlayTypes;\n    willPreventClose = false;\n    /* c8 ignore next 3 */\n    public manuallyKeepOpen(): void {\n        return;\n    }\n\n    public static update(): void {\n        const overlayUpdateEvent = new CustomEvent('sp-update-overlays', {\n            bubbles: true,\n            composed: true,\n            cancelable: true,\n        });\n        document.dispatchEvent(overlayUpdateEvent);\n    }\n\n    /**\n     * Overloaded imperative API entry point that allows for both the pre-0.37.0\n     * argument signature as well as the post-0.37.0 signature. This allows for\n     * consumers to continue to leverage it as they had been in previous releases\n     * while also surfacing the more feature-rich API that has been made available.\n     */\n    public static async open(\n        trigger: HTMLElement,\n        interaction: TriggerInteractionsV1,\n        content: HTMLElement,\n        optionsV1: OverlayOptionsV1\n    ): Promise<() => void>;\n    public static async open(\n        content: HTMLElement,\n        options?: OverlayOptions\n    ): Promise<Overlay>;\n    public static async open(\n        triggerOrContent: HTMLElement,\n        interactionOrOptions:\n            | TriggerInteractionsV1\n            | OverlayOptions\n            | undefined,\n        content?: HTMLElement,\n        optionsV1?: OverlayOptionsV1\n    ): Promise<Overlay | (() => void)> {\n        await import('@spectrum-web-components/overlay/sp-overlay.js');\n        const v2 = arguments.length === 2;\n        const overlayContent = content || triggerOrContent;\n        // Use the `this` from the `static` method context rather than a\n        // specific imported constructor to prevent opening a circular dependency.\n        const overlay = new this() as Overlay;\n        let restored = false;\n        overlay.dispose = () => {\n            overlay.addEventListener('sp-closed', () => {\n                if (!restored) {\n                    restoreContent();\n                    restored = true;\n                }\n                requestAnimationFrame(() => {\n                    overlay.remove();\n                });\n            });\n            overlay.open = false;\n            overlay.dispose = noop;\n        };\n        /**\n         * Since content must exist in an <sp-overlay>, we need a way to get it there.\n         * The best & most-direct way is to declaratively use an <sp-overlay> element,\n         * but for imperative users, we'll reparent content into an overlay that we've created for them.\n         **/\n        const restoreContent = reparentChildren([overlayContent], overlay, {\n            position: 'beforeend',\n            prepareCallback: (el) => {\n                // Ensure that content to be overlaid is no longer targetted to a specific `slot`.\n                // This allow for it to be visible in the overlaid context.\n                const slot = el.slot;\n                el.removeAttribute('slot');\n                return () => {\n                    el.slot = slot;\n                };\n            },\n        });\n\n        const v1 = !v2 && overlayContent && optionsV1;\n        if (v1) {\n            if (window.__swc.DEBUG) {\n                window.__swc.warn(\n                    overlay,\n                    `You are interacting with an ${overlay.localName} element via a deprecated imperative API. This API will be removed in a future version of the SWC library. Consider leveraging an ${overlay.localName} directly.`,\n                    'https://opensource.adobe.com/spectrum-web-components/components/overlay/',\n                    { level: 'deprecation' }\n                );\n            }\n            const trigger = triggerOrContent;\n            const interaction = interactionOrOptions;\n            const options = optionsV1;\n            AbstractOverlay.applyOptions(overlay, {\n                ...options,\n                delayed:\n                    options.delayed || overlayContent.hasAttribute('delayed'),\n                trigger: options.virtualTrigger || trigger,\n                type:\n                    interaction === 'modal'\n                        ? 'modal'\n                        : interaction === 'hover'\n                          ? 'hint'\n                          : 'auto',\n            });\n            trigger.insertAdjacentElement('afterend', overlay);\n            await overlay.updateComplete;\n            overlay.open = true;\n            return overlay.dispose;\n        }\n\n        const options = interactionOrOptions as OverlayOptions;\n        overlay.append(overlayContent);\n        AbstractOverlay.applyOptions(overlay, {\n            ...options,\n            delayed: options.delayed || overlayContent.hasAttribute('delayed'),\n        });\n        overlay.updateComplete.then(() => {\n            // Do we want to \"open\" this path, or leave that to the consumer?\n            overlay.open = true;\n        });\n        return overlay;\n    }\n\n    static applyOptions(\n        overlay: AbstractOverlay,\n        options: OverlayOptions\n    ): void {\n        overlay.delayed = !!options.delayed;\n        overlay.receivesFocus = options.receivesFocus ?? 'auto';\n        overlay.triggerElement = options.trigger || null;\n        overlay.type = options.type || 'modal';\n        overlay.offset = options.offset ?? 0;\n        overlay.placement = options.placement;\n        overlay.willPreventClose = !!options.notImmediatelyClosable;\n    }\n\n    override disconnectedCallback(): void {\n        super.disconnectedCallback();\n    }\n}\n"],
  "mappings": "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",
  "names": ["SpectrumElement", "reparentChildren", "OverlayTimer", "el", "action", "cb", "abortController", "runningTransitions", "cleanup", "guarantee2", "guarantee3", "guarantee1", "handleTransitionend", "event", "handleTransitionrun", "res", "_targetOpenState", "_focusEl", "_delayed", "_disabled", "controller", "_open", "_state", "overlayUpdateEvent", "triggerOrContent", "interactionOrOptions", "content", "optionsV1", "v2", "overlayContent", "overlay", "restored", "restoreContent", "slot", "trigger", "interaction", "options", "_a", "_b"]
}
