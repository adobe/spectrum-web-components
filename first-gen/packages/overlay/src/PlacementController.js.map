{
  "version": 3,
  "sources": ["PlacementController.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type {\n    ReactiveController,\n    ReactiveElement,\n} from '@spectrum-web-components/base';\nimport {\n    arrow,\n    autoUpdate,\n    computePosition,\n    flip,\n    offset,\n    Placement,\n    shift,\n    size,\n} from '@floating-ui/dom';\nimport type { VirtualTrigger } from './VirtualTrigger.js';\nimport type { OpenableElement } from './overlay-types.js';\nimport type { Overlay } from './Overlay.js';\n\ntype OverlayOptionsV1 = {\n    abortPromise?: Promise<boolean>;\n    delayed?: boolean;\n    offset?: number | [number, number]; // supporting multi-axis\n    placement: Placement;\n    notImmediatelyClosable?: boolean; // rename or place behind other API options\n    receivesFocus?: 'auto';\n    root?: HTMLElement;\n    tipPadding?: number;\n    trigger: HTMLElement | VirtualTrigger;\n    type?: 'modal' | 'page' | 'hint' | 'auto' | 'manual';\n};\n\n/**\n * Rounds a number by the device pixel ratio (DPR).\n *\n * @param {number} [num] - The number to round.\n * @returns {number} The rounded number.\n */\nfunction roundByDPR(num?: number): number {\n    if (typeof num === 'undefined') return 0;\n    const dpr = window.devicePixelRatio || 1;\n    return Math.round(num * dpr) / dpr;\n}\n\n// Minimum distance required between the overlay and the edge of the container.\n// See: https://spectrum.adobe.com/page/popover/#Container-padding\nconst REQUIRED_DISTANCE_TO_EDGE = 8;\n// Minimum height for the overlay.\n// See: https://github.com/adobe/spectrum-web-components/issues/910\nconst MIN_OVERLAY_HEIGHT = 100;\n\n/**\n * Gets fallback placements for the overlay based on the initial placement.\n *\n * @param {Placement} placement - The initial placement of the overlay.\n * @returns {Placement[]} An array of fallback placements.\n */\nconst getFallbackPlacements = (placement: Placement): Placement[] => {\n    const fallbacks: Record<Placement, Placement[]> = {\n        left: ['right', 'bottom', 'top'],\n        'left-start': ['right-start', 'bottom', 'top'],\n        'left-end': ['right-end', 'bottom', 'top'],\n        right: ['left', 'bottom', 'top'],\n        'right-start': ['left-start', 'bottom', 'top'],\n        'right-end': ['left-end', 'bottom', 'top'],\n        top: ['bottom', 'left', 'right'],\n        'top-start': ['bottom-start', 'left', 'right'],\n        'top-end': ['bottom-end', 'left', 'right'],\n        bottom: ['top', 'left', 'right'],\n        'bottom-start': ['top-start', 'left', 'right'],\n        'bottom-end': ['top-end', 'left', 'right'],\n    };\n    return fallbacks[placement] ?? [placement];\n};\n\n/**\n * Symbol used to indicate that the placement has been updated.\n */\nexport const placementUpdatedSymbol = Symbol('placement updated');\n\n/**\n * Controller for managing the placement of an overlay.\n *\n * This class implements the ReactiveController interface and provides methods\n * for managing the positioning and constraints of an overlay element.\n */\nexport class PlacementController implements ReactiveController {\n    /**\n     * Function to clean up resources when the controller is no longer needed.\n     *\n     * @private\n     */\n    private cleanup?: () => void;\n\n    /**\n     * Initial height of the overlay.\n     *\n     * @type {number}\n     */\n    initialHeight?: number;\n\n    /**\n     * Indicates whether the overlay is constrained by available space.\n     *\n     * @type {boolean}\n     */\n    isConstrained?: boolean;\n\n    /**\n     * The host element that uses this controller.\n     *\n     * @private\n     * @type {ReactiveElement & { elements: OpenableElement[] }}\n     */\n    private host!: ReactiveElement & { elements: OpenableElement[] };\n\n    /**\n     * Options for configuring the overlay placement.\n     *\n     * @private\n     * @type {OverlayOptionsV1}\n     */\n    private options!: OverlayOptionsV1;\n\n    /**\n     * A WeakMap to store the original placements of overlay elements.\n     *\n     * @private\n     * @type {WeakMap<HTMLElement, Placement>}\n     */\n    private originalPlacements = new WeakMap<HTMLElement, Placement>();\n\n    /**\n     * The target element for the overlay.\n     *\n     * @private\n     * @type {HTMLElement}\n     */\n    private target!: HTMLElement;\n\n    /**\n     * Creates an instance of the PlacementController.\n     *\n     * @param {ReactiveElement & { elements: OpenableElement[] }} host - The host element that uses this controller.\n     */\n    constructor(host: ReactiveElement & { elements: OpenableElement[] }) {\n        this.host = host;\n        // Add the controller after the MutationObserver has been created in preparation\n        // for the `hostConnected`/`hostDisconnected` callbacks to be run.\n        this.host.addController(this);\n    }\n\n    /**\n     * Places the overlay relative to the target element.\n     *\n     * This method sets up the necessary configurations and event listeners to manage the\n     * positioning and constraints of the overlay element.\n     *\n     * @param {HTMLElement} [target=this.target] - The target element for the overlay.\n     * @param {OverlayOptionsV1} [options=this.options] - The options for configuring the overlay placement.\n     * @returns {Promise<void>} A promise that resolves when the overlay has been placed.\n     */\n    public async placeOverlay(\n        target: HTMLElement = this.target,\n        options: OverlayOptionsV1 = this.options\n    ): Promise<void> {\n        // Set the target and options for the overlay.\n        this.target = target;\n        this.options = options;\n        if (!target || !options) return;\n\n        // Set up auto-update for ancestor resize events.\n        const cleanupAncestorResize = autoUpdate(\n            options.trigger,\n            target,\n            this.closeForAncestorUpdate,\n            {\n                ancestorResize: false,\n                elementResize: false,\n                layoutShift: false,\n            }\n        );\n\n        // Set up auto-update for element resize events.\n        const cleanupElementResize = autoUpdate(\n            options.trigger,\n            target,\n            this.updatePlacement,\n            {\n                ancestorScroll: false,\n            }\n        );\n\n        // Define the cleanup function to remove event listeners and reset placements.\n        this.cleanup = () => {\n            this.host.elements?.forEach((element) => {\n                element.addEventListener(\n                    'sp-closed',\n                    () => {\n                        const placement = this.originalPlacements.get(element);\n\n                        if (placement) {\n                            element.setAttribute('placement', placement);\n                        }\n\n                        this.originalPlacements.delete(element);\n                    },\n                    { once: true }\n                );\n            });\n            cleanupAncestorResize();\n            cleanupElementResize();\n        };\n    }\n\n    /**\n     * Flag to allow or disallow placement updates.\n     *\n     * @type {boolean}\n     */\n    public allowPlacementUpdate = false;\n\n    /**\n     * Closes the overlay if an ancestor element is updated.\n     *\n     * This method checks if placement updates are allowed and if the overlay type is not 'modal'.\n     * If these conditions are met and a cleanup function is defined, it dispatches a 'close' event\n     * on the target element to close the overlay.\n     */\n    closeForAncestorUpdate = (): void => {\n        if (\n            !this.allowPlacementUpdate &&\n            this.options.type !== 'modal' &&\n            this.cleanup\n        ) {\n            // Dispatch a 'close' event to close the overlay.\n            this.target.dispatchEvent(new Event('close', { bubbles: true }));\n        }\n\n        // Reset the flag to disallow placement updates.\n        this.allowPlacementUpdate = false;\n    };\n\n    /**\n     * Updates the placement of the overlay.\n     *\n     * This method calls the computePlacement method to recalculate the overlay's position.\n     *\n     * @private\n     */\n    private updatePlacement = (): void => {\n        this.computePlacement();\n    };\n\n    /**\n     * Computes the placement of the overlay relative to the target element.\n     *\n     * This method calculates the necessary positioning and constraints for the overlay element\n     * using various middleware functions. It updates the overlay's style and attributes based\n     * on the computed position.\n     *\n     * @returns {Promise<void>} A promise that resolves when the placement has been computed.\n     */\n    async computePlacement(): Promise<void> {\n        const { options, target } = this;\n\n        // Wait for document fonts to be ready before computing placement.\n        await (document.fonts ? document.fonts.ready : Promise.resolve());\n\n        // Determine the flip middleware based on the type of trigger element.\n        const flipMiddleware = !(options.trigger instanceof HTMLElement)\n            ? flip({\n                  padding: REQUIRED_DISTANCE_TO_EDGE,\n                  fallbackPlacements: getFallbackPlacements(options.placement),\n              })\n            : flip();\n\n        // Extract main axis and cross axis offsets from options.\n        const [mainAxis = 0, crossAxis = 0] = Array.isArray(options?.offset)\n            ? options.offset\n            : [options.offset, 0];\n\n        // Find the tip element within the host elements.\n        const tipElement = this.host.elements.find(\n            (el) => el.tipElement\n        )?.tipElement;\n\n        // Define middleware functions for positioning and constraints.\n        const middleware = [\n            offset({\n                mainAxis,\n                crossAxis,\n            }),\n            shift({ padding: REQUIRED_DISTANCE_TO_EDGE }),\n            flipMiddleware,\n            size({\n                padding: REQUIRED_DISTANCE_TO_EDGE,\n                apply: ({\n                    availableWidth,\n                    availableHeight,\n                    rects: { floating },\n                }) => {\n                    const maxHeight = Math.max(\n                        MIN_OVERLAY_HEIGHT,\n                        Math.floor(availableHeight)\n                    );\n                    const actualHeight = floating.height;\n                    this.initialHeight = !this.isConstrained // && !this.virtualTrigger\n                        ? actualHeight\n                        : this.initialHeight || actualHeight;\n                    this.isConstrained =\n                        actualHeight < this.initialHeight ||\n                        maxHeight <= actualHeight;\n                    const appliedHeight = this.isConstrained\n                        ? `${maxHeight}px`\n                        : '';\n                    Object.assign(target.style, {\n                        maxWidth: `${Math.floor(availableWidth)}px`,\n                        maxHeight: appliedHeight,\n                    });\n                },\n            }),\n            ...(tipElement\n                ? [\n                      arrow({\n                          element: tipElement,\n                          padding:\n                              options.tipPadding || REQUIRED_DISTANCE_TO_EDGE,\n                      }),\n                  ]\n                : []),\n        ];\n\n        // Compute the position of the overlay using the defined middleware.\n        const { x, y, placement, middlewareData } = await computePosition(\n            options.trigger,\n            target,\n            {\n                placement: options.placement,\n                middleware,\n                strategy: 'fixed',\n            }\n        );\n\n        // Update the overlay's style with the computed position.\n        Object.assign(target.style, {\n            top: '0px',\n            left: '0px',\n            translate: `${roundByDPR(x)}px ${roundByDPR(y)}px`,\n        });\n\n        // Set the 'actual-placement' attribute on the target element.\n        target.setAttribute('actual-placement', placement);\n\n        // Update the placement attribute for each host element.\n        this.host.elements?.forEach((element) => {\n            if (!this.originalPlacements.has(element)) {\n                this.originalPlacements.set(\n                    element,\n                    element.getAttribute('placement') as Placement\n                );\n            }\n            element.setAttribute('placement', placement);\n        });\n\n        // Update the tip element's style with the computed arrow position.\n        if (tipElement && middlewareData.arrow) {\n            const { x: arrowX, y: arrowY } = middlewareData.arrow;\n\n            Object.assign(tipElement.style, {\n                top:\n                    placement.startsWith('right') ||\n                    placement.startsWith('left')\n                        ? '0px'\n                        : '',\n                left:\n                    placement.startsWith('bottom') ||\n                    placement.startsWith('top')\n                        ? '0px'\n                        : '',\n                translate: `${roundByDPR(arrowX)}px ${roundByDPR(arrowY)}px`,\n            });\n        }\n    }\n\n    /**\n     * Clears the overlay's position styles.\n     *\n     * This method removes the max-height and max-width styles from the target element,\n     * and resets the initial height and constrained state of the overlay.\n     */\n    public clearOverlayPosition(): void {\n        if (!this.target) {\n            return;\n        }\n        // Remove max-height and max-width styles from the target element.\n        this.target.style.removeProperty('max-height');\n        this.target.style.removeProperty('max-width');\n        // Reset the initial height and constrained state.\n        this.initialHeight = undefined;\n        this.isConstrained = false;\n    }\n\n    /**\n     * Resets the overlay's position.\n     *\n     * This method clears the overlay's position, forces a reflow, and recomputes the placement.\n     */\n    public resetOverlayPosition = (): void => {\n        if (!this.target || !this.options) return;\n        // Clear the overlay's position.\n        this.clearOverlayPosition();\n\n        // Force a reflow.\n        this.host.offsetHeight;\n        // Recompute the placement.\n        this.computePlacement();\n    };\n\n    /**\n     * Lifecycle method called when the host element is connected to the DOM.\n     *\n     * This method sets up an event listener to reset the overlay's position when the 'sp-update-overlays' event is dispatched.\n     */\n    hostConnected(): void {\n        document.addEventListener(\n            'sp-update-overlays',\n            this.resetOverlayPosition\n        );\n    }\n\n    /**\n     * Lifecycle method called when the host element is updated.\n     *\n     * This method cleans up resources if the overlay is not open.\n     */\n    hostUpdated(): void {\n        if (!(this.host as Overlay).open) {\n            // Clean up resources if the overlay is not open.\n            this.cleanup?.();\n            this.cleanup = undefined;\n        }\n    }\n\n    /**\n     * Lifecycle method called when the host element is disconnected from the DOM.\n     *\n     * This method removes the event listener and cleans up resources.\n     */\n    hostDisconnected(): void {\n        // Clean up resources.\n        this.cleanup?.();\n        this.cleanup = undefined;\n        // Remove the event listener.\n        document.removeEventListener(\n            'sp-update-overlays',\n            this.resetOverlayPosition\n        );\n    }\n}\n"],
  "mappings": "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",
  "names": ["arrow", "autoUpdate", "computePosition", "flip", "offset", "shift", "size", "roundByDPR", "num", "dpr", "REQUIRED_DISTANCE_TO_EDGE", "MIN_OVERLAY_HEIGHT", "getFallbackPlacements", "placement", "_a", "host", "target", "options", "cleanupAncestorResize", "cleanupElementResize", "element", "_b", "flipMiddleware", "mainAxis", "crossAxis", "tipElement", "el", "middleware", "availableWidth", "availableHeight", "floating", "maxHeight", "actualHeight", "appliedHeight", "x", "y", "middlewareData", "arrowX", "arrowY"]
}
