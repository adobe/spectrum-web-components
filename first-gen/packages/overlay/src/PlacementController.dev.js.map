{
  "version": 3,
  "sources": ["PlacementController.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type {\n    ReactiveController,\n    ReactiveElement,\n} from '@spectrum-web-components/base';\nimport {\n    arrow,\n    autoUpdate,\n    computePosition,\n    flip,\n    offset,\n    Placement,\n    shift,\n    size,\n} from '@floating-ui/dom';\nimport type { VirtualTrigger } from './VirtualTrigger.dev.js'\nimport type { OpenableElement } from './overlay-types.dev.js'\nimport type { Overlay } from './Overlay.dev.js'\n\ntype OverlayOptionsV1 = {\n    abortPromise?: Promise<boolean>;\n    delayed?: boolean;\n    offset?: number | [number, number]; // supporting multi-axis\n    placement: Placement;\n    notImmediatelyClosable?: boolean; // rename or place behind other API options\n    receivesFocus?: 'auto';\n    root?: HTMLElement;\n    tipPadding?: number;\n    trigger: HTMLElement | VirtualTrigger;\n    type?: 'modal' | 'page' | 'hint' | 'auto' | 'manual';\n};\n\n/**\n * Rounds a number by the device pixel ratio (DPR).\n *\n * @param {number} [num] - The number to round.\n * @returns {number} The rounded number.\n */\nfunction roundByDPR(num?: number): number {\n    if (typeof num === 'undefined') return 0;\n    const dpr = window.devicePixelRatio || 1;\n    return Math.round(num * dpr) / dpr;\n}\n\n// Minimum distance required between the overlay and the edge of the container.\n// See: https://spectrum.adobe.com/page/popover/#Container-padding\nconst REQUIRED_DISTANCE_TO_EDGE = 8;\n// Minimum height for the overlay.\n// See: https://github.com/adobe/spectrum-web-components/issues/910\nconst MIN_OVERLAY_HEIGHT = 100;\n\n/**\n * Gets fallback placements for the overlay based on the initial placement.\n *\n * @param {Placement} placement - The initial placement of the overlay.\n * @returns {Placement[]} An array of fallback placements.\n */\nconst getFallbackPlacements = (placement: Placement): Placement[] => {\n    const fallbacks: Record<Placement, Placement[]> = {\n        left: ['right', 'bottom', 'top'],\n        'left-start': ['right-start', 'bottom', 'top'],\n        'left-end': ['right-end', 'bottom', 'top'],\n        right: ['left', 'bottom', 'top'],\n        'right-start': ['left-start', 'bottom', 'top'],\n        'right-end': ['left-end', 'bottom', 'top'],\n        top: ['bottom', 'left', 'right'],\n        'top-start': ['bottom-start', 'left', 'right'],\n        'top-end': ['bottom-end', 'left', 'right'],\n        bottom: ['top', 'left', 'right'],\n        'bottom-start': ['top-start', 'left', 'right'],\n        'bottom-end': ['top-end', 'left', 'right'],\n    };\n    return fallbacks[placement] ?? [placement];\n};\n\n/**\n * Symbol used to indicate that the placement has been updated.\n */\nexport const placementUpdatedSymbol = Symbol('placement updated');\n\n/**\n * Controller for managing the placement of an overlay.\n *\n * This class implements the ReactiveController interface and provides methods\n * for managing the positioning and constraints of an overlay element.\n */\nexport class PlacementController implements ReactiveController {\n    /**\n     * Function to clean up resources when the controller is no longer needed.\n     *\n     * @private\n     */\n    private cleanup?: () => void;\n\n    /**\n     * Initial height of the overlay.\n     *\n     * @type {number}\n     */\n    initialHeight?: number;\n\n    /**\n     * Indicates whether the overlay is constrained by available space.\n     *\n     * @type {boolean}\n     */\n    isConstrained?: boolean;\n\n    /**\n     * The host element that uses this controller.\n     *\n     * @private\n     * @type {ReactiveElement & { elements: OpenableElement[] }}\n     */\n    private host!: ReactiveElement & { elements: OpenableElement[] };\n\n    /**\n     * Options for configuring the overlay placement.\n     *\n     * @private\n     * @type {OverlayOptionsV1}\n     */\n    private options!: OverlayOptionsV1;\n\n    /**\n     * A WeakMap to store the original placements of overlay elements.\n     *\n     * @private\n     * @type {WeakMap<HTMLElement, Placement>}\n     */\n    private originalPlacements = new WeakMap<HTMLElement, Placement>();\n\n    /**\n     * The target element for the overlay.\n     *\n     * @private\n     * @type {HTMLElement}\n     */\n    private target!: HTMLElement;\n\n    /**\n     * Creates an instance of the PlacementController.\n     *\n     * @param {ReactiveElement & { elements: OpenableElement[] }} host - The host element that uses this controller.\n     */\n    constructor(host: ReactiveElement & { elements: OpenableElement[] }) {\n        this.host = host;\n        // Add the controller after the MutationObserver has been created in preparation\n        // for the `hostConnected`/`hostDisconnected` callbacks to be run.\n        this.host.addController(this);\n    }\n\n    /**\n     * Places the overlay relative to the target element.\n     *\n     * This method sets up the necessary configurations and event listeners to manage the\n     * positioning and constraints of the overlay element.\n     *\n     * @param {HTMLElement} [target=this.target] - The target element for the overlay.\n     * @param {OverlayOptionsV1} [options=this.options] - The options for configuring the overlay placement.\n     * @returns {Promise<void>} A promise that resolves when the overlay has been placed.\n     */\n    public async placeOverlay(\n        target: HTMLElement = this.target,\n        options: OverlayOptionsV1 = this.options\n    ): Promise<void> {\n        // Set the target and options for the overlay.\n        this.target = target;\n        this.options = options;\n        if (!target || !options) return;\n\n        // Set up auto-update for ancestor resize events.\n        const cleanupAncestorResize = autoUpdate(\n            options.trigger,\n            target,\n            this.closeForAncestorUpdate,\n            {\n                ancestorResize: false,\n                elementResize: false,\n                layoutShift: false,\n            }\n        );\n\n        // Set up auto-update for element resize events.\n        const cleanupElementResize = autoUpdate(\n            options.trigger,\n            target,\n            this.updatePlacement,\n            {\n                ancestorScroll: false,\n            }\n        );\n\n        // Define the cleanup function to remove event listeners and reset placements.\n        this.cleanup = () => {\n            this.host.elements?.forEach((element) => {\n                element.addEventListener(\n                    'sp-closed',\n                    () => {\n                        const placement = this.originalPlacements.get(element);\n\n                        if (placement) {\n                            element.setAttribute('placement', placement);\n                        }\n\n                        this.originalPlacements.delete(element);\n                    },\n                    { once: true }\n                );\n            });\n            cleanupAncestorResize();\n            cleanupElementResize();\n        };\n    }\n\n    /**\n     * Flag to allow or disallow placement updates.\n     *\n     * @type {boolean}\n     */\n    public allowPlacementUpdate = false;\n\n    /**\n     * Closes the overlay if an ancestor element is updated.\n     *\n     * This method checks if placement updates are allowed and if the overlay type is not 'modal'.\n     * If these conditions are met and a cleanup function is defined, it dispatches a 'close' event\n     * on the target element to close the overlay.\n     */\n    closeForAncestorUpdate = (): void => {\n        if (\n            !this.allowPlacementUpdate &&\n            this.options.type !== 'modal' &&\n            this.cleanup\n        ) {\n            // Dispatch a 'close' event to close the overlay.\n            this.target.dispatchEvent(new Event('close', { bubbles: true }));\n        }\n\n        // Reset the flag to disallow placement updates.\n        this.allowPlacementUpdate = false;\n    };\n\n    /**\n     * Updates the placement of the overlay.\n     *\n     * This method calls the computePlacement method to recalculate the overlay's position.\n     *\n     * @private\n     */\n    private updatePlacement = (): void => {\n        this.computePlacement();\n    };\n\n    /**\n     * Computes the placement of the overlay relative to the target element.\n     *\n     * This method calculates the necessary positioning and constraints for the overlay element\n     * using various middleware functions. It updates the overlay's style and attributes based\n     * on the computed position.\n     *\n     * @returns {Promise<void>} A promise that resolves when the placement has been computed.\n     */\n    async computePlacement(): Promise<void> {\n        const { options, target } = this;\n\n        // Wait for document fonts to be ready before computing placement.\n        await (document.fonts ? document.fonts.ready : Promise.resolve());\n\n        // Determine the flip middleware based on the type of trigger element.\n        const flipMiddleware = !(options.trigger instanceof HTMLElement)\n            ? flip({\n                  padding: REQUIRED_DISTANCE_TO_EDGE,\n                  fallbackPlacements: getFallbackPlacements(options.placement),\n              })\n            : flip();\n\n        // Extract main axis and cross axis offsets from options.\n        const [mainAxis = 0, crossAxis = 0] = Array.isArray(options?.offset)\n            ? options.offset\n            : [options.offset, 0];\n\n        // Find the tip element within the host elements.\n        const tipElement = this.host.elements.find(\n            (el) => el.tipElement\n        )?.tipElement;\n\n        // Define middleware functions for positioning and constraints.\n        const middleware = [\n            offset({\n                mainAxis,\n                crossAxis,\n            }),\n            shift({ padding: REQUIRED_DISTANCE_TO_EDGE }),\n            flipMiddleware,\n            size({\n                padding: REQUIRED_DISTANCE_TO_EDGE,\n                apply: ({\n                    availableWidth,\n                    availableHeight,\n                    rects: { floating },\n                }) => {\n                    const maxHeight = Math.max(\n                        MIN_OVERLAY_HEIGHT,\n                        Math.floor(availableHeight)\n                    );\n                    const actualHeight = floating.height;\n                    this.initialHeight = !this.isConstrained // && !this.virtualTrigger\n                        ? actualHeight\n                        : this.initialHeight || actualHeight;\n                    this.isConstrained =\n                        actualHeight < this.initialHeight ||\n                        maxHeight <= actualHeight;\n                    const appliedHeight = this.isConstrained\n                        ? `${maxHeight}px`\n                        : '';\n                    Object.assign(target.style, {\n                        maxWidth: `${Math.floor(availableWidth)}px`,\n                        maxHeight: appliedHeight,\n                    });\n                },\n            }),\n            ...(tipElement\n                ? [\n                      arrow({\n                          element: tipElement,\n                          padding:\n                              options.tipPadding || REQUIRED_DISTANCE_TO_EDGE,\n                      }),\n                  ]\n                : []),\n        ];\n\n        // Compute the position of the overlay using the defined middleware.\n        const { x, y, placement, middlewareData } = await computePosition(\n            options.trigger,\n            target,\n            {\n                placement: options.placement,\n                middleware,\n                strategy: 'fixed',\n            }\n        );\n\n        // Update the overlay's style with the computed position.\n        Object.assign(target.style, {\n            top: '0px',\n            left: '0px',\n            translate: `${roundByDPR(x)}px ${roundByDPR(y)}px`,\n        });\n\n        // Set the 'actual-placement' attribute on the target element.\n        target.setAttribute('actual-placement', placement);\n\n        // Update the placement attribute for each host element.\n        this.host.elements?.forEach((element) => {\n            if (!this.originalPlacements.has(element)) {\n                this.originalPlacements.set(\n                    element,\n                    element.getAttribute('placement') as Placement\n                );\n            }\n            element.setAttribute('placement', placement);\n        });\n\n        // Update the tip element's style with the computed arrow position.\n        if (tipElement && middlewareData.arrow) {\n            const { x: arrowX, y: arrowY } = middlewareData.arrow;\n\n            Object.assign(tipElement.style, {\n                top:\n                    placement.startsWith('right') ||\n                    placement.startsWith('left')\n                        ? '0px'\n                        : '',\n                left:\n                    placement.startsWith('bottom') ||\n                    placement.startsWith('top')\n                        ? '0px'\n                        : '',\n                translate: `${roundByDPR(arrowX)}px ${roundByDPR(arrowY)}px`,\n            });\n        }\n    }\n\n    /**\n     * Clears the overlay's position styles.\n     *\n     * This method removes the max-height and max-width styles from the target element,\n     * and resets the initial height and constrained state of the overlay.\n     */\n    public clearOverlayPosition(): void {\n        if (!this.target) {\n            return;\n        }\n        // Remove max-height and max-width styles from the target element.\n        this.target.style.removeProperty('max-height');\n        this.target.style.removeProperty('max-width');\n        // Reset the initial height and constrained state.\n        this.initialHeight = undefined;\n        this.isConstrained = false;\n    }\n\n    /**\n     * Resets the overlay's position.\n     *\n     * This method clears the overlay's position, forces a reflow, and recomputes the placement.\n     */\n    public resetOverlayPosition = (): void => {\n        if (!this.target || !this.options) return;\n        // Clear the overlay's position.\n        this.clearOverlayPosition();\n\n        // Force a reflow.\n        this.host.offsetHeight;\n        // Recompute the placement.\n        this.computePlacement();\n    };\n\n    /**\n     * Lifecycle method called when the host element is connected to the DOM.\n     *\n     * This method sets up an event listener to reset the overlay's position when the 'sp-update-overlays' event is dispatched.\n     */\n    hostConnected(): void {\n        document.addEventListener(\n            'sp-update-overlays',\n            this.resetOverlayPosition\n        );\n    }\n\n    /**\n     * Lifecycle method called when the host element is updated.\n     *\n     * This method cleans up resources if the overlay is not open.\n     */\n    hostUpdated(): void {\n        if (!(this.host as Overlay).open) {\n            // Clean up resources if the overlay is not open.\n            this.cleanup?.();\n            this.cleanup = undefined;\n        }\n    }\n\n    /**\n     * Lifecycle method called when the host element is disconnected from the DOM.\n     *\n     * This method removes the event listener and cleans up resources.\n     */\n    hostDisconnected(): void {\n        // Clean up resources.\n        this.cleanup?.();\n        this.cleanup = undefined;\n        // Remove the event listener.\n        document.removeEventListener(\n            'sp-update-overlays',\n            this.resetOverlayPosition\n        );\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
