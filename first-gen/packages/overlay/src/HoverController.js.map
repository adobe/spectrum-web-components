{
  "version": 3,
  "sources": ["HoverController.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { conditionAttributeWithId } from '@spectrum-web-components/base/src/condition-attribute-with-id.js';\nimport { isWebKit } from '@spectrum-web-components/shared';\nimport { randomID } from '@spectrum-web-components/shared/src/random-id.js';\nimport { noop } from './AbstractOverlay.js';\nimport {\n    InteractionController,\n    InteractionTypes,\n    lastInteractionType,\n} from './InteractionController.js';\n\nconst HOVER_DELAY = 300;\n\nexport class HoverController extends InteractionController {\n    override type = InteractionTypes.hover;\n\n    private elementIds: string[] = [];\n\n    focusedin = false;\n\n    private hoverTimeout?: ReturnType<typeof setTimeout>;\n\n    pointerentered = false;\n\n    handleKeyup(event: KeyboardEvent): void {\n        if (event.code === 'Tab' || event.code === 'Escape') {\n            this.open = true;\n        }\n    }\n\n    handleTargetFocusin(): void {\n        if (!this.target.matches(':focus-visible')) {\n            return;\n        }\n\n        if (\n            isWebKit() &&\n            this.target[lastInteractionType] === InteractionTypes.click\n        ) {\n            return;\n        }\n\n        this.open = true;\n        this.focusedin = true;\n    }\n\n    handleTargetFocusout(): void {\n        this.focusedin = false;\n        if (this.pointerentered) return;\n        this.open = false;\n    }\n\n    handleTargetPointerenter(): void {\n        if (this.hoverTimeout) {\n            clearTimeout(this.hoverTimeout);\n            this.hoverTimeout = undefined;\n        }\n        if (this.overlay?.disabled) return;\n        this.open = true;\n        this.pointerentered = true;\n    }\n\n    handleTargetPointerleave(): void {\n        this.doPointerleave();\n    }\n\n    // set a timeout once the pointer enters and the overlay is shown\n    // give the user time to enter the overlay\n    handleHostPointerenter(): void {\n        if (this.hoverTimeout) {\n            clearTimeout(this.hoverTimeout);\n            this.hoverTimeout = undefined;\n        }\n    }\n\n    handleHostPointerleave(): void {\n        this.doPointerleave();\n    }\n\n    override prepareDescription(): void {\n        // require \"content\" to apply relationship\n        if (!this.overlay.elements.length) return;\n\n        const triggerRoot = this.target.getRootNode();\n        const contentRoot = this.overlay.elements[0].getRootNode();\n        const overlayRoot = this.overlay.getRootNode();\n        if (triggerRoot === overlayRoot) {\n            this.prepareOverlayRelativeDescription();\n        } else if (triggerRoot === contentRoot) {\n            this.prepareContentRelativeDescription();\n        }\n    }\n\n    private prepareOverlayRelativeDescription(): void {\n        const releaseDescription = conditionAttributeWithId(\n            this.target,\n            'aria-describedby',\n            [this.overlay.id]\n        );\n        this.releaseDescription = () => {\n            releaseDescription();\n            this.releaseDescription = noop;\n        };\n    }\n\n    private prepareContentRelativeDescription(): void {\n        const elementIds: string[] = [];\n        const appliedIds = this.overlay.elements.map((el) => {\n            elementIds.push(el.id);\n            if (!el.id) {\n                el.id = `${this.overlay.tagName.toLowerCase()}-helper-${randomID()}`;\n            }\n            return el.id;\n        });\n        this.elementIds = elementIds;\n        const releaseDescription = conditionAttributeWithId(\n            this.target,\n            'aria-describedby',\n            appliedIds\n        );\n        this.releaseDescription = () => {\n            releaseDescription();\n            this.overlay.elements.map((el, index) => {\n                el.id = this.elementIds[index];\n            });\n            this.releaseDescription = noop;\n        };\n    }\n\n    protected doPointerleave(): void {\n        this.pointerentered = false;\n        const triggerElement = this.target as HTMLElement;\n        if (this.focusedin && triggerElement.matches(':focus-visible')) return;\n\n        this.hoverTimeout = setTimeout(() => {\n            this.open = false;\n        }, HOVER_DELAY);\n    }\n\n    override init(): void {\n        // Clean up listeners if they've already been bound\n        this.abortController?.abort();\n        this.abortController = new AbortController();\n        const { signal } = this.abortController;\n        this.target.addEventListener(\n            'keyup',\n            (event) => this.handleKeyup(event),\n            { signal }\n        );\n        this.target.addEventListener(\n            'focusin',\n            () => this.handleTargetFocusin(),\n            { signal }\n        );\n        this.target.addEventListener(\n            'focusout',\n            () => this.handleTargetFocusout(),\n            { signal }\n        );\n        this.target.addEventListener(\n            'pointerenter',\n            () => this.handleTargetPointerenter(),\n            { signal }\n        );\n        this.target.addEventListener(\n            'pointerleave',\n            () => this.handleTargetPointerleave(),\n            { signal }\n        );\n        if (this.overlay) {\n            this.initOverlay();\n        }\n    }\n\n    override initOverlay(): void {\n        if (!this.abortController) {\n            return;\n        }\n        const { signal } = this.abortController;\n        this.overlay.addEventListener(\n            'pointerenter',\n            () => this.handleHostPointerenter(),\n            { signal }\n        );\n        this.overlay.addEventListener(\n            'pointerleave',\n            () => this.handleHostPointerleave(),\n            { signal }\n        );\n    }\n}\n"],
  "mappings": "aAYA,OAAS,4BAAAA,MAAgC,mEACzC,OAAS,YAAAC,MAAgB,kCACzB,OAAS,YAAAC,MAAgB,mDACzB,OAAS,QAAAC,MAAY,uBACrB,OACI,yBAAAC,EACA,oBAAAC,EACA,uBAAAC,MACG,6BAEP,MAAMC,EAAc,IAEb,aAAM,wBAAwBH,CAAsB,CAApD,kCACH,KAAS,KAAOC,EAAiB,MAEjC,KAAQ,WAAuB,CAAC,EAEhC,eAAY,GAIZ,oBAAiB,GAEjB,YAAYG,EAA4B,EAChCA,EAAM,OAAS,OAASA,EAAM,OAAS,YACvC,KAAK,KAAO,GAEpB,CAEA,qBAA4B,CACnB,KAAK,OAAO,QAAQ,gBAAgB,IAKrCP,EAAS,GACT,KAAK,OAAOK,CAAmB,IAAMD,EAAiB,QAK1D,KAAK,KAAO,GACZ,KAAK,UAAY,IACrB,CAEA,sBAA6B,CACzB,KAAK,UAAY,GACb,MAAK,iBACT,KAAK,KAAO,GAChB,CAEA,0BAAiC,CA/DrC,IAAAI,EAgEY,KAAK,eACL,aAAa,KAAK,YAAY,EAC9B,KAAK,aAAe,QAEpB,GAAAA,EAAA,KAAK,UAAL,MAAAA,EAAc,YAClB,KAAK,KAAO,GACZ,KAAK,eAAiB,GAC1B,CAEA,0BAAiC,CAC7B,KAAK,eAAe,CACxB,CAIA,wBAA+B,CACvB,KAAK,eACL,aAAa,KAAK,YAAY,EAC9B,KAAK,aAAe,OAE5B,CAEA,wBAA+B,CAC3B,KAAK,eAAe,CACxB,CAES,oBAA2B,CAEhC,GAAI,CAAC,KAAK,QAAQ,SAAS,OAAQ,OAEnC,MAAMC,EAAc,KAAK,OAAO,YAAY,EACtCC,EAAc,KAAK,QAAQ,SAAS,CAAC,EAAE,YAAY,EACnDC,EAAc,KAAK,QAAQ,YAAY,EACzCF,IAAgBE,EAChB,KAAK,kCAAkC,EAChCF,IAAgBC,GACvB,KAAK,kCAAkC,CAE/C,CAEQ,mCAA0C,CAC9C,MAAME,EAAqBb,EACvB,KAAK,OACL,mBACA,CAAC,KAAK,QAAQ,EAAE,CACpB,EACA,KAAK,mBAAqB,IAAM,CAC5Ba,EAAmB,EACnB,KAAK,mBAAqBV,CAC9B,CACJ,CAEQ,mCAA0C,CAC9C,MAAMW,EAAuB,CAAC,EACxBC,EAAa,KAAK,QAAQ,SAAS,IAAKC,IAC1CF,EAAW,KAAKE,EAAG,EAAE,EAChBA,EAAG,KACJA,EAAG,GAAK,GAAG,KAAK,QAAQ,QAAQ,YAAY,CAAC,WAAWd,EAAS,CAAC,IAE/Dc,EAAG,GACb,EACD,KAAK,WAAaF,EAClB,MAAMD,EAAqBb,EACvB,KAAK,OACL,mBACAe,CACJ,EACA,KAAK,mBAAqB,IAAM,CAC5BF,EAAmB,EACnB,KAAK,QAAQ,SAAS,IAAI,CAACG,EAAIC,IAAU,CACrCD,EAAG,GAAK,KAAK,WAAWC,CAAK,CACjC,CAAC,EACD,KAAK,mBAAqBd,CAC9B,CACJ,CAEU,gBAAuB,CAC7B,KAAK,eAAiB,GACtB,MAAMe,EAAiB,KAAK,OACxB,KAAK,WAAaA,EAAe,QAAQ,gBAAgB,IAE7D,KAAK,aAAe,WAAW,IAAM,CACjC,KAAK,KAAO,EAChB,EAAGX,CAAW,EAClB,CAES,MAAa,CAtJ1B,IAAAE,GAwJQA,EAAA,KAAK,kBAAL,MAAAA,EAAsB,QACtB,KAAK,gBAAkB,IAAI,gBAC3B,KAAM,CAAE,OAAAU,CAAO,EAAI,KAAK,gBACxB,KAAK,OAAO,iBACR,QACCX,GAAU,KAAK,YAAYA,CAAK,EACjC,CAAE,OAAAW,CAAO,CACb,EACA,KAAK,OAAO,iBACR,UACA,IAAM,KAAK,oBAAoB,EAC/B,CAAE,OAAAA,CAAO,CACb,EACA,KAAK,OAAO,iBACR,WACA,IAAM,KAAK,qBAAqB,EAChC,CAAE,OAAAA,CAAO,CACb,EACA,KAAK,OAAO,iBACR,eACA,IAAM,KAAK,yBAAyB,EACpC,CAAE,OAAAA,CAAO,CACb,EACA,KAAK,OAAO,iBACR,eACA,IAAM,KAAK,yBAAyB,EACpC,CAAE,OAAAA,CAAO,CACb,EACI,KAAK,SACL,KAAK,YAAY,CAEzB,CAES,aAAoB,CACzB,GAAI,CAAC,KAAK,gBACN,OAEJ,KAAM,CAAE,OAAAA,CAAO,EAAI,KAAK,gBACxB,KAAK,QAAQ,iBACT,eACA,IAAM,KAAK,uBAAuB,EAClC,CAAE,OAAAA,CAAO,CACb,EACA,KAAK,QAAQ,iBACT,eACA,IAAM,KAAK,uBAAuB,EAClC,CAAE,OAAAA,CAAO,CACb,CACJ,CACJ",
  "names": ["conditionAttributeWithId", "isWebKit", "randomID", "noop", "InteractionController", "InteractionTypes", "lastInteractionType", "HOVER_DELAY", "event", "_a", "triggerRoot", "contentRoot", "overlayRoot", "releaseDescription", "elementIds", "appliedIds", "el", "index", "triggerElement", "signal"]
}
