{
  "version": 3,
  "sources": ["Overlay.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n    html,\n    PropertyValues,\n    TemplateResult,\n} from '@spectrum-web-components/base';\nimport {\n    property,\n    query,\n    queryAssignedElements,\n    state,\n} from '@spectrum-web-components/base/src/decorators.js';\nimport {\n    ElementResolutionController,\n    elementResolverUpdatedSymbol,\n} from '@spectrum-web-components/reactive-controllers/src/ElementResolution.js';\nimport {\n    ifDefined,\n    StyleInfo,\n    styleMap,\n} from '@spectrum-web-components/base/src/directives.js';\nimport { randomID } from '@spectrum-web-components/shared/src/random-id.js';\nimport type {\n    OpenableElement,\n    OverlayState,\n    OverlayTypes,\n    Placement,\n    TriggerInteraction,\n} from './overlay-types.dev.js'\nimport { AbstractOverlay, nextFrame } from './AbstractOverlay.dev.js'\nimport { OverlayPopover } from './OverlayPopover.dev.js'\nimport { OverlayNoPopover } from './OverlayNoPopover.dev.js'\nimport { overlayStack } from './OverlayStack.dev.js'\nimport { VirtualTrigger } from './VirtualTrigger.dev.js'\nimport { PlacementController } from './PlacementController.dev.js'\nimport type { ClickController } from './ClickController.dev.js'\nimport type { HoverController } from './HoverController.dev.js'\nimport type { LongpressController } from './LongpressController.dev.js'\nexport { LONGPRESS_INSTRUCTIONS } from './LongpressController.dev.js'\nimport { strategies } from './strategies.dev.js'\nimport {\n    removeSlottableRequest,\n    SlottableRequestEvent,\n} from './slottable-request-event.dev.js'\n\nimport styles from './overlay.css.js';\nimport { FocusTrap } from 'focus-trap';\nimport '@spectrum-web-components/underlay/sp-underlay.js';\n\nconst browserSupportsPopover = 'showPopover' in document.createElement('div');\n\n// Start the base class and add the popover or no-popover functionality\nlet ComputedOverlayBase = OverlayPopover(AbstractOverlay);\nif (!browserSupportsPopover) {\n    ComputedOverlayBase = OverlayNoPopover(AbstractOverlay);\n}\n\n/**\n * @element sp-overlay\n *\n * @slot default - The content that will be displayed in the overlay\n *\n * @fires sp-opened - announces that an overlay has completed any entry animations\n * @fires sp-closed - announce that an overlay has compelted any exit animations\n * @fires slottable-request - requests to add or remove slottable content\n *\n * @attr {string} placement - The placement of the overlay relative to the trigger\n * @attr {number} offset - The distance between the overlay and the trigger\n * @attr {boolean} disabled - Whether the overlay trigger is disabled\n * @attr {string} receives-focus - How focus should be handled ('true'|'false'|'auto')\n * @attr {boolean} delayed - Whether the overlay should wait for a warm-up period before opening\n * @attr {boolean} open - Whether the overlay is currently open\n */\nexport class Overlay extends ComputedOverlayBase {\n    static override styles = [styles];\n\n    /**\n     * An Overlay that is `delayed` will wait until a warm-up period of 1000ms\n     * has completed before opening. Once the warm-up period has completed, all\n     * subsequent Overlays will open immediately. When no Overlays are opened,\n     * a cool-down period of 1000ms will begin. Once the cool-down has completed,\n     * the next Overlay to be opened will be subject to the warm-up period if\n     * provided that option.\n     *\n     * This behavior helps to manage the performance and user experience by\n     * preventing multiple overlays from opening simultaneously and ensuring\n     * a smooth transition between opening and closing overlays.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    @property({ type: Boolean })\n    override get delayed(): boolean {\n        return this.elements.at(-1)?.hasAttribute('delayed') || this._delayed;\n    }\n\n    override set delayed(delayed: boolean) {\n        this._delayed = delayed;\n    }\n\n    private _delayed = false;\n\n    /**\n     * A reference to the dialog element within the overlay.\n     * This element is expected to have `showPopover` and `hidePopover` methods.\n     */\n    @query('.dialog')\n    override dialogEl!: HTMLDialogElement & {\n        showPopover(): void;\n        hidePopover(): void;\n    };\n\n    /**\n     * Indicates whether the overlay is currently functional or not.\n     *\n     * When set to `true`, the overlay is disabled, and any active strategy is aborted.\n     * The overlay will also close if it is currently open. When set to `false`, the\n     * overlay will re-bind events and re-open if it was previously open.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    @property({ type: Boolean })\n    override get disabled(): boolean {\n        return this._disabled;\n    }\n\n    override set disabled(disabled: boolean) {\n        this._disabled = disabled;\n        if (disabled) {\n            // Abort any active strategy and close the overlay if it is currently open\n            this.strategy?.abort();\n            this.wasOpen = this.open;\n            this.open = false;\n        } else {\n            // Re-bind events and re-open the overlay if it was previously open\n            this.bindEvents();\n            this.open = this.open || this.wasOpen;\n            this.wasOpen = false;\n        }\n    }\n\n    private _disabled = false;\n\n    /**\n     * A query to gather all elements slotted into the default slot, excluding elements\n     * with the slot name \"longpress-describedby-descriptor\".\n     */\n    @queryAssignedElements({\n        flatten: true,\n        selector: ':not([slot=\"longpress-describedby-descriptor\"], slot)',\n    })\n    override elements!: OpenableElement[];\n\n    /**\n     * A reference to the parent overlay that should be force-closed, if any.\n     */\n    public parentOverlayToForceClose?: Overlay;\n\n    /**\n     * Determines if the overlay has a non-virtual trigger element.\n     *\n     * @returns {boolean} `true` if the trigger element is not a virtual trigger, otherwise `false`.\n     */\n    private get hasNonVirtualTrigger(): boolean {\n        return (\n            !!this.triggerElement &&\n            !(this.triggerElement instanceof VirtualTrigger)\n        );\n    }\n\n    /**\n     * The `offset` property accepts either a single number to define the offset of the\n     * Overlay along the main axis from the trigger, or a 2-tuple to define the offset\n     * along both the main axis and the cross axis. This option has no effect when there\n     * is no trigger element.\n     *\n     * @type {number | [number, number]}\n     * @default 0\n     */\n    @property({ type: Number })\n    override offset: number | [number, number] = 0;\n\n    /**\n     * Provides an instance of the `PlacementController` for managing the positioning\n     * of the overlay relative to its trigger element.\n     *\n     * If the `PlacementController` instance does not already exist, it is created and\n     * assigned to the `_placementController` property.\n     *\n     * @protected\n     * @returns {PlacementController} The `PlacementController` instance.\n     */\n    protected override get placementController(): PlacementController {\n        if (!this._placementController) {\n            this._placementController = new PlacementController(this);\n        }\n        return this._placementController;\n    }\n\n    /**\n     * Indicates whether the Overlay is projected onto the \"top layer\" or not.\n     *\n     * When set to `true`, the overlay is open and visible. When set to `false`, the overlay is closed and hidden.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    @property({ type: Boolean, reflect: true })\n    override get open(): boolean {\n        return this._open;\n    }\n\n    override set open(open: boolean) {\n        // Don't respond if the overlay is disabled.\n        if (open && this.disabled) return;\n\n        // Don't respond if the state is not changing.\n        if (open === this.open) return;\n\n        // Don't respond if the overlay is in the shadow state during a longpress.\n        // The shadow state occurs when the first \"click\" would normally close the popover.\n        if (this.strategy?.activelyOpening && !open) return;\n\n        // Update the internal _open property.\n        this._open = open;\n\n        // Increment the open count if the overlay is opening.\n        if (this.open) {\n            Overlay.openCount += 1;\n        }\n\n        // Request an update to re-render the component if necessary.\n        this.requestUpdate('open', !this.open);\n\n        // Request slottable content if the overlay is opening.\n        if (this.open) {\n            this.requestSlottable();\n        }\n    }\n\n    private _open = false;\n\n    /**\n     * Tracks the number of overlays that have been opened.\n     *\n     * This static property is used to manage the stacking context of multiple overlays.\n     *\n     * @type {number}\n     * @default 1\n     */\n    static openCount = 1;\n\n    /**\n     * Instruct the Overlay where to place itself in relationship to the trigger element.\n     *\n     * @type {\"top\" | \"top-start\" | \"top-end\" | \"right\" | \"right-start\" | \"right-end\" | \"bottom\" | \"bottom-start\" | \"bottom-end\" | \"left\" | \"left-start\" | \"left-end\"}\n     */\n    @property()\n    override placement?: Placement;\n\n    /**\n     * The state in which the last `request-slottable` event was dispatched.\n     *\n     * This property ensures that overlays do not dispatch the same state twice in a row.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    private lastRequestSlottableState = false;\n\n    /**\n     * Whether to pass focus to the overlay once opened, or\n     * to the appropriate value based on the \"type\" of the overlay\n     * when set to `\"auto\"`.\n     *\n     * @type {'true' | 'false' | 'auto'}\n     * @default 'auto'\n     */\n    @property({ attribute: 'receives-focus' })\n    override receivesFocus: 'true' | 'false' | 'auto' = 'auto';\n\n    /**\n     * A reference to the slot element within the overlay.\n     *\n     * This element is used to manage the content slotted into the overlay.\n     *\n     * @type {HTMLSlotElement}\n     */\n    @query('slot')\n    slotEl!: HTMLSlotElement;\n\n    /**\n     * The current state of the overlay.\n     *\n     * This property reflects the current state of the overlay, such as 'opened' or 'closed'.\n     * When the state changes, it triggers the appropriate actions and updates the component.\n     *\n     * @type {OverlayState}\n     * @default 'closed'\n     */\n    @state()\n    override get state(): OverlayState {\n        return this._state;\n    }\n\n    override set state(state) {\n        // Do not respond if the state is not changing.\n        if (state === this.state) return;\n\n        const oldState = this.state;\n\n        this._state = state;\n\n        // Complete the opening strategy if the state is 'opened' or 'closed'.\n        if (this.state === 'opened' || this.state === 'closed') {\n            this.strategy?.shouldCompleteOpen();\n        }\n\n        // Request an update to re-render the component if necessary.\n        this.requestUpdate('state', oldState);\n    }\n\n    override _state: OverlayState = 'closed';\n\n    /**\n     * The interaction strategy for opening the overlay.\n     * This can be a ClickController, HoverController, or LongpressController.\n     */\n    public strategy?: ClickController | HoverController | LongpressController;\n\n    /**\n     * The padding around the tip of the overlay.\n     * This property defines the padding around the tip of the overlay, which can be used to adjust its positioning.\n     *\n     * @type {number}\n     */\n    @property({ type: Number, attribute: 'tip-padding' })\n    tipPadding?: number;\n\n    /**\n     * An optional ID reference for the trigger element combined with the optional\n     * interaction (click | hover | longpress) by which the overlay should open.\n     * The format is `trigger@interaction`, e.g., `trigger@click` opens the overlay\n     * when an element with the ID \"trigger\" is clicked.\n     *\n     * @type {string}\n     */\n    @property()\n    trigger?: string;\n\n    /**\n     * An element reference for the trigger element that the overlay should relate to.\n     * This property is not reflected as an attribute.\n     *\n     * @type {HTMLElement | VirtualTrigger | null}\n     */\n    @property({ attribute: false })\n    override triggerElement: HTMLElement | VirtualTrigger | null = null;\n\n    /**\n     * The specific interaction to listen for on the `triggerElement` to open the overlay.\n     * This property is not reflected as an attribute.\n     *\n     * @type {TriggerInteraction}\n     */\n    @property({ attribute: false })\n    triggerInteraction?: TriggerInteraction;\n\n    /**\n     * Configures the open/close heuristics of the Overlay.\n     *\n     * @type {\"auto\" | \"hint\" | \"manual\" | \"modal\" | \"page\"}\n     * @default \"auto\"\n     */\n    @property()\n    override type: OverlayTypes = 'auto';\n\n    /**\n     * Tracks whether the overlay was previously open.\n     * This is used to restore the open state when re-enabling the overlay.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    protected wasOpen = false;\n\n    /**\n     * Focus trap to keep focus within the dialog\n     * @private\n     */\n    private _focusTrap: FocusTrap | null = null;\n\n    /**\n     * Provides an instance of the `ElementResolutionController` for managing the element\n     * that the overlay should be associated with. If the instance does not already exist,\n     * it is created and assigned to the `_elementResolver` property.\n     *\n     * @protected\n     * @returns {ElementResolutionController} The `ElementResolutionController` instance.\n     */\n    protected override get elementResolver(): ElementResolutionController {\n        if (!this._elementResolver) {\n            this._elementResolver = new ElementResolutionController(this);\n        }\n\n        return this._elementResolver;\n    }\n\n    /**\n     * Determines the value for the popover attribute based on the overlay type.\n     *\n     * @private\n     * @returns {'auto' | 'manual' | 'hint' | undefined} The popover value or undefined if not applicable.\n     */\n    private get popoverValue(): 'auto' | 'manual' | 'hint' | undefined {\n        const hasPopoverAttribute = 'popover' in this;\n\n        if (!hasPopoverAttribute) {\n            return undefined;\n        }\n\n        switch (this.type) {\n            case 'modal':\n                return 'manual';\n            case 'page':\n                return 'manual';\n            default:\n                return this.type;\n        }\n    }\n\n    /**\n     * Determines if the overlay requires positioning based on its type and state.\n     *\n     * @protected\n     * @returns {boolean} True if the overlay requires positioning, otherwise false.\n     */\n    protected get requiresPositioning(): boolean {\n        // Do not position \"page\" overlays as they should block the entire UI.\n        if (this.type === 'page' || !this.open) return false;\n\n        // Do not position content without a trigger element, as there is nothing to position it relative to.\n        // Do not automatically position content unless it is a \"hint\".\n        if (!this.triggerElement || (!this.placement && this.type !== 'hint'))\n            return false;\n\n        return true;\n    }\n\n    /**\n     * Manages the positioning of the overlay relative to its trigger element.\n     *\n     * This method calculates the necessary parameters for positioning the overlay,\n     * such as offset, placement, and tip padding, and then delegates the actual\n     * positioning to the `PlacementController`.\n     *\n     * @protected\n     * @override\n     */\n    protected override managePosition(): void {\n        // Do not proceed if positioning is not required or the overlay is not open.\n        if (!this.requiresPositioning || !this.open) return;\n\n        const offset = this.offset || 0;\n\n        const trigger = this.triggerElement as HTMLElement;\n\n        const placement = (this.placement as Placement) || 'right';\n\n        const tipPadding = this.tipPadding;\n\n        this.placementController.placeOverlay(this.dialogEl, {\n            offset,\n            placement,\n            tipPadding,\n            trigger,\n            type: this.type,\n        });\n    }\n\n    /**\n     * Manages the process of opening the popover.\n     *\n     * This method handles the necessary steps to open the popover, including managing delays,\n     * ensuring the popover is in the DOM, making transitions, and applying focus.\n     *\n     * @protected\n     * @override\n     * @returns {Promise<void>} A promise that resolves when the popover has been fully opened.\n     */\n    protected override async managePopoverOpen(): Promise<void> {\n        // Call the base class method to handle any initial setup.\n        super.managePopoverOpen();\n\n        const targetOpenState = this.open;\n\n        // Ensure the open state has not changed before proceeding.\n        if (this.open !== targetOpenState) {\n            return;\n        }\n\n        // Manage any delays before opening the popover.\n        await this.manageDelay(targetOpenState);\n\n        if (this.open !== targetOpenState) {\n            return;\n        }\n\n        // Only wait for next frame if `longpress` is the trigger.\n        // In Safari, awaiting nextFrame here causes layout issues\n        // when rendering trays inside modals, so we skip it otherwise.\n        if (this.triggerInteraction === 'longpress') {\n            await nextFrame();\n        }\n\n        // Ensure the popover is in the DOM before proceeding.\n        await this.ensureOnDOM(targetOpenState);\n\n        if (this.open !== targetOpenState) {\n            return;\n        }\n\n        // Make any necessary transitions for opening the popover.\n        const focusEl = await this.makeTransition(targetOpenState);\n        console.log(this.dialogEl.querySelector('sp-close-button'));\n        if (this.open !== targetOpenState) {\n            return;\n        }\n        if (targetOpenState) {\n            const focusTrap = await import('focus-trap');\n            this._focusTrap = focusTrap.createFocusTrap(this.dialogEl, {\n                allowOutsideClick: (event) => {\n                    return !event.isTrusted;\n                },\n                tabbableOptions: {\n                    getShadowRoot: true,\n                },\n                fallbackFocus: () => {\n                    // set tabIndex to -1 allow the focus-trap to still be applied\n                    this.dialogEl.setAttribute('tabIndex', '-1');\n                    return this.dialogEl;\n                },\n                // disable escape key capture to close the overlay, the focus-trap library captures it otherwise\n                escapeDeactivates: false,\n            });\n\n            if (\n                (this.type === 'modal' || this.type === 'page') &&\n                this.receivesFocus !== 'false'\n            ) {\n                this._focusTrap.activate();\n            }\n        }\n        // Apply focus to the appropriate element after opening the popover.\n        await this.applyFocus(targetOpenState, focusEl);\n    }\n\n    /**\n     * Applies focus to the appropriate element after the popover has been opened.\n     *\n     * This method handles the focus management for the overlay, ensuring that the correct\n     * element receives focus based on the overlay's type and state.\n     *\n     * @protected\n     * @override\n     * @param {boolean} targetOpenState - The target open state of the overlay.\n     * @param {HTMLElement | null} focusEl - The element to focus after opening the popover.\n     * @returns {Promise<void>} A promise that resolves when the focus has been applied.\n     */\n    protected override async applyFocus(\n        targetOpenState: boolean,\n        focusEl: HTMLElement | null\n    ): Promise<void> {\n        // Do not move focus when explicitly told not to or when the overlay is a \"hint\".\n        if (this.receivesFocus === 'false' || this.type === 'hint') {\n            return;\n        }\n\n        // Wait for the next two animation frames to ensure the DOM is updated.\n        await nextFrame();\n        await nextFrame();\n\n        // If the open state has changed during the delay, do not proceed.\n        if (targetOpenState === this.open && !this.open) {\n            // If the overlay is closing and the trigger element is still focused, return focus to the trigger element.\n            if (\n                this.hasNonVirtualTrigger &&\n                this.contains((this.getRootNode() as Document).activeElement)\n            ) {\n                (this.triggerElement as HTMLElement).focus();\n            }\n            return;\n        }\n\n        // Apply focus to the specified focus element.\n        focusEl?.focus();\n    }\n\n    /**\n     * Returns focus to the trigger element if the overlay is closed.\n     *\n     * This method ensures that focus is returned to the trigger element when the overlay is closed,\n     * unless the overlay is of type \"hint\" or the focus is already outside the overlay.\n     *\n     * @protected\n     * @override\n     */\n    protected override returnFocus(): void {\n        // Do not proceed if the overlay is open or if the overlay type is \"hint\".\n        if (this.open || this.type === 'hint') return;\n\n        /**\n         * Retrieves the ancestors of the currently focused element.\n         *\n         * @returns {HTMLElement[]} An array of ancestor elements.\n         */\n        const getAncestors = (): HTMLElement[] => {\n            const ancestors: HTMLElement[] = [];\n\n            // eslint-disable-next-line @spectrum-web-components/document-active-element\n            let currentNode = document.activeElement;\n\n            // Traverse the shadow DOM to find the active element.\n            while (currentNode?.shadowRoot?.activeElement) {\n                currentNode = currentNode.shadowRoot.activeElement;\n            }\n\n            // Traverse the DOM tree to collect ancestor elements.\n            while (currentNode) {\n                const ancestor =\n                    currentNode.assignedSlot ||\n                    currentNode.parentElement ||\n                    (currentNode.getRootNode() as ShadowRoot)?.host;\n                if (ancestor) {\n                    ancestors.push(ancestor as HTMLElement);\n                }\n                currentNode = ancestor;\n            }\n            return ancestors;\n        };\n\n        // Check if focus should be returned to the trigger element.\n        if (\n            this.receivesFocus !== 'false' &&\n            !!(this.triggerElement as HTMLElement)?.focus &&\n            (this.contains((this.getRootNode() as Document).activeElement) ||\n                getAncestors().includes(this) ||\n                // eslint-disable-next-line @spectrum-web-components/document-active-element\n                document.activeElement === document.body)\n        ) {\n            // Return focus to the trigger element.\n            (this.triggerElement as HTMLElement).focus();\n        }\n    }\n\n    /**\n     * Handles the focus out event to close the overlay if the focus moves outside of it.\n     *\n     * This method ensures that the overlay is closed when the focus moves to an element\n     * outside of the overlay, unless the focus is moved to a related element.\n     *\n     * @private\n     * @param {FocusEvent} event - The focus out event.\n     */\n    private closeOnFocusOut = (event: FocusEvent): void => {\n        // If the related target (newly focused element) is not known, do nothing.\n        if (!event.relatedTarget) {\n            return;\n        }\n\n        // Create a custom event to query the relationship of the newly focused element.\n        const relationEvent = new Event('overlay-relation-query', {\n            bubbles: true,\n            composed: true,\n        });\n\n        // Add an event listener to the related target to handle the custom event.\n        event.relatedTarget.addEventListener(\n            relationEvent.type,\n            (event: Event) => {\n                // Check if the newly focused element is within the overlay or its children\n                const path = event.composedPath();\n                const isWithinOverlay = path.some((el) => el === this);\n\n                // Only close if focus moves outside the overlay and its children\n                if (!isWithinOverlay) {\n                    this.open = false;\n                }\n            }\n        );\n\n        // Dispatch the custom event to the related target.\n        event.relatedTarget.dispatchEvent(relationEvent);\n    };\n\n    private closeOnCancelEvent = (): void => {\n        this.open = false;\n    };\n\n    /**\n     * Manages the process of opening or closing the overlay.\n     *\n     * This method handles the necessary steps to open or close the overlay, including updating the state,\n     * managing the overlay stack, and handling focus events.\n     *\n     * @protected\n     * @param {boolean} oldOpen - The previous open state of the overlay.\n     * @returns {Promise<void>} A promise that resolves when the overlay has been fully managed.\n     */\n    protected async manageOpen(oldOpen: boolean): Promise<void> {\n        // Prevent entering the manage workflow if the overlay is not connected to the DOM.\n        // The `.showPopover()` event will error on content that is not connected to the DOM.\n        if (!this.isConnected && this.open) return;\n\n        // Wait for the component to finish updating if it has not already done so.\n        if (!this.hasUpdated) {\n            await this.updateComplete;\n        }\n\n        if (this.open) {\n            // Add the overlay to the overlay stack.\n            overlayStack.add(this);\n\n            if (this.willPreventClose) {\n                // Add an event listener to handle the pointerup event and toggle the 'not-immediately-closable' class.\n                document.addEventListener(\n                    'pointerup',\n                    () => {\n                        this.dialogEl.classList.toggle(\n                            'not-immediately-closable',\n                            false\n                        );\n                        this.willPreventClose = false;\n                    },\n                    { once: true }\n                );\n                this.dialogEl.classList.toggle(\n                    'not-immediately-closable',\n                    true\n                );\n            }\n        } else {\n            if (oldOpen) {\n                this._focusTrap?.deactivate();\n                this._focusTrap = null;\n                // Dispose of the overlay if it was previously open.\n                this.dispose();\n            }\n\n            // Remove the overlay from the overlay stack.\n            overlayStack.remove(this);\n        }\n\n        // Update the state of the overlay based on the open property.\n        if (this.open && this.state !== 'opened') {\n            this.state = 'opening';\n        } else if (!this.open && this.state !== 'closed') {\n            this.state = 'closing';\n        }\n\n        this.managePopoverOpen();\n\n        const listenerRoot = this.getRootNode() as Document;\n        // Handle focus events for auto type overlays.\n        if (this.type === 'auto') {\n            if (this.open) {\n                listenerRoot.addEventListener(\n                    'focusout',\n                    this.closeOnFocusOut,\n                    { capture: true }\n                );\n            } else {\n                listenerRoot.removeEventListener(\n                    'focusout',\n                    this.closeOnFocusOut,\n                    { capture: true }\n                );\n            }\n        }\n\n        // Handle cancel events for modal and page type overlays.\n        if (this.type === 'modal' || this.type === 'page') {\n            if (this.open) {\n                listenerRoot.addEventListener(\n                    'cancel',\n                    this.closeOnCancelEvent,\n                    {\n                        capture: true,\n                    }\n                );\n            } else {\n                listenerRoot.removeEventListener(\n                    'cancel',\n                    this.closeOnCancelEvent,\n                    {\n                        capture: true,\n                    }\n                );\n            }\n        }\n    }\n\n    /**\n     * Binds event handling strategies to the overlay based on the specified trigger interaction.\n     *\n     * This method sets up the appropriate event handling strategy for the overlay, ensuring that\n     * it responds correctly to user interactions such as clicks, hovers, or long presses.\n     *\n     * @protected\n     */\n    protected bindEvents(): void {\n        // Abort any existing strategy to ensure a clean setup.\n        this.strategy?.abort();\n        this.strategy = undefined;\n\n        // Return early if there is no non-virtual trigger element.\n        if (!this.hasNonVirtualTrigger) return;\n\n        // Return early if no trigger interaction is specified.\n        if (!this.triggerInteraction) return;\n\n        // Set up a new event handling strategy based on the specified trigger interaction.\n        this.strategy = new strategies[this.triggerInteraction](\n            this.triggerElement as HTMLElement,\n            {\n                overlay: this,\n            }\n        );\n    }\n\n    /**\n     * Handles the `beforetoggle` event to manage the overlay's state.\n     *\n     * This method checks the new state of the event and calls `handleBrowserClose`\n     * if the new state is not 'open'.\n     *\n     * @protected\n     * @param {Event & { newState: string }} event - The `beforetoggle` event with the new state.\n     */\n    protected handleBeforetoggle(event: Event & { newState: string }): void {\n        if (event.newState !== 'open') {\n            this.handleBrowserClose(event);\n        }\n    }\n\n    /**\n     * Handles the browser's close event to manage the overlay's state.\n     *\n     * This method stops the propagation of the event and closes the overlay if it is not\n     * actively opening. If the overlay is actively opening, it calls `manuallyKeepOpen`.\n     *\n     * @protected\n     * @param {Event} event - The browser's close event.\n     */\n    protected handleBrowserClose(event: Event): void {\n        event.stopPropagation();\n        if (!this.strategy?.activelyOpening) {\n            this.open = false;\n            return;\n        }\n        this.manuallyKeepOpen();\n    }\n\n    /**\n     * Manually keeps the overlay open.\n     *\n     * This method sets the overlay to open, allows placement updates, and manages the open state.\n     *\n     * @public\n     * @override\n     */\n    public override manuallyKeepOpen(): void {\n        this.open = true;\n        this.placementController.allowPlacementUpdate = true;\n        this.manageOpen(false);\n    }\n\n    /**\n     * Handles the `slotchange` event to manage the overlay's state.\n     *\n     * This method checks if there are any elements in the slot. If there are no elements,\n     * it releases the description from the strategy. If there are elements and the trigger\n     * is non-virtual, it prepares the description for the trigger element.\n     *\n     * @protected\n     */\n    protected handleSlotchange(): void {\n        if (!this.elements.length) {\n            // Release the description if there are no elements in the slot.\n            this.strategy?.releaseDescription();\n        } else if (this.hasNonVirtualTrigger) {\n            // Prepare the description for the trigger element if it is non-virtual.\n            this.strategy?.prepareDescription(\n                this.triggerElement as HTMLElement\n            );\n        }\n    }\n\n    /**\n     * Determines whether the overlay should prevent closing.\n     *\n     * This method checks the `willPreventClose` flag and resets it to `false`.\n     * It returns the value of the `willPreventClose` flag.\n     *\n     * @public\n     * @returns {boolean} `true` if the overlay should prevent closing, otherwise `false`.\n     */\n    public shouldPreventClose(): boolean {\n        const shouldPreventClose = this.willPreventClose;\n        this.willPreventClose = false;\n        return shouldPreventClose;\n    }\n\n    /**\n     * Requests slottable content for the overlay.\n     *\n     * This method dispatches a `SlottableRequestEvent` to request or remove slottable content\n     * based on the current open state of the overlay. It ensures that the same state is not\n     * dispatched twice in a row.\n     *\n     * @protected\n     * @override\n     */\n    protected override requestSlottable(): void {\n        // Do not dispatch the same state twice in a row.\n        if (this.lastRequestSlottableState === this.open) {\n            return;\n        }\n\n        // Force a reflow if the overlay is closing.\n        if (!this.open) {\n            document.body.offsetHeight;\n        }\n\n        /**\n         * @ignore\n         */\n        // Dispatch a custom event to request or remove slottable content based on the open state.\n        this.dispatchEvent(\n            new SlottableRequestEvent(\n                'overlay-content',\n                this.open ? {} : removeSlottableRequest\n            )\n        );\n\n        // Update the last request slottable state.\n        this.lastRequestSlottableState = this.open;\n    }\n\n    /**\n     * Lifecycle method called before the component updates.\n     *\n     * This method handles various tasks before the component updates, such as setting an ID,\n     * managing the open state, resolving the trigger element, and binding events.\n     *\n     * @override\n     * @param {PropertyValues} changes - The properties that have changed.\n     */\n    override willUpdate(changes: PropertyValues): void {\n        // Ensure the component has an ID attribute.\n        if (!this.hasAttribute('id')) {\n            this.setAttribute(\n                'id',\n                `${this.tagName.toLowerCase()}-${randomID()}`\n            );\n        }\n\n        // Manage the open state if the 'open' property has changed.\n        if (changes.has('open') && (this.hasUpdated || this.open)) {\n            this.manageOpen(changes.get('open'));\n        }\n\n        // Resolve the trigger element if the 'trigger' property has changed.\n        if (changes.has('trigger')) {\n            const [id, interaction] = this.trigger?.split('@') || [];\n            this.elementResolver.selector = id ? `#${id}` : '';\n            this.triggerInteraction = interaction as\n                | 'click'\n                | 'longpress'\n                | 'hover'\n                | undefined;\n        }\n\n        // Initialize oldTrigger to track the previous trigger element.\n        let oldTrigger: HTMLElement | false | undefined = false;\n\n        // Check if the element resolver has been updated.\n        if (changes.has(elementResolverUpdatedSymbol)) {\n            // Store the current trigger element.\n            oldTrigger = this.triggerElement as HTMLElement;\n            // Update the trigger element from the element resolver.\n            this.triggerElement = this.elementResolver.element;\n        }\n\n        // Check if the 'triggerElement' property has changed.\n        if (changes.has('triggerElement')) {\n            // Store the old trigger element.\n            oldTrigger = changes.get('triggerElement');\n        }\n\n        // If the trigger element has changed, bind the new events.\n        if (oldTrigger !== false) {\n            this.bindEvents();\n        }\n    }\n\n    /**\n     * Lifecycle method called after the component updates.\n     *\n     * This method handles various tasks after the component updates, such as updating the placement\n     * attribute, resetting the overlay position, and clearing the overlay position based on the state.\n     *\n     * @override\n     * @param {PropertyValues} changes - The properties that have changed.\n     */\n    protected override updated(changes: PropertyValues): void {\n        // Call the base class method to handle any initial setup.\n        super.updated(changes);\n\n        // Check if the 'placement' property has changed.\n        if (changes.has('placement')) {\n            if (this.placement) {\n                // Set the 'actual-placement' attribute on the dialog element.\n                this.dialogEl.setAttribute('actual-placement', this.placement);\n            } else {\n                // Remove the 'actual-placement' attribute from the dialog element.\n                this.dialogEl.removeAttribute('actual-placement');\n            }\n\n            // If the overlay is open and the 'placement' property has changed, reset the overlay position.\n            if (this.open && typeof changes.get('placement') !== 'undefined') {\n                this.placementController.resetOverlayPosition();\n            }\n        }\n\n        // Check if the 'state' property has changed and the overlay is closed.\n        if (\n            changes.has('state') &&\n            this.state === 'closed' &&\n            typeof changes.get('state') !== 'undefined'\n        ) {\n            // Clear the overlay position.\n            this.placementController.clearOverlayPosition();\n        }\n    }\n\n    /**\n     * Renders the content of the overlay.\n     *\n     * This method returns a template result containing a slot element. The slot element\n     * listens for the `slotchange` event to manage the overlay's state.\n     *\n     * @protected\n     * @returns {TemplateResult} The template result containing the slot element.\n     */\n    protected renderContent(): TemplateResult {\n        return html`\n            <slot @slotchange=${this.handleSlotchange}></slot>\n        `;\n    }\n\n    /**\n     * Generates a style map for the dialog element.\n     *\n     * This method returns an object containing CSS custom properties for the dialog element.\n     * The `--swc-overlay-open-count` custom property is set to the current open count of overlays.\n     *\n     * @private\n     * @returns {StyleInfo} The style map for the dialog element.\n     */\n    private get dialogStyleMap(): StyleInfo {\n        return {\n            '--swc-overlay-open-count': Overlay.openCount.toString(),\n        };\n    }\n\n    /**\n     * Renders the popover element for the overlay.\n     *\n     * This method returns a template result containing a div element styled as a popover.\n     * The popover element includes various attributes and event listeners to manage the overlay's state and behavior.\n     *\n     * @protected\n     * @returns {TemplateResult} The template result containing the popover element.\n     */\n    protected renderPopover(): TemplateResult {\n        /**\n         * The `--swc-overlay-open-count` custom property is applied to mimic the single stack\n         * nature of the top layer in browsers that do not yet support it.\n         *\n         * The value should always represent the total number of overlays that have ever been opened.\n         * This value will be added to the `--swc-overlay-z-index-base` custom property, which can be\n         * provided by a consuming developer. By default, `--swc-overlay-z-index-base` is set to 1000\n         * to ensure that the overlay stacks above most other elements during fallback delivery.\n         */\n        return html`\n            <div\n                class=\"dialog\"\n                part=\"dialog\"\n                role=${ifDefined(\n                    this.type === 'modal' || this.type === 'page'\n                        ? 'dialog'\n                        : undefined\n                )}\n                aria-modal=${ifDefined(\n                    this.type === 'modal' || this.type === 'page'\n                        ? 'true'\n                        : undefined\n                )}\n                placement=${ifDefined(\n                    this.requiresPositioning\n                        ? this.placement || 'right'\n                        : undefined\n                )}\n                popover=${ifDefined(this.popoverValue)}\n                style=${styleMap(this.dialogStyleMap)}\n                @beforetoggle=${this.handleBeforetoggle}\n                @close=${this.handleBrowserClose}\n                ?is-visible=${this.state !== 'closed'}\n            >\n                ${this.renderContent()}\n            </div>\n        `;\n    }\n\n    /**\n     * Renders the overlay component.\n     *\n     * This method returns a template result containing either a dialog or popover element\n     * based on the overlay type. It also includes a slot for longpress descriptors.\n     *\n     * @override\n     * @returns {TemplateResult} The template result containing the overlay content.\n     */\n    public override render(): TemplateResult {\n        return html`\n            ${this.type === 'modal' || this.type === 'page'\n                ? html`\n                      <popover>\n                          <sp-underlay\n                              ?open=${this.open}\n                              @close=${() => {\n                                  this.open = false;\n                              }}\n                              style=\"--spectrum-underlay-background-color: transparent\"\n                          ></sp-underlay>\n                      </popover>\n                  `\n                : ''}\n            ${this.renderPopover()}\n            <slot name=\"longpress-describedby-descriptor\"></slot>\n        `;\n    }\n\n    /**\n     * Lifecycle method called when the component is added to the DOM.\n     *\n     * This method sets up event listeners and binds events if the component has already updated.\n     *\n     * @override\n     */\n    override connectedCallback(): void {\n        super.connectedCallback();\n\n        // Add an event listener to handle the 'close' event and update the 'open' property.\n        this.addEventListener('close', () => {\n            this.open = false;\n        });\n\n        // Bind events if the component has already updated.\n        if (this.hasUpdated) {\n            this.bindEvents();\n        }\n    }\n\n    /**\n     * Lifecycle method called when the component is removed from the DOM.\n     *\n     * This method releases the description from the strategy and updates the 'open' property.\n     *\n     * @override\n     */\n    override disconnectedCallback(): void {\n        // Release the description from the strategy.\n        this.strategy?.releaseDescription();\n        // Update the 'open' property to false.\n        this.open = false;\n        super.disconnectedCallback();\n    }\n}\n"],
  "mappings": "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",
  "names": ["event", "state", "_a"]
}
