{
  "version": 3,
  "sources": ["Overlay.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n    html,\n    PropertyValues,\n    TemplateResult,\n} from '@spectrum-web-components/base';\nimport {\n    property,\n    query,\n    queryAssignedElements,\n    state,\n} from '@spectrum-web-components/base/src/decorators.js';\nimport {\n    ElementResolutionController,\n    elementResolverUpdatedSymbol,\n} from '@spectrum-web-components/reactive-controllers/src/ElementResolution.js';\nimport {\n    ifDefined,\n    StyleInfo,\n    styleMap,\n} from '@spectrum-web-components/base/src/directives.js';\nimport { randomID } from '@spectrum-web-components/shared/src/random-id.js';\nimport type {\n    OpenableElement,\n    OverlayState,\n    OverlayTypes,\n    Placement,\n    TriggerInteraction,\n} from './overlay-types.js';\nimport { AbstractOverlay, nextFrame } from './AbstractOverlay.js';\nimport { OverlayPopover } from './OverlayPopover.js';\nimport { OverlayNoPopover } from './OverlayNoPopover.js';\nimport { overlayStack } from './OverlayStack.js';\nimport { VirtualTrigger } from './VirtualTrigger.js';\nimport { PlacementController } from './PlacementController.js';\nimport type { ClickController } from './ClickController.js';\nimport type { HoverController } from './HoverController.js';\nimport type { LongpressController } from './LongpressController.js';\nexport { LONGPRESS_INSTRUCTIONS } from './LongpressController.js';\nimport { strategies } from './strategies.js';\nimport {\n    removeSlottableRequest,\n    SlottableRequestEvent,\n} from './slottable-request-event.js';\n\nimport styles from './overlay.css.js';\nimport { FocusTrap } from 'focus-trap';\n\nconst browserSupportsPopover = 'showPopover' in document.createElement('div');\n\n// Start the base class and add the popover or no-popover functionality\nlet ComputedOverlayBase = OverlayPopover(AbstractOverlay);\nif (!browserSupportsPopover) {\n    ComputedOverlayBase = OverlayNoPopover(AbstractOverlay);\n}\n\n/**\n * @element sp-overlay\n *\n * @slot default - The content that will be displayed in the overlay\n *\n * @fires sp-opened - announces that an overlay has completed any entry animations\n * @fires sp-closed - announce that an overlay has compelted any exit animations\n * @fires slottable-request - requests to add or remove slottable content\n *\n * @attr {string} placement - The placement of the overlay relative to the trigger\n * @attr {number} offset - The distance between the overlay and the trigger\n * @attr {boolean} disabled - Whether the overlay trigger is disabled\n * @attr {string} receives-focus - How focus should be handled ('true'|'false'|'auto')\n * @attr {boolean} delayed - Whether the overlay should wait for a warm-up period before opening\n * @attr {boolean} open - Whether the overlay is currently open\n */\nexport class Overlay extends ComputedOverlayBase {\n    static override styles = [styles];\n\n    /**\n     * An Overlay that is `delayed` will wait until a warm-up period of 1000ms\n     * has completed before opening. Once the warm-up period has completed, all\n     * subsequent Overlays will open immediately. When no Overlays are opened,\n     * a cool-down period of 1000ms will begin. Once the cool-down has completed,\n     * the next Overlay to be opened will be subject to the warm-up period if\n     * provided that option.\n     *\n     * This behavior helps to manage the performance and user experience by\n     * preventing multiple overlays from opening simultaneously and ensuring\n     * a smooth transition between opening and closing overlays.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    @property({ type: Boolean })\n    override get delayed(): boolean {\n        return this.elements.at(-1)?.hasAttribute('delayed') || this._delayed;\n    }\n\n    override set delayed(delayed: boolean) {\n        this._delayed = delayed;\n    }\n\n    private _delayed = false;\n\n    /**\n     * A reference to the dialog element within the overlay.\n     * This element is expected to have `showPopover` and `hidePopover` methods.\n     */\n    @query('.dialog')\n    override dialogEl!: HTMLDialogElement & {\n        showPopover(): void;\n        hidePopover(): void;\n    };\n\n    /**\n     * Indicates whether the overlay is currently functional or not.\n     *\n     * When set to `true`, the overlay is disabled, and any active strategy is aborted.\n     * The overlay will also close if it is currently open. When set to `false`, the\n     * overlay will re-bind events and re-open if it was previously open.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    @property({ type: Boolean })\n    override get disabled(): boolean {\n        return this._disabled;\n    }\n\n    override set disabled(disabled: boolean) {\n        this._disabled = disabled;\n        if (disabled) {\n            // Abort any active strategy and close the overlay if it is currently open\n            this.strategy?.abort();\n            this.wasOpen = this.open;\n            this.open = false;\n        } else {\n            // Re-bind events and re-open the overlay if it was previously open\n            this.bindEvents();\n            this.open = this.open || this.wasOpen;\n            this.wasOpen = false;\n        }\n    }\n\n    private _disabled = false;\n\n    /**\n     * A query to gather all elements slotted into the default slot, excluding elements\n     * with the slot name \"longpress-describedby-descriptor\".\n     */\n    @queryAssignedElements({\n        flatten: true,\n        selector: ':not([slot=\"longpress-describedby-descriptor\"], slot)',\n    })\n    override elements!: OpenableElement[];\n\n    /**\n     * A reference to the parent overlay that should be force-closed, if any.\n     */\n    public parentOverlayToForceClose?: Overlay;\n\n    /**\n     * Determines if the overlay has a non-virtual trigger element.\n     *\n     * @returns {boolean} `true` if the trigger element is not a virtual trigger, otherwise `false`.\n     */\n    private get hasNonVirtualTrigger(): boolean {\n        return (\n            !!this.triggerElement &&\n            !(this.triggerElement instanceof VirtualTrigger)\n        );\n    }\n\n    /**\n     * The `offset` property accepts either a single number to define the offset of the\n     * Overlay along the main axis from the trigger, or a 2-tuple to define the offset\n     * along both the main axis and the cross axis. This option has no effect when there\n     * is no trigger element.\n     *\n     * @type {number | [number, number]}\n     * @default 0\n     */\n    @property({ type: Number })\n    override offset: number | [number, number] = 0;\n\n    /**\n     * Provides an instance of the `PlacementController` for managing the positioning\n     * of the overlay relative to its trigger element.\n     *\n     * If the `PlacementController` instance does not already exist, it is created and\n     * assigned to the `_placementController` property.\n     *\n     * @protected\n     * @returns {PlacementController} The `PlacementController` instance.\n     */\n    protected override get placementController(): PlacementController {\n        if (!this._placementController) {\n            this._placementController = new PlacementController(this);\n        }\n        return this._placementController;\n    }\n\n    /**\n     * Indicates whether the Overlay is projected onto the \"top layer\" or not.\n     *\n     * When set to `true`, the overlay is open and visible. When set to `false`, the overlay is closed and hidden.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    @property({ type: Boolean, reflect: true })\n    override get open(): boolean {\n        return this._open;\n    }\n\n    override set open(open: boolean) {\n        // Don't respond if the overlay is disabled.\n        if (open && this.disabled) return;\n\n        // Don't respond if the state is not changing.\n        if (open === this.open) return;\n\n        // Don't respond if the overlay is in the shadow state during a longpress.\n        // The shadow state occurs when the first \"click\" would normally close the popover.\n        if (this.strategy?.activelyOpening && !open) return;\n\n        // Update the internal _open property.\n        this._open = open;\n\n        // Increment the open count if the overlay is opening.\n        if (this.open) {\n            Overlay.openCount += 1;\n        }\n\n        // Request an update to re-render the component if necessary.\n        this.requestUpdate('open', !this.open);\n\n        // Request slottable content if the overlay is opening.\n        if (this.open) {\n            this.requestSlottable();\n        }\n    }\n\n    private _open = false;\n\n    /**\n     * Tracks the number of overlays that have been opened.\n     *\n     * This static property is used to manage the stacking context of multiple overlays.\n     *\n     * @type {number}\n     * @default 1\n     */\n    static openCount = 1;\n\n    /**\n     * Instruct the Overlay where to place itself in relationship to the trigger element.\n     *\n     * @type {\"top\" | \"top-start\" | \"top-end\" | \"right\" | \"right-start\" | \"right-end\" | \"bottom\" | \"bottom-start\" | \"bottom-end\" | \"left\" | \"left-start\" | \"left-end\"}\n     */\n    @property()\n    override placement?: Placement;\n\n    /**\n     * The state in which the last `request-slottable` event was dispatched.\n     *\n     * This property ensures that overlays do not dispatch the same state twice in a row.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    private lastRequestSlottableState = false;\n\n    /**\n     * Whether to pass focus to the overlay once opened, or\n     * to the appropriate value based on the \"type\" of the overlay\n     * when set to `\"auto\"`.\n     *\n     * @type {'true' | 'false' | 'auto'}\n     * @default 'auto'\n     */\n    @property({ attribute: 'receives-focus' })\n    override receivesFocus: 'true' | 'false' | 'auto' = 'auto';\n\n    /**\n     * A reference to the slot element within the overlay.\n     *\n     * This element is used to manage the content slotted into the overlay.\n     *\n     * @type {HTMLSlotElement}\n     */\n    @query('slot')\n    slotEl!: HTMLSlotElement;\n\n    /**\n     * The current state of the overlay.\n     *\n     * This property reflects the current state of the overlay, such as 'opened' or 'closed'.\n     * When the state changes, it triggers the appropriate actions and updates the component.\n     *\n     * @type {OverlayState}\n     * @default 'closed'\n     */\n    @state()\n    override get state(): OverlayState {\n        return this._state;\n    }\n\n    override set state(state) {\n        // Do not respond if the state is not changing.\n        if (state === this.state) return;\n\n        const oldState = this.state;\n\n        this._state = state;\n\n        // Complete the opening strategy if the state is 'opened' or 'closed'.\n        if (this.state === 'opened' || this.state === 'closed') {\n            this.strategy?.shouldCompleteOpen();\n        }\n\n        // Request an update to re-render the component if necessary.\n        this.requestUpdate('state', oldState);\n    }\n\n    override _state: OverlayState = 'closed';\n\n    /**\n     * The interaction strategy for opening the overlay.\n     * This can be a ClickController, HoverController, or LongpressController.\n     */\n    public strategy?: ClickController | HoverController | LongpressController;\n\n    /**\n     * The padding around the tip of the overlay.\n     * This property defines the padding around the tip of the overlay, which can be used to adjust its positioning.\n     *\n     * @type {number}\n     */\n    @property({ type: Number, attribute: 'tip-padding' })\n    tipPadding?: number;\n\n    /**\n     * An optional ID reference for the trigger element combined with the optional\n     * interaction (click | hover | longpress) by which the overlay should open.\n     * The format is `trigger@interaction`, e.g., `trigger@click` opens the overlay\n     * when an element with the ID \"trigger\" is clicked.\n     *\n     * @type {string}\n     */\n    @property()\n    trigger?: string;\n\n    /**\n     * An element reference for the trigger element that the overlay should relate to.\n     * This property is not reflected as an attribute.\n     *\n     * @type {HTMLElement | VirtualTrigger | null}\n     */\n    @property({ attribute: false })\n    override triggerElement: HTMLElement | VirtualTrigger | null = null;\n\n    /**\n     * The specific interaction to listen for on the `triggerElement` to open the overlay.\n     * This property is not reflected as an attribute.\n     *\n     * @type {TriggerInteraction}\n     */\n    @property({ attribute: false })\n    triggerInteraction?: TriggerInteraction;\n\n    /**\n     * Configures the open/close heuristics of the Overlay.\n     *\n     * @type {\"auto\" | \"hint\" | \"manual\" | \"modal\" | \"page\"}\n     * @default \"auto\"\n     */\n    @property()\n    override type: OverlayTypes = 'auto';\n\n    /**\n     * Tracks whether the overlay was previously open.\n     * This is used to restore the open state when re-enabling the overlay.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    protected wasOpen = false;\n\n    /**\n     * Focus trap to keep focus within the dialog\n     * @private\n     */\n    private _focusTrap: FocusTrap | null = null;\n\n    /**\n     * Provides an instance of the `ElementResolutionController` for managing the element\n     * that the overlay should be associated with. If the instance does not already exist,\n     * it is created and assigned to the `_elementResolver` property.\n     *\n     * @protected\n     * @returns {ElementResolutionController} The `ElementResolutionController` instance.\n     */\n    protected override get elementResolver(): ElementResolutionController {\n        if (!this._elementResolver) {\n            this._elementResolver = new ElementResolutionController(this);\n        }\n\n        return this._elementResolver;\n    }\n\n    /**\n     * Determines the value for the popover attribute based on the overlay type.\n     *\n     * @private\n     * @returns {'auto' | 'manual' | undefined} The popover value or undefined if not applicable.\n     */\n    private get popoverValue(): 'auto' | 'manual' | undefined {\n        const hasPopoverAttribute = 'popover' in this;\n\n        if (!hasPopoverAttribute) {\n            return undefined;\n        }\n\n        switch (this.type) {\n            case 'modal':\n                return 'auto';\n            case 'page':\n                return 'manual';\n            case 'hint':\n                return 'manual';\n            default:\n                return this.type;\n        }\n    }\n\n    /**\n     * Determines if the overlay requires positioning based on its type and state.\n     *\n     * @protected\n     * @returns {boolean} True if the overlay requires positioning, otherwise false.\n     */\n    protected get requiresPositioning(): boolean {\n        // Do not position \"page\" overlays as they should block the entire UI.\n        if (this.type === 'page' || !this.open) return false;\n\n        // Do not position content without a trigger element, as there is nothing to position it relative to.\n        // Do not automatically position content unless it is a \"hint\".\n        if (!this.triggerElement || (!this.placement && this.type !== 'hint'))\n            return false;\n\n        return true;\n    }\n\n    /**\n     * Manages the positioning of the overlay relative to its trigger element.\n     *\n     * This method calculates the necessary parameters for positioning the overlay,\n     * such as offset, placement, and tip padding, and then delegates the actual\n     * positioning to the `PlacementController`.\n     *\n     * @protected\n     * @override\n     */\n    protected override managePosition(): void {\n        // Do not proceed if positioning is not required or the overlay is not open.\n        if (!this.requiresPositioning || !this.open) return;\n\n        const offset = this.offset || 0;\n\n        const trigger = this.triggerElement as HTMLElement;\n\n        const placement = (this.placement as Placement) || 'right';\n\n        const tipPadding = this.tipPadding;\n\n        this.placementController.placeOverlay(this.dialogEl, {\n            offset,\n            placement,\n            tipPadding,\n            trigger,\n            type: this.type,\n        });\n    }\n\n    /**\n     * Manages the process of opening the popover.\n     *\n     * This method handles the necessary steps to open the popover, including managing delays,\n     * ensuring the popover is in the DOM, making transitions, and applying focus.\n     *\n     * @protected\n     * @override\n     * @returns {Promise<void>} A promise that resolves when the popover has been fully opened.\n     */\n    protected override async managePopoverOpen(): Promise<void> {\n        // Call the base class method to handle any initial setup.\n        super.managePopoverOpen();\n\n        const targetOpenState = this.open;\n\n        // Ensure the open state has not changed before proceeding.\n        if (this.open !== targetOpenState) {\n            return;\n        }\n\n        // Manage any delays before opening the popover.\n        await this.manageDelay(targetOpenState);\n\n        if (this.open !== targetOpenState) {\n            return;\n        }\n\n        // Only wait for next frame if `longpress` is the trigger.\n        // In Safari, awaiting nextFrame here causes layout issues\n        // when rendering trays inside modals, so we skip it otherwise.\n        if (this.triggerInteraction === 'longpress') {\n            await nextFrame();\n        }\n\n        // Ensure the popover is in the DOM before proceeding.\n        await this.ensureOnDOM(targetOpenState);\n\n        if (this.open !== targetOpenState) {\n            return;\n        }\n\n        // Make any necessary transitions for opening the popover.\n        const focusEl = await this.makeTransition(targetOpenState);\n\n        if (this.open !== targetOpenState) {\n            return;\n        }\n        if (targetOpenState) {\n            const focusTrap = await import('focus-trap');\n            this._focusTrap = focusTrap.createFocusTrap(this.dialogEl, {\n                initialFocus: focusEl || undefined,\n                tabbableOptions: {\n                    getShadowRoot: true,\n                },\n                fallbackFocus: () => {\n                    // set tabIndex to -1 allow the focus-trap to still be applied\n                    this.dialogEl.setAttribute('tabIndex', '-1');\n                    return this.dialogEl;\n                },\n                // disable escape key capture to close the overlay, the focus-trap library captures it otherwise\n                escapeDeactivates: false,\n            });\n\n            if (this.type === 'modal' || this.type === 'page') {\n                this._focusTrap.activate();\n            }\n        }\n        // Apply focus to the appropriate element after opening the popover.\n        await this.applyFocus(targetOpenState, focusEl);\n    }\n\n    /**\n     * Applies focus to the appropriate element after the popover has been opened.\n     *\n     * This method handles the focus management for the overlay, ensuring that the correct\n     * element receives focus based on the overlay's type and state.\n     *\n     * @protected\n     * @override\n     * @param {boolean} targetOpenState - The target open state of the overlay.\n     * @param {HTMLElement | null} focusEl - The element to focus after opening the popover.\n     * @returns {Promise<void>} A promise that resolves when the focus has been applied.\n     */\n    protected override async applyFocus(\n        targetOpenState: boolean,\n        focusEl: HTMLElement | null\n    ): Promise<void> {\n        // Do not move focus when explicitly told not to or when the overlay is a \"hint\".\n        if (this.receivesFocus === 'false' || this.type === 'hint') {\n            return;\n        }\n\n        // Wait for the next two animation frames to ensure the DOM is updated.\n        await nextFrame();\n        await nextFrame();\n\n        // If the open state has changed during the delay, do not proceed.\n        if (targetOpenState === this.open && !this.open) {\n            // If the overlay is closing and the trigger element is still focused, return focus to the trigger element.\n            if (\n                this.hasNonVirtualTrigger &&\n                this.contains((this.getRootNode() as Document).activeElement)\n            ) {\n                (this.triggerElement as HTMLElement).focus();\n            }\n            return;\n        }\n\n        // Apply focus to the specified focus element.\n        focusEl?.focus();\n    }\n\n    /**\n     * Returns focus to the trigger element if the overlay is closed.\n     *\n     * This method ensures that focus is returned to the trigger element when the overlay is closed,\n     * unless the overlay is of type \"hint\" or the focus is already outside the overlay.\n     *\n     * @protected\n     * @override\n     */\n    protected override returnFocus(): void {\n        // Do not proceed if the overlay is open or if the overlay type is \"hint\".\n        if (this.open || this.type === 'hint') return;\n\n        /**\n         * Retrieves the ancestors of the currently focused element.\n         *\n         * @returns {HTMLElement[]} An array of ancestor elements.\n         */\n        const getAncestors = (): HTMLElement[] => {\n            const ancestors: HTMLElement[] = [];\n\n            // eslint-disable-next-line @spectrum-web-components/document-active-element\n            let currentNode = document.activeElement;\n\n            // Traverse the shadow DOM to find the active element.\n            while (currentNode?.shadowRoot?.activeElement) {\n                currentNode = currentNode.shadowRoot.activeElement;\n            }\n\n            // Traverse the DOM tree to collect ancestor elements.\n            while (currentNode) {\n                const ancestor =\n                    currentNode.assignedSlot ||\n                    currentNode.parentElement ||\n                    (currentNode.getRootNode() as ShadowRoot)?.host;\n                if (ancestor) {\n                    ancestors.push(ancestor as HTMLElement);\n                }\n                currentNode = ancestor;\n            }\n            return ancestors;\n        };\n\n        // Check if focus should be returned to the trigger element.\n        if (\n            this.receivesFocus !== 'false' &&\n            !!(this.triggerElement as HTMLElement)?.focus &&\n            (this.contains((this.getRootNode() as Document).activeElement) ||\n                getAncestors().includes(this) ||\n                // eslint-disable-next-line @spectrum-web-components/document-active-element\n                document.activeElement === document.body)\n        ) {\n            // Return focus to the trigger element.\n            (this.triggerElement as HTMLElement).focus();\n        }\n    }\n\n    /**\n     * Handles the focus out event to close the overlay if the focus moves outside of it.\n     *\n     * This method ensures that the overlay is closed when the focus moves to an element\n     * outside of the overlay, unless the focus is moved to a related element.\n     *\n     * @private\n     * @param {FocusEvent} event - The focus out event.\n     */\n    private closeOnFocusOut = (event: FocusEvent): void => {\n        // If the related target (newly focused element) is not known, do nothing.\n        if (!event.relatedTarget) {\n            return;\n        }\n\n        // Create a custom event to query the relationship of the newly focused element.\n        const relationEvent = new Event('overlay-relation-query', {\n            bubbles: true,\n            composed: true,\n        });\n\n        // Add an event listener to the related target to handle the custom event.\n        event.relatedTarget.addEventListener(\n            relationEvent.type,\n            (event: Event) => {\n                // Check if the newly focused element is within the overlay or its children\n                const path = event.composedPath();\n                const isWithinOverlay = path.some((el) => el === this);\n\n                // Only close if focus moves outside the overlay and its children\n                if (!isWithinOverlay) {\n                    this.open = false;\n                }\n            }\n        );\n\n        // Dispatch the custom event to the related target.\n        event.relatedTarget.dispatchEvent(relationEvent);\n    };\n\n    private closeOnCancelEvent = (): void => {\n        this.open = false;\n    };\n\n    /**\n     * Manages the process of opening or closing the overlay.\n     *\n     * This method handles the necessary steps to open or close the overlay, including updating the state,\n     * managing the overlay stack, and handling focus events.\n     *\n     * @protected\n     * @param {boolean} oldOpen - The previous open state of the overlay.\n     * @returns {Promise<void>} A promise that resolves when the overlay has been fully managed.\n     */\n    protected async manageOpen(oldOpen: boolean): Promise<void> {\n        // Prevent entering the manage workflow if the overlay is not connected to the DOM.\n        // The `.showPopover()` event will error on content that is not connected to the DOM.\n        if (!this.isConnected && this.open) return;\n\n        // Wait for the component to finish updating if it has not already done so.\n        if (!this.hasUpdated) {\n            await this.updateComplete;\n        }\n\n        if (this.open) {\n            // Add the overlay to the overlay stack.\n            overlayStack.add(this);\n\n            if (this.willPreventClose) {\n                // Add an event listener to handle the pointerup event and toggle the 'not-immediately-closable' class.\n                document.addEventListener(\n                    'pointerup',\n                    () => {\n                        this.dialogEl.classList.toggle(\n                            'not-immediately-closable',\n                            false\n                        );\n                        this.willPreventClose = false;\n                    },\n                    { once: true }\n                );\n                this.dialogEl.classList.toggle(\n                    'not-immediately-closable',\n                    true\n                );\n            }\n        } else {\n            if (oldOpen) {\n                this._focusTrap?.deactivate();\n                this._focusTrap = null;\n                // Dispose of the overlay if it was previously open.\n                this.dispose();\n            }\n\n            // Remove the overlay from the overlay stack.\n            overlayStack.remove(this);\n        }\n\n        // Update the state of the overlay based on the open property.\n        if (this.open && this.state !== 'opened') {\n            this.state = 'opening';\n        } else if (!this.open && this.state !== 'closed') {\n            this.state = 'closing';\n        }\n\n        this.managePopoverOpen();\n\n        const listenerRoot = this.getRootNode() as Document;\n        // Handle focus events for auto type overlays.\n        if (this.type === 'auto') {\n            if (this.open) {\n                listenerRoot.addEventListener(\n                    'focusout',\n                    this.closeOnFocusOut,\n                    { capture: true }\n                );\n            } else {\n                listenerRoot.removeEventListener(\n                    'focusout',\n                    this.closeOnFocusOut,\n                    { capture: true }\n                );\n            }\n        }\n\n        // Handle cancel events for modal and page type overlays.\n        if (this.type === 'modal' || this.type === 'page') {\n            if (this.open) {\n                listenerRoot.addEventListener(\n                    'cancel',\n                    this.closeOnCancelEvent,\n                    {\n                        capture: true,\n                    }\n                );\n            } else {\n                listenerRoot.removeEventListener(\n                    'cancel',\n                    this.closeOnCancelEvent,\n                    {\n                        capture: true,\n                    }\n                );\n            }\n        }\n    }\n\n    /**\n     * Binds event handling strategies to the overlay based on the specified trigger interaction.\n     *\n     * This method sets up the appropriate event handling strategy for the overlay, ensuring that\n     * it responds correctly to user interactions such as clicks, hovers, or long presses.\n     *\n     * @protected\n     */\n    protected bindEvents(): void {\n        // Abort any existing strategy to ensure a clean setup.\n        this.strategy?.abort();\n        this.strategy = undefined;\n\n        // Return early if there is no non-virtual trigger element.\n        if (!this.hasNonVirtualTrigger) return;\n\n        // Return early if no trigger interaction is specified.\n        if (!this.triggerInteraction) return;\n\n        // Set up a new event handling strategy based on the specified trigger interaction.\n        this.strategy = new strategies[this.triggerInteraction](\n            this.triggerElement as HTMLElement,\n            {\n                overlay: this,\n            }\n        );\n    }\n\n    /**\n     * Handles the `beforetoggle` event to manage the overlay's state.\n     *\n     * This method checks the new state of the event and calls `handleBrowserClose`\n     * if the new state is not 'open'.\n     *\n     * @protected\n     * @param {Event & { newState: string }} event - The `beforetoggle` event with the new state.\n     */\n    protected handleBeforetoggle(event: Event & { newState: string }): void {\n        if (event.newState !== 'open') {\n            this.handleBrowserClose(event);\n        }\n    }\n\n    /**\n     * Handles the browser's close event to manage the overlay's state.\n     *\n     * This method stops the propagation of the event and closes the overlay if it is not\n     * actively opening. If the overlay is actively opening, it calls `manuallyKeepOpen`.\n     *\n     * @protected\n     * @param {Event} event - The browser's close event.\n     */\n    protected handleBrowserClose(event: Event): void {\n        event.stopPropagation();\n        if (!this.strategy?.activelyOpening) {\n            this.open = false;\n            return;\n        }\n        this.manuallyKeepOpen();\n    }\n\n    /**\n     * Manually keeps the overlay open.\n     *\n     * This method sets the overlay to open, allows placement updates, and manages the open state.\n     *\n     * @public\n     * @override\n     */\n    public override manuallyKeepOpen(): void {\n        this.open = true;\n        this.placementController.allowPlacementUpdate = true;\n        this.manageOpen(false);\n    }\n\n    /**\n     * Handles the `slotchange` event to manage the overlay's state.\n     *\n     * This method checks if there are any elements in the slot. If there are no elements,\n     * it releases the description from the strategy. If there are elements and the trigger\n     * is non-virtual, it prepares the description for the trigger element.\n     *\n     * @protected\n     */\n    protected handleSlotchange(): void {\n        if (!this.elements.length) {\n            // Release the description if there are no elements in the slot.\n            this.strategy?.releaseDescription();\n        } else if (this.hasNonVirtualTrigger) {\n            // Prepare the description for the trigger element if it is non-virtual.\n            this.strategy?.prepareDescription(\n                this.triggerElement as HTMLElement\n            );\n        }\n    }\n\n    /**\n     * Determines whether the overlay should prevent closing.\n     *\n     * This method checks the `willPreventClose` flag and resets it to `false`.\n     * It returns the value of the `willPreventClose` flag.\n     *\n     * @public\n     * @returns {boolean} `true` if the overlay should prevent closing, otherwise `false`.\n     */\n    public shouldPreventClose(): boolean {\n        const shouldPreventClose = this.willPreventClose;\n        this.willPreventClose = false;\n        return shouldPreventClose;\n    }\n\n    /**\n     * Requests slottable content for the overlay.\n     *\n     * This method dispatches a `SlottableRequestEvent` to request or remove slottable content\n     * based on the current open state of the overlay. It ensures that the same state is not\n     * dispatched twice in a row.\n     *\n     * @protected\n     * @override\n     */\n    protected override requestSlottable(): void {\n        // Do not dispatch the same state twice in a row.\n        if (this.lastRequestSlottableState === this.open) {\n            return;\n        }\n\n        // Force a reflow if the overlay is closing.\n        if (!this.open) {\n            document.body.offsetHeight;\n        }\n\n        /**\n         * @ignore\n         */\n        // Dispatch a custom event to request or remove slottable content based on the open state.\n        this.dispatchEvent(\n            new SlottableRequestEvent(\n                'overlay-content',\n                this.open ? {} : removeSlottableRequest\n            )\n        );\n\n        // Update the last request slottable state.\n        this.lastRequestSlottableState = this.open;\n    }\n\n    /**\n     * Lifecycle method called before the component updates.\n     *\n     * This method handles various tasks before the component updates, such as setting an ID,\n     * managing the open state, resolving the trigger element, and binding events.\n     *\n     * @override\n     * @param {PropertyValues} changes - The properties that have changed.\n     */\n    override willUpdate(changes: PropertyValues): void {\n        // Ensure the component has an ID attribute.\n        if (!this.hasAttribute('id')) {\n            this.setAttribute(\n                'id',\n                `${this.tagName.toLowerCase()}-${randomID()}`\n            );\n        }\n\n        // Manage the open state if the 'open' property has changed.\n        if (changes.has('open') && (this.hasUpdated || this.open)) {\n            this.manageOpen(changes.get('open'));\n        }\n\n        // Resolve the trigger element if the 'trigger' property has changed.\n        if (changes.has('trigger')) {\n            const [id, interaction] = this.trigger?.split('@') || [];\n            this.elementResolver.selector = id ? `#${id}` : '';\n            this.triggerInteraction = interaction as\n                | 'click'\n                | 'longpress'\n                | 'hover'\n                | undefined;\n        }\n\n        // Initialize oldTrigger to track the previous trigger element.\n        let oldTrigger: HTMLElement | false | undefined = false;\n\n        // Check if the element resolver has been updated.\n        if (changes.has(elementResolverUpdatedSymbol)) {\n            // Store the current trigger element.\n            oldTrigger = this.triggerElement as HTMLElement;\n            // Update the trigger element from the element resolver.\n            this.triggerElement = this.elementResolver.element;\n        }\n\n        // Check if the 'triggerElement' property has changed.\n        if (changes.has('triggerElement')) {\n            // Store the old trigger element.\n            oldTrigger = changes.get('triggerElement');\n        }\n\n        // If the trigger element has changed, bind the new events.\n        if (oldTrigger !== false) {\n            this.bindEvents();\n        }\n    }\n\n    /**\n     * Lifecycle method called after the component updates.\n     *\n     * This method handles various tasks after the component updates, such as updating the placement\n     * attribute, resetting the overlay position, and clearing the overlay position based on the state.\n     *\n     * @override\n     * @param {PropertyValues} changes - The properties that have changed.\n     */\n    protected override updated(changes: PropertyValues): void {\n        // Call the base class method to handle any initial setup.\n        super.updated(changes);\n\n        // Check if the 'placement' property has changed.\n        if (changes.has('placement')) {\n            if (this.placement) {\n                // Set the 'actual-placement' attribute on the dialog element.\n                this.dialogEl.setAttribute('actual-placement', this.placement);\n            } else {\n                // Remove the 'actual-placement' attribute from the dialog element.\n                this.dialogEl.removeAttribute('actual-placement');\n            }\n\n            // If the overlay is open and the 'placement' property has changed, reset the overlay position.\n            if (this.open && typeof changes.get('placement') !== 'undefined') {\n                this.placementController.resetOverlayPosition();\n            }\n        }\n\n        // Check if the 'state' property has changed and the overlay is closed.\n        if (\n            changes.has('state') &&\n            this.state === 'closed' &&\n            typeof changes.get('state') !== 'undefined'\n        ) {\n            // Clear the overlay position.\n            this.placementController.clearOverlayPosition();\n        }\n    }\n\n    /**\n     * Renders the content of the overlay.\n     *\n     * This method returns a template result containing a slot element. The slot element\n     * listens for the `slotchange` event to manage the overlay's state.\n     *\n     * @protected\n     * @returns {TemplateResult} The template result containing the slot element.\n     */\n    protected renderContent(): TemplateResult {\n        return html`\n            <slot @slotchange=${this.handleSlotchange}></slot>\n        `;\n    }\n\n    /**\n     * Generates a style map for the dialog element.\n     *\n     * This method returns an object containing CSS custom properties for the dialog element.\n     * The `--swc-overlay-open-count` custom property is set to the current open count of overlays.\n     *\n     * @private\n     * @returns {StyleInfo} The style map for the dialog element.\n     */\n    private get dialogStyleMap(): StyleInfo {\n        return {\n            '--swc-overlay-open-count': Overlay.openCount.toString(),\n        };\n    }\n\n    /**\n     * Renders the popover element for the overlay.\n     *\n     * This method returns a template result containing a div element styled as a popover.\n     * The popover element includes various attributes and event listeners to manage the overlay's state and behavior.\n     *\n     * @protected\n     * @returns {TemplateResult} The template result containing the popover element.\n     */\n    protected renderPopover(): TemplateResult {\n        /**\n         * The `--swc-overlay-open-count` custom property is applied to mimic the single stack\n         * nature of the top layer in browsers that do not yet support it.\n         *\n         * The value should always represent the total number of overlays that have ever been opened.\n         * This value will be added to the `--swc-overlay-z-index-base` custom property, which can be\n         * provided by a consuming developer. By default, `--swc-overlay-z-index-base` is set to 1000\n         * to ensure that the overlay stacks above most other elements during fallback delivery.\n         */\n        return html`\n            <div\n                class=\"dialog\"\n                part=\"dialog\"\n                role=${ifDefined(\n                    this.type === 'modal' || this.type === 'page'\n                        ? 'dialog'\n                        : undefined\n                )}\n                aria-modal=${ifDefined(\n                    this.type === 'modal' || this.type === 'page'\n                        ? 'true'\n                        : undefined\n                )}\n                placement=${ifDefined(\n                    this.requiresPositioning\n                        ? this.placement || 'right'\n                        : undefined\n                )}\n                popover=${ifDefined(this.popoverValue)}\n                style=${styleMap(this.dialogStyleMap)}\n                @beforetoggle=${this.handleBeforetoggle}\n                @close=${this.handleBrowserClose}\n                ?is-visible=${this.state !== 'closed'}\n            >\n                ${this.renderContent()}\n            </div>\n        `;\n    }\n\n    /**\n     * Renders the overlay component.\n     *\n     * This method returns a template result containing either a dialog or popover element\n     * based on the overlay type. It also includes a slot for longpress descriptors.\n     *\n     * @override\n     * @returns {TemplateResult} The template result containing the overlay content.\n     */\n    public override render(): TemplateResult {\n        return html`\n            ${this.renderPopover()}\n            <slot name=\"longpress-describedby-descriptor\"></slot>\n        `;\n    }\n\n    /**\n     * Lifecycle method called when the component is added to the DOM.\n     *\n     * This method sets up event listeners and binds events if the component has already updated.\n     *\n     * @override\n     */\n    override connectedCallback(): void {\n        super.connectedCallback();\n\n        // Add an event listener to handle the 'close' event and update the 'open' property.\n        this.addEventListener('close', () => {\n            this.open = false;\n        });\n\n        // Bind events if the component has already updated.\n        if (this.hasUpdated) {\n            this.bindEvents();\n        }\n    }\n\n    /**\n     * Lifecycle method called when the component is removed from the DOM.\n     *\n     * This method releases the description from the strategy and updates the 'open' property.\n     *\n     * @override\n     */\n    override disconnectedCallback(): void {\n        // Release the description from the strategy.\n        this.strategy?.releaseDescription();\n        // Update the 'open' property to false.\n        this.open = false;\n        super.disconnectedCallback();\n    }\n}\n"],
  "mappings": "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",
  "names": ["html", "property", "query", "queryAssignedElements", "state", "ElementResolutionController", "elementResolverUpdatedSymbol", "ifDefined", "styleMap", "randomID", "AbstractOverlay", "nextFrame", "OverlayPopover", "OverlayNoPopover", "overlayStack", "VirtualTrigger", "PlacementController", "strategies", "removeSlottableRequest", "SlottableRequestEvent", "styles", "browserSupportsPopover", "ComputedOverlayBase", "_Overlay", "event", "relationEvent", "el", "_a", "delayed", "disabled", "open", "oldState", "offset", "trigger", "placement", "tipPadding", "targetOpenState", "focusEl", "focusTrap", "getAncestors", "_b", "ancestors", "currentNode", "ancestor", "oldOpen", "listenerRoot", "shouldPreventClose", "changes", "id", "interaction", "oldTrigger", "__decorateClass"]
}
