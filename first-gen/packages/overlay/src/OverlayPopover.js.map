{
  "version": 3,
  "sources": ["OverlayPopover.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport {\n    firstFocusableIn,\n    firstFocusableSlottedIn,\n} from '@spectrum-web-components/shared/src/first-focusable-in.js';\nimport type { SpectrumElement } from '@spectrum-web-components/base';\nimport { VirtualTrigger } from './VirtualTrigger.js';\nimport { Constructor, OpenableElement } from './overlay-types.js';\nimport {\n    guaranteedAllTransitionend,\n    nextFrame,\n    overlayTimer,\n} from './AbstractOverlay.js';\nimport {\n    BeforetoggleClosedEvent,\n    BeforetoggleOpenEvent,\n    OverlayStateEvent,\n} from './events.js';\nimport type { AbstractOverlay } from './AbstractOverlay.js';\nimport { userFocusableSelector } from '@spectrum-web-components/shared';\n\nconst supportsOverlayAuto = CSS.supports('(overlay: auto)');\n\nfunction isOpen(el: HTMLElement): boolean {\n    let popoverOpen = false;\n    try {\n        popoverOpen = el.matches(':popover-open');\n        // eslint-disable-next-line no-empty\n    } catch (error) {}\n    let open = false;\n    try {\n        open = el.matches(':open');\n        // eslint-disable-next-line no-empty\n    } catch (error) {}\n    return popoverOpen || open;\n}\n\nexport function OverlayPopover<T extends Constructor<AbstractOverlay>>(\n    constructor: T\n): T & Constructor<SpectrumElement> {\n    class OverlayWithPopover extends constructor {\n        protected override async manageDelay(\n            targetOpenState: boolean\n        ): Promise<void> {\n            if (targetOpenState === false || targetOpenState !== this.open) {\n                overlayTimer.close(this);\n                return;\n            }\n            if (this.delayed) {\n                const cancelled = await overlayTimer.openTimer(this);\n                if (cancelled) {\n                    this.open = !targetOpenState;\n                }\n            }\n        }\n\n        /**\n         * A popover should be hidden _after_ it is no longer on top-layer because\n         * the position metrics will have changed from when it was originally positioned.\n         */\n        private async shouldHidePopover(\n            targetOpenState: boolean\n        ): Promise<void> {\n            if (targetOpenState && this.open !== targetOpenState) {\n                return;\n            }\n            const update = async ({\n                newState,\n            }: { newState?: string } = {}): Promise<void> => {\n                if (newState === 'open') {\n                    return;\n                }\n                // When in a parent Overlay, this Overlay may need to position itself\n                // while closing in due to the parent _also_ closing which means the\n                // location can no longer rely on \"top layer over transform\" math.\n                await this.placementController.resetOverlayPosition();\n            };\n            if (!isOpen(this.dialogEl)) {\n                // The means the Overlay was closed from the outside, it is already off of top-layer\n                // so we need to position it in regards to this new state.\n                update();\n                return;\n            }\n            // `toggle` is an async event, so it's possible for this handler to run a frame late\n            this.dialogEl.addEventListener('toggle', update as EventListener, {\n                once: true,\n            });\n        }\n\n        private shouldShowPopover(targetOpenState: boolean): void {\n            let popoverOpen = false;\n            try {\n                popoverOpen = this.dialogEl.matches(':popover-open');\n                // eslint-disable-next-line no-empty\n            } catch (error) {}\n            let open = false;\n            try {\n                open = this.dialogEl.matches(':open');\n                // eslint-disable-next-line no-empty\n            } catch (error) {}\n            if (\n                targetOpenState &&\n                this.open === targetOpenState &&\n                !popoverOpen &&\n                !open &&\n                this.isConnected\n            ) {\n                this.dialogEl.showPopover();\n                this.managePosition();\n            }\n        }\n\n        protected override async ensureOnDOM(\n            targetOpenState: boolean\n        ): Promise<void> {\n            if (!supportsOverlayAuto) {\n                await this.shouldHidePopover(targetOpenState);\n            }\n            this.shouldShowPopover(targetOpenState);\n            await nextFrame();\n        }\n\n        protected override async makeTransition(\n            targetOpenState: boolean\n        ): Promise<HTMLElement | null> {\n            if (this.open !== targetOpenState) {\n                return null;\n            }\n            let focusEl = null as HTMLElement | null;\n            const start = (el: OpenableElement, index: number) => (): void => {\n                el.open = targetOpenState;\n                if (index === 0) {\n                    const event = targetOpenState\n                        ? BeforetoggleOpenEvent\n                        : BeforetoggleClosedEvent;\n                    this.dispatchEvent(new event());\n                }\n                if (!targetOpenState) {\n                    return;\n                }\n                if (el.matches(userFocusableSelector)) {\n                    focusEl = el;\n                }\n                focusEl = focusEl || firstFocusableIn(el);\n                if (focusEl) {\n                    return;\n                }\n                const childSlots = el.querySelectorAll('slot');\n                childSlots.forEach((slot) => {\n                    if (!focusEl) {\n                        focusEl = firstFocusableSlottedIn(slot);\n                    }\n                });\n            };\n            const finish =\n                (el: OpenableElement, index: number) =>\n                async (): Promise<void> => {\n                    if (this.open !== targetOpenState) {\n                        return;\n                    }\n                    const eventName = targetOpenState\n                        ? 'sp-opened'\n                        : 'sp-closed';\n                    if (index > 0) {\n                        el.dispatchEvent(\n                            new OverlayStateEvent(eventName, this, {\n                                interaction: this.type,\n                                publish: false,\n                            })\n                        );\n                        return;\n                    }\n                    const reportChange = async (): Promise<void> => {\n                        if (this.open !== targetOpenState) {\n                            return;\n                        }\n                        await nextFrame();\n                        const hasVirtualTrigger =\n                            this.triggerElement instanceof VirtualTrigger;\n                        this.dispatchEvent(\n                            new OverlayStateEvent(eventName, this, {\n                                interaction: this.type,\n                                publish: hasVirtualTrigger,\n                            })\n                        );\n                        el.dispatchEvent(\n                            new OverlayStateEvent(eventName, this, {\n                                interaction: this.type,\n                                publish: false,\n                            })\n                        );\n                        if (this.triggerElement && !hasVirtualTrigger) {\n                            (this.triggerElement as HTMLElement).dispatchEvent(\n                                new OverlayStateEvent(eventName, this, {\n                                    interaction: this.type,\n                                    publish: true,\n                                })\n                            );\n                        }\n                        this.state = targetOpenState ? 'opened' : 'closed';\n                        this.returnFocus();\n                        // Ensure layout and paint are done and the Overlay is still closed before removing the slottable request.\n                        await nextFrame();\n                        await nextFrame();\n                        if (\n                            targetOpenState === this.open &&\n                            targetOpenState === false\n                        ) {\n                            this.requestSlottable();\n                        }\n                    };\n                    if (this.open !== targetOpenState) {\n                        return;\n                    }\n                    const open = isOpen(this.dialogEl);\n                    if (targetOpenState !== true && open && this.isConnected) {\n                        this.dialogEl.addEventListener(\n                            'beforetoggle',\n                            () => {\n                                reportChange();\n                            },\n                            { once: true }\n                        );\n                        this.dialogEl.hidePopover();\n                    } else {\n                        reportChange();\n                    }\n                };\n            this.elements.forEach((el, index) => {\n                guaranteedAllTransitionend(\n                    el,\n                    start(el, index),\n                    finish(el, index)\n                );\n            });\n            return focusEl;\n        }\n    }\n    return OverlayWithPopover;\n}\n"],
  "mappings": "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",
  "names": ["firstFocusableIn", "firstFocusableSlottedIn", "VirtualTrigger", "guaranteedAllTransitionend", "nextFrame", "overlayTimer", "BeforetoggleClosedEvent", "BeforetoggleOpenEvent", "OverlayStateEvent", "userFocusableSelector", "supportsOverlayAuto", "isOpen", "el", "popoverOpen", "error", "open", "constructor", "OverlayWithPopover", "targetOpenState", "update", "newState", "focusEl", "start", "index", "event", "slot", "finish", "eventName", "reportChange", "hasVirtualTrigger"]
}
