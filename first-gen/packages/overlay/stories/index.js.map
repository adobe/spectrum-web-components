{
  "version": 3,
  "sources": ["index.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport { html, TemplateResult } from '@spectrum-web-components/base';\nimport type { Overlay } from '@spectrum-web-components/overlay';\n\nfunction nextFrame(): Promise<void> {\n    return new Promise((res) => requestAnimationFrame(() => res()));\n}\n\nclass IsOverlayOpen extends HTMLElement {\n    ready!: (value: boolean | PromiseLike<boolean>) => void;\n\n    constructor() {\n        super();\n        this.readyPromise = new Promise((res) => {\n            this.ready = res;\n            this.setup();\n        });\n    }\n\n    async setup(): Promise<void> {\n        await nextFrame();\n        document.addEventListener('sp-opened', this.handleOpened);\n    }\n\n    private sendFocus = async (): Promise<void> => {\n        const selectedItem = document\n            .querySelector('[focusable]')\n            ?.querySelector('[selected]') as HTMLElement & {\n            focused?: boolean;\n        };\n\n        if (selectedItem) {\n            selectedItem.focus();\n            selectedItem.focused = true;\n\n            // scroll the selected item into view with block start alignment to ensure consistent behavior in VRTs\n            await nextFrame();\n            selectedItem.scrollIntoView({ block: 'start' });\n            await nextFrame();\n        }\n    };\n\n    handleOpened = async (event: Event): Promise<void> => {\n        const overlay = event.target as Overlay;\n        const actions = [nextFrame(), overlay.updateComplete, this.sendFocus()];\n\n        await Promise.all(actions);\n        // Focus happens _after_ `sp-opened` by at least two frames.\n        await nextFrame();\n        await nextFrame();\n        await nextFrame();\n        await nextFrame();\n\n        this.ready(true);\n    };\n\n    private readyPromise: Promise<boolean> = Promise.resolve(false);\n\n    get updateComplete(): Promise<boolean> {\n        return this.readyPromise;\n    }\n\n    // remove event listeners in disconnectCallback\n    disconnectedCallback(): void {\n        document.removeEventListener('sp-opened', this.handleOpened);\n    }\n}\n\ncustomElements.define('is-overlay-open', IsOverlayOpen);\n\nexport const isOverlayOpen = (story: () => TemplateResult): TemplateResult => {\n    return html`\n        ${story()}\n        <is-overlay-open></is-overlay-open>\n    `;\n};\n\nclass AreIconsPresent extends HTMLElement {\n    ready!: (value: boolean | PromiseLike<boolean>) => void;\n\n    constructor() {\n        super();\n        this.readyPromise = new Promise((res) => {\n            this.ready = res;\n            this.setup();\n        });\n    }\n\n    async setup(): Promise<void> {\n        await nextFrame();\n        // First, wait for the overlay to open\n        document.addEventListener('sp-opened', this.handleOpened);\n    }\n\n    private overlayTimeout: ReturnType<typeof setTimeout> | null = null;\n\n    private sendFocus = async (): Promise<void> => {\n        const selectedItem = document\n            .querySelector('[focusable]')\n            ?.querySelector('[selected]') as HTMLElement & {\n            focused?: boolean;\n        };\n\n        if (selectedItem) {\n            selectedItem.focus();\n            selectedItem.focused = true;\n\n            // scroll the selected item into view with block start alignment to ensure consistent behavior in VRTs\n            await nextFrame();\n            selectedItem.scrollIntoView({ block: 'start' });\n            await nextFrame();\n        }\n    };\n\n    handleOpened = async (event: Event): Promise<void> => {\n        // Clear the timeout since overlay opened\n        if (this.overlayTimeout) {\n            clearTimeout(this.overlayTimeout);\n            this.overlayTimeout = null;\n        }\n\n        const overlay = event.target as Overlay;\n        const actions = [nextFrame(), overlay.updateComplete, this.sendFocus()];\n\n        await Promise.all(actions);\n        // Focus happens _after_ `sp-opened` by at least two frames.\n        await nextFrame();\n        await nextFrame();\n        await nextFrame();\n        await nextFrame();\n\n        this.checkIcons();\n    };\n\n    private checkIcons = async (): Promise<void> => {\n        const icons = [...document.querySelectorAll('sp-icon')];\n\n        // there is an icon inside the picker also\n        const picker = document.querySelector('sp-picker');\n        if (picker) {\n            const pickerIcon = picker.querySelector('sp-icon');\n            if (pickerIcon) {\n                icons.push(pickerIcon);\n            }\n        }\n\n        // Create an array of promises for each icon to load\n        const iconLoadPromises = Array.from(icons).map((icon) => {\n            return new Promise<void>((resolve) => {\n                // First check if the icon has an updateComplete promise we can use\n                if (\n                    'updateComplete' in icon &&\n                    typeof icon.updateComplete?.then === 'function'\n                ) {\n                    icon.updateComplete.then(() => {\n                        resolve();\n                    });\n                    return;\n                }\n\n                // Check if the icon has a src attribute\n                const src = icon.getAttribute('src');\n                if (!src) {\n                    // No src, check if it has an internal img element\n                    const imgElement = icon.querySelector('img');\n                    if (imgElement) {\n                        if (imgElement.complete) {\n                            // Image is already loaded\n                            resolve();\n                        } else {\n                            // Wait for the image to load\n                            imgElement.addEventListener(\n                                'load',\n                                () => {\n                                    resolve();\n                                },\n                                { once: true }\n                            );\n                            imgElement.addEventListener(\n                                'error',\n                                () => {\n                                    console.warn(`Failed to load icon image`);\n                                    resolve();\n                                },\n                                { once: true }\n                            );\n                        }\n                        return;\n                    }\n\n                    // No src and no img element, resolve immediately\n                    resolve();\n                    return;\n                }\n\n                // For icons with src attribute, check if there's an internal img element first\n                const imgElement = icon.querySelector('img');\n                if (imgElement) {\n                    if (imgElement.complete) {\n                        // Image is already loaded\n                        resolve();\n                    } else {\n                        // Wait for the image to load\n                        imgElement.addEventListener(\n                            'load',\n                            () => {\n                                resolve();\n                            },\n                            { once: true }\n                        );\n                        imgElement.addEventListener(\n                            'error',\n                            () => {\n                                console.warn(\n                                    `Failed to load icon image: ${src}`\n                                );\n                                resolve();\n                            },\n                            { once: true }\n                        );\n                    }\n                    return;\n                }\n\n                // Fallback to creating a new Image instance\n                const img = new Image();\n                img.onload = () => resolve();\n                img.onerror = () => {\n                    console.warn(`Failed to load icon: ${src}`);\n                    resolve();\n                };\n                img.src = src;\n            });\n        });\n\n        // Wait for all icons to load\n        await Promise.all(iconLoadPromises);\n        await nextFrame();\n\n        this.ready(true);\n    };\n\n    private readyPromise: Promise<boolean> = Promise.resolve(false);\n\n    get updateComplete(): Promise<boolean> {\n        return this.readyPromise;\n    }\n\n    // remove event listeners in disconnectCallback\n    disconnectedCallback(): void {\n        document.removeEventListener('sp-opened', this.handleOpened);\n    }\n}\n\ncustomElements.define('are-icons-present', AreIconsPresent);\n\nexport const areIconsPresent = (\n    story: () => TemplateResult\n): TemplateResult => {\n    return html`\n        ${story()}\n        <are-icons-present></are-icons-present>\n    `;\n};\n"],
  "mappings": ";AAYA,SAAS,YAA4B;AAGrC,SAAS,YAA2B;AAChC,SAAO,IAAI,QAAQ,CAAC,QAAQ,sBAAsB,MAAM,IAAI,CAAC,CAAC;AAClE;AAEA,MAAM,sBAAsB,YAAY;AAAA,EAGpC,cAAc;AACV,UAAM;AAYV,SAAQ,YAAY,YAA2B;AAnCnD;AAoCQ,YAAM,gBAAe,cAChB,cAAc,aAAa,MADX,mBAEf,cAAc;AAIpB,UAAI,cAAc;AACd,qBAAa,MAAM;AACnB,qBAAa,UAAU;AAGvB,cAAM,UAAU;AAChB,qBAAa,eAAe,EAAE,OAAO,QAAQ,CAAC;AAC9C,cAAM,UAAU;AAAA,MACpB;AAAA,IACJ;AAEA,wBAAe,OAAO,UAAgC;AAClD,YAAM,UAAU,MAAM;AACtB,YAAM,UAAU,CAAC,UAAU,GAAG,QAAQ,gBAAgB,KAAK,UAAU,CAAC;AAEtE,YAAM,QAAQ,IAAI,OAAO;AAEzB,YAAM,UAAU;AAChB,YAAM,UAAU;AAChB,YAAM,UAAU;AAChB,YAAM,UAAU;AAEhB,WAAK,MAAM,IAAI;AAAA,IACnB;AAEA,SAAQ,eAAiC,QAAQ,QAAQ,KAAK;AA3C1D,SAAK,eAAe,IAAI,QAAQ,CAAC,QAAQ;AACrC,WAAK,QAAQ;AACb,WAAK,MAAM;AAAA,IACf,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,QAAuB;AACzB,UAAM,UAAU;AAChB,aAAS,iBAAiB,aAAa,KAAK,YAAY;AAAA,EAC5D;AAAA,EAoCA,IAAI,iBAAmC;AACnC,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA,EAGA,uBAA6B;AACzB,aAAS,oBAAoB,aAAa,KAAK,YAAY;AAAA,EAC/D;AACJ;AAEA,eAAe,OAAO,mBAAmB,aAAa;AAE/C,aAAM,gBAAgB,CAAC,UAAgD;AAC1E,SAAO;AAAA,UACD,MAAM,CAAC;AAAA;AAAA;AAGjB;AAEA,MAAM,wBAAwB,YAAY;AAAA,EAGtC,cAAc;AACV,UAAM;AAaV,SAAQ,iBAAuD;AAE/D,SAAQ,YAAY,YAA2B;AA3GnD;AA4GQ,YAAM,gBAAe,cAChB,cAAc,aAAa,MADX,mBAEf,cAAc;AAIpB,UAAI,cAAc;AACd,qBAAa,MAAM;AACnB,qBAAa,UAAU;AAGvB,cAAM,UAAU;AAChB,qBAAa,eAAe,EAAE,OAAO,QAAQ,CAAC;AAC9C,cAAM,UAAU;AAAA,MACpB;AAAA,IACJ;AAEA,wBAAe,OAAO,UAAgC;AAElD,UAAI,KAAK,gBAAgB;AACrB,qBAAa,KAAK,cAAc;AAChC,aAAK,iBAAiB;AAAA,MAC1B;AAEA,YAAM,UAAU,MAAM;AACtB,YAAM,UAAU,CAAC,UAAU,GAAG,QAAQ,gBAAgB,KAAK,UAAU,CAAC;AAEtE,YAAM,QAAQ,IAAI,OAAO;AAEzB,YAAM,UAAU;AAChB,YAAM,UAAU;AAChB,YAAM,UAAU;AAChB,YAAM,UAAU;AAEhB,WAAK,WAAW;AAAA,IACpB;AAEA,SAAQ,aAAa,YAA2B;AAC5C,YAAM,QAAQ,CAAC,GAAG,SAAS,iBAAiB,SAAS,CAAC;AAGtD,YAAM,SAAS,SAAS,cAAc,WAAW;AACjD,UAAI,QAAQ;AACR,cAAM,aAAa,OAAO,cAAc,SAAS;AACjD,YAAI,YAAY;AACZ,gBAAM,KAAK,UAAU;AAAA,QACzB;AAAA,MACJ;AAGA,YAAM,mBAAmB,MAAM,KAAK,KAAK,EAAE,IAAI,CAAC,SAAS;AACrD,eAAO,IAAI,QAAc,CAAC,YAAY;AA/JlD;AAiKgB,cACI,oBAAoB,QACpB,SAAO,UAAK,mBAAL,mBAAqB,UAAS,YACvC;AACE,iBAAK,eAAe,KAAK,MAAM;AAC3B,sBAAQ;AAAA,YACZ,CAAC;AACD;AAAA,UACJ;AAGA,gBAAM,MAAM,KAAK,aAAa,KAAK;AACnC,cAAI,CAAC,KAAK;AAEN,kBAAMA,cAAa,KAAK,cAAc,KAAK;AAC3C,gBAAIA,aAAY;AACZ,kBAAIA,YAAW,UAAU;AAErB,wBAAQ;AAAA,cACZ,OAAO;AAEH,gBAAAA,YAAW;AAAA,kBACP;AAAA,kBACA,MAAM;AACF,4BAAQ;AAAA,kBACZ;AAAA,kBACA,EAAE,MAAM,KAAK;AAAA,gBACjB;AACA,gBAAAA,YAAW;AAAA,kBACP;AAAA,kBACA,MAAM;AACF,4BAAQ,KAAK,2BAA2B;AACxC,4BAAQ;AAAA,kBACZ;AAAA,kBACA,EAAE,MAAM,KAAK;AAAA,gBACjB;AAAA,cACJ;AACA;AAAA,YACJ;AAGA,oBAAQ;AACR;AAAA,UACJ;AAGA,gBAAM,aAAa,KAAK,cAAc,KAAK;AAC3C,cAAI,YAAY;AACZ,gBAAI,WAAW,UAAU;AAErB,sBAAQ;AAAA,YACZ,OAAO;AAEH,yBAAW;AAAA,gBACP;AAAA,gBACA,MAAM;AACF,0BAAQ;AAAA,gBACZ;AAAA,gBACA,EAAE,MAAM,KAAK;AAAA,cACjB;AACA,yBAAW;AAAA,gBACP;AAAA,gBACA,MAAM;AACF,0BAAQ;AAAA,oBACJ,8BAA8B,GAAG;AAAA,kBACrC;AACA,0BAAQ;AAAA,gBACZ;AAAA,gBACA,EAAE,MAAM,KAAK;AAAA,cACjB;AAAA,YACJ;AACA;AAAA,UACJ;AAGA,gBAAM,MAAM,IAAI,MAAM;AACtB,cAAI,SAAS,MAAM,QAAQ;AAC3B,cAAI,UAAU,MAAM;AAChB,oBAAQ,KAAK,wBAAwB,GAAG,EAAE;AAC1C,oBAAQ;AAAA,UACZ;AACA,cAAI,MAAM;AAAA,QACd,CAAC;AAAA,MACL,CAAC;AAGD,YAAM,QAAQ,IAAI,gBAAgB;AAClC,YAAM,UAAU;AAEhB,WAAK,MAAM,IAAI;AAAA,IACnB;AAEA,SAAQ,eAAiC,QAAQ,QAAQ,KAAK;AAhK1D,SAAK,eAAe,IAAI,QAAQ,CAAC,QAAQ;AACrC,WAAK,QAAQ;AACb,WAAK,MAAM;AAAA,IACf,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,QAAuB;AACzB,UAAM,UAAU;AAEhB,aAAS,iBAAiB,aAAa,KAAK,YAAY;AAAA,EAC5D;AAAA,EAwJA,IAAI,iBAAmC;AACnC,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA,EAGA,uBAA6B;AACzB,aAAS,oBAAoB,aAAa,KAAK,YAAY;AAAA,EAC/D;AACJ;AAEA,eAAe,OAAO,qBAAqB,eAAe;AAEnD,aAAM,kBAAkB,CAC3B,UACiB;AACjB,SAAO;AAAA,UACD,MAAM,CAAC;AAAA;AAAA;AAGjB;",
  "names": ["imgElement"]
}
