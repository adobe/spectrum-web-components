{
  "version": 3,
  "sources": ["Picker.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n    CSSResultArray,\n    DefaultElementSize,\n    html,\n    nothing,\n    PropertyValues,\n    render,\n    SizedMixin,\n    SpectrumElement,\n    TemplateResult,\n} from '@spectrum-web-components/base';\nimport {\n    classMap,\n    ifDefined,\n    StyleInfo,\n    styleMap,\n} from '@spectrum-web-components/base/src/directives.js';\nimport {\n    property,\n    query,\n    state,\n} from '@spectrum-web-components/base/src/decorators.js';\n\nimport pickerStyles from './picker.css.js';\nimport chevronStyles from '@spectrum-web-components/icon/src/spectrum-icon-chevron.css.js';\n\nimport type { Tooltip } from '@spectrum-web-components/tooltip';\nimport '@spectrum-web-components/icons-ui/icons/sp-icon-chevron100.js';\nimport '@spectrum-web-components/icons-workflow/icons/sp-icon-alert.js';\nimport '@spectrum-web-components/menu/sp-menu.js';\nimport type {\n    Menu,\n    MenuItem,\n    MenuItemChildren,\n} from '@spectrum-web-components/menu';\n\nimport type { MenuItemKeydownEvent } from '@spectrum-web-components/menu';\nimport { Placement } from '@spectrum-web-components/overlay';\nimport {\n    IS_MOBILE,\n    MatchMediaController,\n} from '@spectrum-web-components/reactive-controllers/src/MatchMedia.js';\nimport { DependencyManagerController } from '@spectrum-web-components/reactive-controllers/src/DependencyManger.js';\nimport { PendingStateController } from '@spectrum-web-components/reactive-controllers/src/PendingState.js';\nimport { Overlay } from '@spectrum-web-components/overlay/src/Overlay.js';\nimport type { SlottableRequestEvent } from '@spectrum-web-components/overlay/src/slottable-request-event.js';\nimport type { FieldLabel } from '@spectrum-web-components/field-label';\n\nimport { DesktopController } from './DesktopController.js';\nimport { MobileController } from './MobileController.js';\nimport { strategies } from './strategies.js';\n\nconst chevronClass = {\n    s: 'spectrum-UIIcon-ChevronDown75',\n    m: 'spectrum-UIIcon-ChevronDown100',\n    l: 'spectrum-UIIcon-ChevronDown200',\n    xl: 'spectrum-UIIcon-ChevronDown300',\n};\n\nexport const DESCRIPTION_ID = 'option-picker';\n\n/**\n * @element sp-picker\n * @slot label - The placeholder content for the Picker\n * @slot description - The description content for the Picker\n * @slot tooltip - Tooltip to to be applied to the the Picker Button\n * @slot - menu items to be listed in the Picker\n * @fires change - Announces that the `value` of the element has changed\n * @fires sp-opened - Announces that the overlay has been opened\n */\nexport class PickerBase extends SizedMixin(SpectrumElement, {\n    noDefaultSize: true,\n}) {\n    static override shadowRootOptions = {\n        ...SpectrumElement.shadowRootOptions,\n        delegatesFocus: true,\n    };\n\n    public isMobile = new MatchMediaController(this, IS_MOBILE);\n\n    public strategy!: DesktopController | MobileController;\n\n    @state()\n    appliedLabel?: string;\n\n    @query('#button')\n    public button!: HTMLButtonElement;\n\n    public dependencyManager = new DependencyManagerController(this);\n\n    private deprecatedMenu: Menu | null = null;\n\n    @property({ type: Boolean, reflect: true })\n    public disabled = false;\n\n    @property({ type: Boolean, reflect: true })\n    public focused = false;\n\n    @property({ type: String, reflect: true })\n    public icons?: 'only' | 'none';\n\n    @property({ type: Boolean, reflect: true })\n    public invalid = false;\n\n    /**\n     * Forces the Picker to render as a popover on mobile instead of a tray.\n     *\n     * @memberof PickerBase\n     */\n    @property({ type: Boolean, reflect: true, attribute: 'force-popover' })\n    public forcePopover = false;\n\n    /** Whether the items are currently loading. */\n    @property({ type: Boolean, reflect: true })\n    public pending = false;\n\n    /** Defines a string value that labels the Picker while it is in pending state. */\n    @property({ type: String, attribute: 'pending-label' })\n    public pendingLabel = 'Pending';\n\n    @property()\n    public label?: string;\n\n    @property({ type: Boolean, reflect: true })\n    public open = false;\n\n    @property({ type: Boolean, reflect: true })\n    public readonly = false;\n\n    public selects: undefined | 'single' = 'single';\n\n    @state()\n    public labelAlignment?: 'inline';\n\n    protected get menuItems(): MenuItem[] {\n        return this.optionsMenu.childItems;\n    }\n\n    @query('sp-menu')\n    public optionsMenu!: Menu;\n\n    /**\n     * @deprecated\n     * */\n    public get selfManageFocusElement(): boolean {\n        return true;\n    }\n\n    @query('sp-overlay')\n    public overlayElement!: Overlay;\n\n    protected tooltipEl?: Tooltip;\n\n    /**\n     * @type {\"top\" | \"top-start\" | \"top-end\" | \"right\" | \"right-start\" | \"right-end\" | \"bottom\" | \"bottom-start\" | \"bottom-end\" | \"left\" | \"left-start\" | \"left-end\"}\n     * @attr\n     */\n\n    @property()\n    public placement: Placement = 'bottom-start';\n\n    @property({ type: Boolean, reflect: true })\n    public quiet = false;\n\n    @property({ type: String })\n    public value = '';\n\n    @property({ attribute: false })\n    public get selectedItem(): MenuItem | undefined {\n        return this._selectedItem;\n    }\n\n    public pendingStateController: PendingStateController<this>;\n\n    /**\n     * Initializes the `PendingStateController` for the Picker component.\n     * The `PendingStateController` manages the pending state of the Picker.\n     */\n    constructor() {\n        super();\n        this.pendingStateController = new PendingStateController(this);\n    }\n\n    public set selectedItem(selectedItem: MenuItem | undefined) {\n        this.selectedItemContent = selectedItem\n            ? selectedItem.itemChildren\n            : undefined;\n\n        if (selectedItem === this.selectedItem) return;\n        const oldSelectedItem = this.selectedItem;\n        this._selectedItem = selectedItem;\n        this.requestUpdate('selectedItem', oldSelectedItem);\n    }\n\n    _selectedItem?: MenuItem;\n\n    protected listRole: 'listbox' | 'menu' = 'listbox';\n    protected itemRole = 'option';\n\n    public get focusElement(): HTMLElement {\n        if (this.open) {\n            return this.optionsMenu;\n        }\n        return this.button;\n    }\n\n    public forceFocusVisible(): void {\n        if (this.disabled) {\n            return;\n        }\n\n        this.focused = true;\n    }\n\n    // handled by interaction controller, desktop or mobile; this is only called with a programmatic this.click()\n    public override click(): void {\n        this.toggle();\n    }\n\n    // pointer events handled by interaction controller, desktop or mobile; this is only called with a programmatic this.button.click()\n    public handleButtonClick(): void {\n        if (this.disabled) {\n            return;\n        }\n        this.toggle();\n    }\n\n    public handleButtonBlur(): void {\n        this.focused = false;\n    }\n\n    public override focus(options?: FocusOptions): void {\n        this.focusElement?.focus(options);\n    }\n    /**\n     * @deprecated - Use `focus` instead.\n     */\n    public handleHelperFocus(): void {\n        // set focused to true here instead of handleButtonFocus so clicks don't flash a focus outline\n        this.focused = true;\n        this.button.focus();\n    }\n\n    public handleFocus(): void {\n        if (!this.disabled && this.focusElement) {\n            this.focused = this.hasVisibleFocusInTree();\n        }\n    }\n\n    public handleChange(event: Event): void {\n        if (this.strategy) {\n            this.strategy.preventNextToggle = 'no';\n        }\n        const target = event.target as Menu;\n        const [selected] = target.selectedItems;\n        event.stopPropagation();\n        if (event.cancelable) {\n            this.setValueFromItem(selected, event);\n        } else {\n            // Non-cancelable \"change\" events announce a selection with no value\n            // change that should close the Picker element.\n            this.open = false;\n            if (this.strategy) {\n                this.strategy.open = false;\n            }\n        }\n    }\n\n    public handleButtonFocus(event: FocusEvent): void {\n        this.strategy?.handleButtonFocus(event);\n    }\n\n    protected handleEscape = (\n        event: MenuItemKeydownEvent | KeyboardEvent\n    ): void => {\n        if (event.key === 'Escape') {\n            event.stopPropagation();\n            event.preventDefault();\n            this.toggle(false);\n        }\n    };\n\n    protected handleKeydown = (event: KeyboardEvent): void => {\n        this.focused = true;\n        if (\n            !['ArrowUp', 'ArrowDown', 'Enter', ' ', 'Escape'].includes(\n                event.key\n            )\n        ) {\n            return;\n        }\n        if (event.key === 'Escape') {\n            this.handleEscape(event);\n            return;\n        }\n        event.stopPropagation();\n        event.preventDefault();\n        this.keyboardOpen();\n    };\n\n    protected async keyboardOpen(): Promise<void> {\n        // if the menu is not open, we need to toggle it and wait for it to open to focus on the first selected item\n        if (!this.open || !this.strategy.open) {\n            this.addEventListener(\n                'sp-opened',\n                () => this.optionsMenu?.focusOnFirstSelectedItem(),\n                {\n                    once: true,\n                }\n            );\n            this.toggle(true);\n        } else {\n            // if the menu is already open, we need to focus on the first selected item\n            this.optionsMenu?.focusOnFirstSelectedItem();\n        }\n    }\n\n    protected async setValueFromItem(\n        item: MenuItem,\n        menuChangeEvent?: Event\n    ): Promise<void> {\n        this.open = false;\n        // should always close when \"setting\" a value\n        const oldSelectedItem = this.selectedItem;\n        const oldValue = this.value;\n\n        // Set a value.\n        this.selectedItem = item;\n        this.value = item?.value ?? '';\n        await this.updateComplete;\n        const applyDefault = this.dispatchEvent(\n            new Event('change', {\n                bubbles: true,\n                // Allow it to be prevented.\n                cancelable: true,\n                composed: true,\n            })\n        );\n        if (!applyDefault && this.selects) {\n            if (menuChangeEvent) {\n                menuChangeEvent.preventDefault();\n            }\n            this.setMenuItemSelected(this.selectedItem as MenuItem, false);\n            if (oldSelectedItem) {\n                this.setMenuItemSelected(oldSelectedItem, true);\n            }\n            this.selectedItem = oldSelectedItem;\n            this.value = oldValue;\n            this.open = true;\n            if (this.strategy) {\n                this.strategy.open = true;\n            }\n            return;\n        } else if (!this.selects) {\n            // Unset the value if not carrying a selection\n            this.selectedItem = oldSelectedItem;\n            this.value = oldValue;\n            return;\n        }\n        if (oldSelectedItem) {\n            this.setMenuItemSelected(oldSelectedItem, false);\n        }\n        this.setMenuItemSelected(item, !!this.selects);\n    }\n\n    protected setMenuItemSelected(item: MenuItem, value: boolean): void {\n        // matches null | undefined\n        if (this.selects == null) return;\n        item.selected = value;\n    }\n\n    public toggle(target?: boolean): void {\n        if (this.readonly || this.pending || this.disabled) {\n            return;\n        }\n        const open = typeof target !== 'undefined' ? target : !this.open;\n\n        this.open = open;\n        if (this.strategy) {\n            this.strategy.open = this.open;\n        }\n    }\n\n    public close(): void {\n        if (this.readonly) {\n            return;\n        }\n        if (this.strategy) {\n            this.open = false;\n            this.strategy.open = false;\n        }\n    }\n\n    protected get containerStyles(): StyleInfo {\n        // @todo: test in mobile\n        /* c8 ignore next 5 */\n        if (this.isMobile.matches) {\n            return {\n                '--swc-menu-width': '100%',\n            };\n        }\n        return {};\n    }\n\n    @state()\n    protected get selectedItemContent(): MenuItemChildren {\n        return this._selectedItemContent || { icon: [], content: [] };\n    }\n\n    protected set selectedItemContent(\n        selectedItemContent: MenuItemChildren | undefined\n    ) {\n        if (selectedItemContent === this.selectedItemContent) return;\n\n        const oldContent = this.selectedItemContent;\n        this._selectedItemContent = selectedItemContent;\n        this.requestUpdate('selectedItemContent', oldContent);\n    }\n\n    _selectedItemContent?: MenuItemChildren;\n\n    protected handleTooltipSlotchange(\n        event: Event & { target: HTMLSlotElement }\n    ): void {\n        this.tooltipEl = event.target.assignedElements()[0] as\n            | Tooltip\n            | undefined;\n    }\n\n    public handleSlottableRequest = (_event: SlottableRequestEvent): void => {};\n\n    protected renderLabelContent(content: Node[]): TemplateResult | Node[] {\n        if (this.value && this.selectedItem) {\n            return content;\n        }\n        return html`\n            <slot name=\"label\" id=\"label\">\n                <span\n                    aria-hidden=${ifDefined(\n                        this.appliedLabel ? undefined : 'true'\n                    )}\n                >\n                    ${this.label}\n                </span>\n            </slot>\n        `;\n    }\n\n    protected get buttonContent(): TemplateResult[] {\n        const labelClasses = {\n            'visually-hidden': this.icons === 'only' && !!this.value,\n            placeholder: !this.value,\n            label: true,\n        };\n        const appliedLabel = this.appliedLabel || this.label;\n        return [\n            html`\n                <span id=\"icon\" ?hidden=${this.icons === 'none'}>\n                    ${this.selectedItemContent.icon}\n                </span>\n                <span\n                    id=${ifDefined(\n                        this.value && this.selectedItem ? 'label' : undefined\n                    )}\n                    class=${classMap(labelClasses)}\n                >\n                    ${this.renderLabelContent(this.selectedItemContent.content)}\n                </span>\n                ${this.value && this.selectedItem\n                    ? html`\n                          <span\n                              aria-hidden=\"true\"\n                              class=\"visually-hidden\"\n                              id=\"applied-label\"\n                          >\n                              ${appliedLabel}\n                              <slot name=\"label\"></slot>\n                          </span>\n                      `\n                    : html`\n                          <span hidden id=\"applied-label\">${appliedLabel}</span>\n                      `}\n                ${this.invalid && !this.pending\n                    ? html`\n                          <sp-icon-alert\n                              class=\"validation-icon\"\n                          ></sp-icon-alert>\n                      `\n                    : nothing}\n                ${this.pendingStateController.renderPendingState()}\n                <sp-icon-chevron100\n                    class=\"picker ${chevronClass[\n                        this.size as DefaultElementSize\n                    ]}\"\n                ></sp-icon-chevron100>\n            `,\n        ];\n    }\n\n    applyFocusElementLabel = (\n        value: string,\n        labelElement: FieldLabel\n    ): void => {\n        this.appliedLabel = value;\n        this.labelAlignment = labelElement.sideAligned ? 'inline' : undefined;\n    };\n\n    protected hasAccessibleLabel(): boolean {\n        const slotContent =\n            this.querySelector('[slot=\"label\"]')?.textContent &&\n            this.querySelector('[slot=\"label\"]')?.textContent?.trim() !== '';\n        const slotAlt =\n            this.querySelector('[slot=\"label\"]')?.getAttribute('alt')?.trim() &&\n            this.querySelector('[slot=\"label\"]')\n                ?.getAttribute('alt')\n                ?.trim() !== '';\n        return (\n            !!this.label ||\n            !!this.getAttribute('aria-label') ||\n            !!this.getAttribute('aria-labelledby') ||\n            !!this.appliedLabel ||\n            !!slotContent ||\n            !!slotAlt\n        );\n    }\n\n    protected warnNoLabel(): void {\n        window.__swc.warn(\n            this,\n            `<${this.localName}> needs one of the following to be accessible:`,\n            'https://opensource.adobe.com/spectrum-web-components/components/picker/#accessibility',\n            {\n                type: 'accessibility',\n                issues: [\n                    `an <sp-field-label> element with a \\`for\\` attribute referencing the \\`id\\` of the \\`<${this.localName}>\\`, or`,\n                    'value supplied to the \"label\" attribute, which will be displayed visually as placeholder text, or',\n                    'text content supplied in a <span> with slot=\"label\", which will also be displayed visually as placeholder text.',\n                ],\n            }\n        );\n    }\n\n    protected renderOverlay(menu: TemplateResult): TemplateResult {\n        if (this.strategy?.overlay === undefined) {\n            return menu;\n        }\n        const container = this.renderContainer(menu);\n        render(container, this.strategy?.overlay as unknown as HTMLElement, {\n            host: this,\n        });\n        return this.strategy?.overlay as unknown as TemplateResult;\n    }\n\n    protected get renderDescriptionSlot(): TemplateResult {\n        return html`\n            <div id=${DESCRIPTION_ID}>\n                <slot name=\"description\"></slot>\n            </div>\n        `;\n    }\n    // a helper to throw focus to the button is needed because Safari\n    // won't include buttons in the tab order even with tabindex=\"0\"\n    protected override render(): TemplateResult {\n        if (this.tooltipEl) {\n            this.tooltipEl.disabled = this.open;\n        }\n        return html`\n            <button\n                aria-controls=${ifDefined(this.open ? 'menu' : undefined)}\n                aria-describedby=\"tooltip ${DESCRIPTION_ID}\"\n                aria-expanded=${this.open ? 'true' : 'false'}\n                aria-haspopup=\"true\"\n                aria-labelledby=\"loader icon label applied-label\"\n                id=\"button\"\n                class=${ifDefined(\n                    this.labelAlignment\n                        ? `label-${this.labelAlignment}`\n                        : undefined\n                )}\n                @focus=${this.handleButtonFocus}\n                @blur=${this.handleButtonBlur}\n                @keydown=${{\n                    handleEvent: this.handleEnterKeydown,\n                    capture: true,\n                }}\n                ?disabled=${this.disabled}\n            >\n                ${this.buttonContent}\n            </button>\n            <slot\n                aria-hidden=\"true\"\n                name=\"tooltip\"\n                id=\"tooltip\"\n                @keydown=${this.handleKeydown}\n                @slotchange=${this.handleTooltipSlotchange}\n            ></slot>\n            ${this.renderMenu} ${this.renderDescriptionSlot}\n        `;\n    }\n\n    protected override willUpdate(changes: PropertyValues<this>): void {\n        super.willUpdate(changes);\n        if (changes.has('tabIndex') && !!this.tabIndex) {\n            this.button.tabIndex = this.tabIndex;\n            this.removeAttribute('tabindex');\n        }\n    }\n\n    protected override update(changes: PropertyValues<this>): void {\n        if (this.selects) {\n            /**\n             * Always force `selects` to \"single\" when set.\n             *\n             * @todo: Add support functionally and visually for \"multiple\"\n             */\n            this.selects = 'single';\n        }\n        if (changes.has('disabled') && this.disabled) {\n            this.close();\n        }\n        if (changes.has('pending') && this.pending) {\n            this.close();\n        }\n        if (changes.has('value')) {\n            // MenuItems update a frame late for <slot> management,\n            // await the same here.\n            this.shouldScheduleManageSelection();\n        }\n        // Maybe it's finally time to remove this support?s\n        if (!this.hasUpdated) {\n            this.deprecatedMenu = this.querySelector(':scope > sp-menu');\n            this.deprecatedMenu?.toggleAttribute('ignore', true);\n            this.deprecatedMenu?.setAttribute('selects', 'inherit');\n        }\n        if (window.__swc.DEBUG) {\n            if (!this.hasUpdated && this.querySelector(':scope > sp-menu')) {\n                const { localName } = this;\n                window.__swc.warn(\n                    this,\n                    `You no longer need to provide an <sp-menu> child to ${localName}. Any styling or attributes on the <sp-menu> will be ignored.`,\n                    'https://opensource.adobe.com/spectrum-web-components/components/picker/#sizes',\n                    { level: 'deprecation' }\n                );\n            }\n            this.updateComplete.then(async () => {\n                // Attributes should be user supplied, making them available before first update.\n                // However, `appliesLabel` is applied by external elements that must be update complete as well to be bound appropriately.\n                await new Promise((res) => requestAnimationFrame(res));\n                await new Promise((res) => requestAnimationFrame(res));\n                if (!this.hasAccessibleLabel()) {\n                    this.warnNoLabel();\n                }\n            });\n        }\n        super.update(changes);\n    }\n\n    protected bindButtonKeydownListener(): void {\n        this.button.addEventListener('keydown', this.handleKeydown);\n    }\n\n    protected override updated(changes: PropertyValues<this>): void {\n        super.updated(changes);\n        if (changes.has('open')) {\n            this.strategy.open = this.open;\n        }\n    }\n\n    protected override firstUpdated(changes: PropertyValues<this>): void {\n        super.firstUpdated(changes);\n        this.bindButtonKeydownListener();\n        this.bindEvents();\n    }\n\n    protected get dismissHelper(): TemplateResult {\n        return html`\n            <div class=\"visually-hidden\">\n                <button\n                    tabindex=\"-1\"\n                    aria-label=\"Dismiss\"\n                    @click=${this.close}\n                ></button>\n            </div>\n        `;\n    }\n\n    protected renderContainer(menu: TemplateResult): TemplateResult {\n        const accessibleMenu = html`\n            ${this.dismissHelper} ${menu} ${this.dismissHelper}\n        `;\n        // @todo: test in mobile\n        if (this.isMobile.matches && !this.forcePopover) {\n            this.dependencyManager.add('sp-tray');\n            import('@spectrum-web-components/tray/sp-tray.js');\n            return html`\n                <sp-tray\n                    id=\"popover\"\n                    role=\"presentation\"\n                    style=${styleMap(this.containerStyles)}\n                >\n                    ${accessibleMenu}\n                </sp-tray>\n            `;\n        }\n        this.dependencyManager.add('sp-popover');\n        import('@spectrum-web-components/popover/sp-popover.js');\n        return html`\n            <sp-popover\n                id=\"popover\"\n                role=\"presentation\"\n                style=${styleMap(this.containerStyles)}\n                placement=${this.placement}\n            >\n                ${accessibleMenu}\n            </sp-popover>\n        `;\n    }\n\n    protected hasRenderedOverlay = false;\n\n    private onScroll(): void {\n        this.dispatchEvent(\n            new Event('scroll', {\n                cancelable: true,\n                composed: true,\n            })\n        );\n    }\n\n    protected get renderMenu(): TemplateResult {\n        const menu = html`\n            <sp-menu\n                aria-labelledby=\"applied-label\"\n                @change=${this.handleChange}\n                id=\"menu\"\n                @keydown=${{\n                    handleEvent: this.handleEnterKeydown,\n                    capture: true,\n                }}\n                @scroll=${this.onScroll}\n                role=${this.listRole}\n                .selects=${this.selects}\n                .selected=${this.value ? [this.value] : []}\n                size=${this.size}\n                @sp-menu-item-keydown=${this.handleEscape}\n                @sp-menu-item-added-or-updated=${this.shouldManageSelection}\n            >\n                <slot @slotchange=${this.shouldScheduleManageSelection}></slot>\n            </sp-menu>\n        `;\n        this.hasRenderedOverlay =\n            this.hasRenderedOverlay ||\n            this.focused ||\n            this.open ||\n            !!this.deprecatedMenu;\n        if (this.hasRenderedOverlay) {\n            if (this.dependencyManager.loaded) {\n                this.dependencyManager.add('sp-overlay');\n            }\n            return this.renderOverlay(menu);\n        }\n        return menu;\n    }\n\n    /**\n     * whether a selection change is already scheduled\n     */\n    public willManageSelection = false;\n\n    /**\n     * when the value changes or the menu slot changes, manage the selection on the next frame, if not already scheduled\n     * @param event\n     */\n    protected shouldScheduleManageSelection(event?: Event): void {\n        if (\n            !this.willManageSelection &&\n            (!event ||\n                ((event.target as HTMLElement).getRootNode() as ShadowRoot)\n                    .host === this)\n        ) {\n            //s set a flag to manage selection on the next frame\n            this.willManageSelection = true;\n            requestAnimationFrame(() => {\n                requestAnimationFrame(() => {\n                    this.manageSelection();\n                });\n            });\n        }\n    }\n\n    /**\n     * when an item is added or updated, manage the selection, if it's not already scheduled\n     */\n    protected shouldManageSelection(): void {\n        if (this.willManageSelection) {\n            return;\n        }\n        this.willManageSelection = true;\n        this.manageSelection();\n    }\n\n    /**\n     * updates menu selection based on value\n     */\n    protected async manageSelection(): Promise<void> {\n        if (this.selects == null) return;\n\n        this.selectionPromise = new Promise(\n            (res) => (this.selectionResolver = res)\n        );\n        let selectedItem: MenuItem | undefined;\n        await this.optionsMenu.updateComplete;\n        if (this.recentlyConnected) {\n            // Work around for attach timing differences in Safari and Firefox.\n            // Remove when refactoring to Menu passthrough wrapper.\n            await new Promise((res) => requestAnimationFrame(() => res(true)));\n            this.recentlyConnected = false;\n        }\n        this.menuItems.forEach((item) => {\n            if (this.value === item.value && !item.disabled) {\n                selectedItem = item;\n            } else {\n                item.selected = false;\n            }\n        });\n        if (selectedItem) {\n            selectedItem.selected = !!this.selects;\n            this.selectedItem = selectedItem;\n        } else {\n            this.value = '';\n            this.selectedItem = undefined;\n        }\n        if (this.open) {\n            await this.optionsMenu.updateComplete;\n            this.optionsMenu.updateSelectedItemIndex();\n        }\n        this.selectionResolver();\n        this.willManageSelection = false;\n    }\n\n    private selectionPromise = Promise.resolve();\n    private selectionResolver!: () => void;\n\n    protected override async getUpdateComplete(): Promise<boolean> {\n        const complete = (await super.getUpdateComplete()) as boolean;\n        await this.selectionPromise;\n        // if (this.overlayElement) {\n        //     await this.overlayElement.updateComplete;\n        // }\n        return complete;\n    }\n\n    private recentlyConnected = false;\n\n    private enterKeydownOn: EventTarget | null = null;\n\n    protected handleEnterKeydown = (event: KeyboardEvent): void => {\n        if (event.key !== 'Enter') {\n            return;\n        }\n        const target = event?.target as MenuItem;\n        if (!target.open && target.hasSubmenu) {\n            event.preventDefault();\n            return;\n        }\n\n        if (this.enterKeydownOn) {\n            event.preventDefault();\n            return;\n        }\n        this.enterKeydownOn = event.target;\n        this.addEventListener(\n            'keyup',\n            async (keyupEvent: KeyboardEvent) => {\n                if (keyupEvent.key !== 'Enter') {\n                    return;\n                }\n                this.enterKeydownOn = null;\n            },\n            { once: true }\n        );\n    };\n\n    public bindEvents(): void {\n        this.strategy?.abort();\n        if (this.isMobile.matches) {\n            this.strategy = new strategies['mobile'](this.button, this);\n        } else {\n            this.strategy = new strategies['desktop'](this.button, this);\n        }\n    }\n\n    public override connectedCallback(): void {\n        super.connectedCallback();\n        this.updateComplete.then(() => {\n            if (!this.tooltipEl?.selfManaged) {\n                return;\n            }\n            const overlayElement = this.tooltipEl.overlayElement;\n            if (overlayElement) {\n                overlayElement.triggerElement = this.button;\n            }\n        });\n\n        this.recentlyConnected = this.hasUpdated;\n        this.addEventListener('focus', this.handleFocus);\n    }\n\n    public override disconnectedCallback(): void {\n        this.close();\n        this.strategy?.releaseDescription();\n        super.disconnectedCallback();\n    }\n}\n\n/**\n * @element sp-picker\n *\n * @slot label - The placeholder content for the Picker\n * @slot description - The description content for the Picker\n * @slot tooltip - Tooltip to to be applied to the the Picker Button\n * @slot - menu items to be listed in the Picker\n * @fires change - Announces that the `value` of the element has changed\n * @fires sp-opened - Announces that the overlay has been opened\n * @fires sp-closed - Announces that the overlay has been closed\n */\nexport class Picker extends PickerBase {\n    public static override get styles(): CSSResultArray {\n        return [pickerStyles, chevronStyles];\n    }\n\n    protected override get containerStyles(): StyleInfo {\n        const styles = super.containerStyles;\n        if (!this.quiet) {\n            styles['min-width'] = `${this.offsetWidth}px`;\n        }\n        return styles;\n    }\n\n    protected override handleKeydown = (event: KeyboardEvent): void => {\n        const { key } = event;\n        const handledKeys = [\n            'ArrowUp',\n            'ArrowDown',\n            'ArrowLeft',\n            'ArrowRight',\n            'Enter',\n            ' ',\n            'Escape',\n        ].includes(key);\n        const openKeys = ['ArrowUp', 'ArrowDown', 'Enter', ' '].includes(key);\n        this.focused = true;\n        if ('Escape' === key) {\n            this.handleEscape(event);\n            return;\n        }\n        if (!handledKeys || this.readonly || this.pending) {\n            return;\n        }\n        if (openKeys) {\n            this.keyboardOpen();\n            event.preventDefault();\n            return;\n        }\n        event.preventDefault();\n        const nextItem = this.optionsMenu?.getNeighboringFocusableElement(\n            this.selectedItem,\n            key === 'ArrowLeft'\n        );\n        if (!this.value || nextItem !== this.selectedItem) {\n            // updates picker text but does not fire change event until action is completed\n            if (!!nextItem) this.setValueFromItem(nextItem as MenuItem);\n        }\n    };\n}\n"],
  "mappings": "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",
  "names": ["html", "nothing", "render", "SizedMixin", "SpectrumElement", "classMap", "ifDefined", "styleMap", "property", "query", "state", "pickerStyles", "chevronStyles", "IS_MOBILE", "MatchMediaController", "DependencyManagerController", "PendingStateController", "strategies", "chevronClass", "event", "_event", "value", "labelElement", "target", "keyupEvent", "selectedItem", "oldSelectedItem", "options", "_a", "selected", "item", "menuChangeEvent", "oldValue", "open", "selectedItemContent", "oldContent", "content", "labelClasses", "appliedLabel", "_b", "_c", "_d", "_e", "_f", "_g", "slotContent", "slotAlt", "menu", "container", "changes", "accessibleMenu", "res", "complete", "overlayElement", "__decorateClass", "key", "handledKeys", "openKeys", "nextItem", "styles"]
}
