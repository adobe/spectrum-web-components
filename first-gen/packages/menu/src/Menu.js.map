{
  "version": 3,
  "sources": ["Menu.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n    CSSResultArray,\n    html,\n    PropertyValues,\n    SizedMixin,\n    SpectrumElement,\n    TemplateResult,\n} from '@spectrum-web-components/base';\nimport {\n    property,\n    query,\n} from '@spectrum-web-components/base/src/decorators.js';\n\nimport { MenuItem } from './MenuItem.js';\nimport type {\n    MenuItemAddedOrUpdatedEvent,\n    MenuItemKeydownEvent,\n} from './MenuItem.js';\nimport type { Overlay } from '@spectrum-web-components/overlay';\nimport menuStyles from './menu.css.js';\nimport { RovingTabindexController } from '@spectrum-web-components/reactive-controllers/src/RovingTabindex.js';\n\nexport interface MenuChildItem {\n    menuItem: MenuItem;\n    managed: boolean;\n    active: boolean;\n    focusable: boolean;\n    focusRoot: Menu;\n}\n\ntype SelectsType = 'none' | 'ignore' | 'inherit' | 'multiple' | 'single';\ntype RoleType = 'group' | 'menu' | 'listbox' | 'none';\n\n/**\n * Spectrum Menu Component\n * @element sp-menu\n *\n * @slot - menu items to be listed in the menu\n * @fires change - Announces that the `value` of the element has changed\n * @attr selects - whether the element has a specific selection algorithm that it applies\n *   to its item descendants. `single` allows only one descendent to be selected at a time.\n *   `multiple` allows many descendants to be selected. `inherit` will be applied dynamically\n *   when an ancestor of this element is actively managing the selection of its descendents.\n *   When the `selects` attribute is not present a `value` will not be maintained and the Menu\n *   Item children of this Menu will not have their `selected` state managed.\n */\nexport class Menu extends SizedMixin(SpectrumElement, { noDefaultSize: true }) {\n    public static override get styles(): CSSResultArray {\n        return [menuStyles];\n    }\n\n    static override shadowRootOptions = {\n        ...SpectrumElement.shadowRootOptions,\n        delegatesFocus: true,\n    };\n\n    private get isSubmenu(): boolean {\n        return this.slot === 'submenu';\n    }\n\n    protected rovingTabindexController?: RovingTabindexController<MenuItem>;\n\n    /**\n     * label of the menu\n     */\n    @property({ type: String, reflect: true })\n    public label = '';\n\n    /**\n     * whether menu should be ignored by roving tabindex controller\n     */\n    @property({ type: Boolean, reflect: true })\n    public ignore = false;\n\n    /**\n     * how the menu allows selection of its items:\n     * - `undefined` (default): no selection is allowed\n     * - `\"inherit\"`: the selection behavior is managed from an ancestor\n     * - `\"single\"`: only one item can be selected at a time\n     *  - `\"multiple\"`: multiple items can be selected\n     */\n    @property({ type: String, reflect: true })\n    public selects: undefined | 'inherit' | 'single' | 'multiple';\n\n    /**\n     * value of the selected item(s)\n     */\n    @property({ type: String })\n    public value = '';\n\n    // For the multiple select case, we'll join the value strings together\n    // for the value property with this separator\n    @property({ type: String, attribute: 'value-separator' })\n    public valueSeparator = ',';\n\n    /**\n     * selected items values as string\n     */\n    @property({ attribute: false })\n    public get selected(): string[] {\n        return !this.selects ? [] : this._selected;\n    }\n\n    public set selected(selected: string[]) {\n        if (selected === this.selected) {\n            return;\n        }\n        const old = this.selected;\n        this._selected = selected;\n        this.selectedItems = [];\n        this.selectedItemsMap.clear();\n        this.childItems.forEach((item) => {\n            if (this !== item.menuData.selectionRoot) {\n                return;\n            }\n            item.selected = this.selected.includes(item.value);\n            if (item.selected) {\n                this.selectedItems.push(item);\n                this.selectedItemsMap.set(item, true);\n            }\n        });\n        this.requestUpdate('selected', old);\n    }\n\n    protected _selected = [] as string[];\n\n    /**\n     * array of selected menu items\n     */\n    @property({ attribute: false })\n    public selectedItems = [] as MenuItem[];\n\n    @query('slot:not([name])')\n    public menuSlot!: HTMLSlotElement;\n\n    private childItemSet = new Set<MenuItem>();\n    public focusedItemIndex = 0;\n    public focusInItemIndex = 0;\n\n    /**\n     * Whether to support the pointerdown-drag-pointerup selection strategy.\n     * Defaults to false to prevent click/touch events from being captured\n     * behind the menu tray in mobile environments (since the menu closes\n     * immediately on pointerup).\n     */\n\n    public shouldSupportDragAndSelect = false;\n\n    public get focusInItem(): MenuItem | undefined {\n        return this.rovingTabindexController?.focusInElement;\n    }\n\n    protected get controlsRovingTabindex(): boolean {\n        return true;\n    }\n\n    private selectedItemsMap = new Map<MenuItem, boolean>();\n\n    /**\n     * child items managed by menu\n     */\n    public get childItems(): MenuItem[] {\n        if (!this.cachedChildItems) {\n            this.cachedChildItems = this.updateCachedMenuItems();\n        }\n        return this.cachedChildItems;\n    }\n\n    private cachedChildItems: MenuItem[] | undefined;\n\n    private updateCachedMenuItems(): MenuItem[] {\n        if (!this.menuSlot) {\n            return [];\n        }\n        const itemsList = [];\n        const slottedElements = this.menuSlot.assignedElements({\n            flatten: true,\n        }) as HTMLElement[];\n        // Recursively flatten <slot> and non-<sp-menu-item> elements assigned to the menu into a single array.\n        for (const [i, slottedElement] of slottedElements.entries()) {\n            if (this.childItemSet.has(slottedElement as MenuItem)) {\n                // Assign <sp-menu-item> members of the array that are in this.childItemSet to this.chachedChildItems.\n                itemsList.push(slottedElement as MenuItem);\n                continue;\n            }\n            const isHTMLSlotElement = slottedElement.localName === 'slot';\n            const flattenedChildren = isHTMLSlotElement\n                ? (slottedElement as HTMLSlotElement).assignedElements({\n                      flatten: true,\n                  })\n                : [...slottedElement.querySelectorAll(`:scope > *`)];\n            slottedElements.splice(\n                i,\n                1,\n                slottedElement,\n                ...(flattenedChildren as HTMLElement[])\n            );\n        }\n\n        this.cachedChildItems = [...itemsList];\n        this.rovingTabindexController?.clearElementCache();\n\n        return this.cachedChildItems;\n    }\n\n    /**\n     * Hide this getter from web-component-analyzer until\n     * https://github.com/runem/web-component-analyzer/issues/131\n     * has been addressed.\n     *\n     * @private\n     */\n    public get childRole(): string {\n        if (this.resolvedRole === 'listbox') {\n            return 'option';\n        }\n        switch (this.resolvedSelects) {\n            case 'single':\n                return 'menuitemradio';\n            case 'multiple':\n                return 'menuitemcheckbox';\n            default:\n                return 'menuitem';\n        }\n    }\n\n    protected get ownRole(): string {\n        return 'menu';\n    }\n\n    /**\n     * menuitem role based on selection type\n     */\n    private resolvedSelects?: SelectsType;\n\n    /**\n     * menu role based on selection type\n     */\n    private resolvedRole?: RoleType;\n\n    /**\n     * When a descendant `<sp-menu-item>` element is added or updated it will dispatch\n     * this event to announce its presence in the DOM. During the CAPTURE phase the first\n     * Menu based element that the event encounters will manage the focus state of the\n     * dispatching `<sp-menu-item>` element.\n     * @param event\n     */\n    private onFocusableItemAddedOrUpdated(\n        event: MenuItemAddedOrUpdatedEvent\n    ): void {\n        event.menuCascade.set(this, {\n            hadFocusRoot: !!event.item.menuData.focusRoot,\n            ancestorWithSelects: event.currentAncestorWithSelects,\n        });\n        if (this.selects) {\n            event.currentAncestorWithSelects = this;\n        }\n        event.item.menuData.focusRoot = event.item.menuData.focusRoot || this;\n    }\n\n    /**\n     * When a descendant `<sp-menu-item>` element is added or updated it will dispatch\n     * this event to announce its presence in the DOM. During the BUBBLE phase the first\n     * Menu based element that the event encounters that does not inherit selection will\n     * manage the selection state of the dispatching `<sp-menu-item>` element.\n     * @param event\n     */\n    private onSelectableItemAddedOrUpdated(\n        event: MenuItemAddedOrUpdatedEvent\n    ): void {\n        const cascadeData = event.menuCascade.get(this);\n        /* c8 ignore next 1 */\n        if (!cascadeData) return;\n\n        event.item.menuData.parentMenu = event.item.menuData.parentMenu || this;\n        this.addChildItem(event.item);\n\n        if (this.selects === 'inherit') {\n            this.resolvedSelects = 'inherit';\n            const ignoreMenu = event.currentAncestorWithSelects?.ignore;\n            this.resolvedRole = ignoreMenu\n                ? 'none'\n                : ((event.currentAncestorWithSelects?.getAttribute('role') ||\n                      this.getAttribute('role') ||\n                      undefined) as RoleType);\n        } else if (this.selects) {\n            this.resolvedRole = this.ignore\n                ? 'none'\n                : ((this.getAttribute('role') || undefined) as RoleType);\n            this.resolvedSelects = this.selects;\n        } else {\n            this.resolvedRole = this.ignore\n                ? 'none'\n                : ((this.getAttribute('role') || undefined) as RoleType);\n            this.resolvedSelects =\n                this.resolvedRole === 'none' ? 'ignore' : 'none';\n        }\n\n        if (this.resolvedRole === 'none') {\n            return;\n        }\n\n        const selects =\n            this.resolvedSelects === 'single' ||\n            this.resolvedSelects === 'multiple';\n        event.item.menuData.cleanupSteps.push((item: MenuItem) =>\n            this.removeChildItem(item)\n        );\n        if (\n            (selects || (!this.selects && this.resolvedSelects !== 'ignore')) &&\n            !event.item.menuData.selectionRoot\n        ) {\n            event.item.setRole(this.childRole);\n            event.item.menuData.selectionRoot =\n                event.item.menuData.selectionRoot || this;\n            if (event.item.selected) {\n                this.selectedItemsMap.set(event.item, true);\n                this.selectedItems = [...this.selectedItems, event.item];\n                this._selected = [...this.selected, event.item.value];\n                this.value = this.selected.join(this.valueSeparator);\n            }\n        }\n    }\n\n    private addChildItem(item: MenuItem): void {\n        this.childItemSet.add(item);\n        this.handleItemsChanged();\n    }\n\n    private async removeChildItem(item: MenuItem): Promise<void> {\n        if (item.focused || item.hasAttribute('focused') || item.active) {\n            this._updateFocus = this.getNeighboringFocusableElement(item);\n        }\n        this.childItemSet.delete(item);\n        this.cachedChildItems = undefined;\n    }\n\n    public constructor() {\n        super();\n\n        /**\n         * only create an RTI if menu controls keyboard navigation and one does not already exist\n         */\n        if (!this.rovingTabindexController && this.controlsRovingTabindex) {\n            this.rovingTabindexController =\n                new RovingTabindexController<MenuItem>(this, {\n                    direction: 'vertical',\n                    focusInIndex: (elements: MenuItem[] | undefined) => {\n                        let firstEnabledIndex = -1;\n                        const firstSelectedIndex = elements?.findIndex(\n                            (el, index) => {\n                                if (\n                                    !elements[firstEnabledIndex] &&\n                                    !el.disabled\n                                ) {\n                                    firstEnabledIndex = index;\n                                }\n                                return el.selected && !el.disabled;\n                            }\n                        );\n                        return elements &&\n                            firstSelectedIndex &&\n                            elements[firstSelectedIndex]\n                            ? firstSelectedIndex\n                            : firstEnabledIndex;\n                    },\n                    elements: () => this.childItems,\n                    isFocusableElement: this.isFocusableElement.bind(this),\n                    hostDelegatesFocus: true,\n                });\n        }\n\n        this.addEventListener(\n            'sp-menu-item-added-or-updated',\n            this.onSelectableItemAddedOrUpdated\n        );\n        this.addEventListener(\n            'sp-menu-item-added-or-updated',\n            this.onFocusableItemAddedOrUpdated,\n            {\n                capture: true,\n            }\n        );\n        this.addEventListener('click', this.handleClick);\n        this.addEventListener('touchend', this.handlePointerup);\n        this.addEventListener('focusout', this.handleFocusout);\n        this.addEventListener('sp-menu-item-keydown', this.handleKeydown);\n        this.addEventListener('pointerup', this.handlePointerup);\n        this.addEventListener('sp-opened', this.handleSubmenuOpened);\n        this.addEventListener('sp-closed', this.handleSubmenuClosed);\n    }\n\n    /**\n     * for picker elements, will set focus on first selected item\n     */\n    public focusOnFirstSelectedItem({\n        preventScroll,\n    }: FocusOptions = {}): void {\n        if (!this.rovingTabindexController) return;\n        const selectedItem = this.selectedItems.find((el) =>\n            this.isFocusableElement(el)\n        );\n        if (!selectedItem) {\n            this.focus({ preventScroll });\n            return;\n        }\n\n        if (selectedItem && !preventScroll) {\n            selectedItem.scrollIntoView({ block: 'nearest' });\n        }\n        this.rovingTabindexController?.focusOnItem(selectedItem);\n    }\n\n    public override focus({ preventScroll }: FocusOptions = {}): void {\n        if (this.rovingTabindexController) {\n            if (\n                !this.childItems.length ||\n                this.childItems.every((childItem) => childItem.disabled)\n            ) {\n                return;\n            }\n            if (\n                this.childItems.some(\n                    (childItem) => childItem.menuData.focusRoot !== this\n                )\n            ) {\n                super.focus({ preventScroll });\n                return;\n            }\n            this.rovingTabindexController.focus({ preventScroll });\n        }\n    }\n\n    // if the click and pointerup events are on the same target, we should not\n    // handle the click event.\n    private pointerUpTarget = null as EventTarget | null;\n\n    private handleFocusout(): void {\n        if (!this.matches(':focus-within'))\n            this.rovingTabindexController?.reset();\n    }\n\n    private handleClick(event: Event): void {\n        if (this.pointerUpTarget === event.target) {\n            this.pointerUpTarget = null;\n            return;\n        }\n        this.handlePointerBasedSelection(event);\n    }\n\n    private handlePointerup(event: Event): void {\n        /*\n         * early return if drag and select is not supported\n         * in this case, selection will be handled by the click event\n         */\n        if (!this.shouldSupportDragAndSelect) {\n            return;\n        }\n        this.pointerUpTarget = event.target;\n        this.handlePointerBasedSelection(event);\n    }\n\n    private async handlePointerBasedSelection(event: Event): Promise<void> {\n        // Only handle left clicks\n        if (event instanceof MouseEvent && event.button !== 0) {\n            return;\n        }\n\n        const path = event.composedPath();\n        const target = path.find((el) => {\n            /* c8 ignore next 3 */\n            if (!(el instanceof Element)) {\n                return false;\n            }\n            return el.getAttribute('role') === this.childRole;\n        }) as MenuItem;\n        if (event.defaultPrevented) {\n            const index = this.childItems.indexOf(target);\n            if (target?.menuData?.focusRoot === this && index > -1) {\n                this.focusedItemIndex = index;\n            }\n            return;\n        }\n        if (target?.href && target.href.length) {\n            // This event will NOT ALLOW CANCELATION as link action\n            // cancelation should occur on the `<sp-menu-item>` itself.\n            this.dispatchEvent(\n                new Event('change', {\n                    bubbles: true,\n                    composed: true,\n                })\n            );\n            return;\n        } else if (\n            target?.menuData?.selectionRoot === this &&\n            this.childItems.length\n        ) {\n            event.preventDefault();\n            if (target.hasSubmenu || target.open) {\n                return;\n            }\n            this.selectOrToggleItem(target);\n        } else {\n            return;\n        }\n        this.prepareToCleanUp();\n    }\n\n    private descendentOverlays = new Map<Overlay, Overlay>();\n\n    protected handleDescendentOverlayOpened(event: Event): void {\n        const target = event.composedPath()[0] as MenuItem;\n        /* c8 ignore next 1 */\n        if (!target.overlayElement) return;\n        this.descendentOverlays.set(\n            target.overlayElement,\n            target.overlayElement\n        );\n    }\n\n    protected handleDescendentOverlayClosed(event: Event): void {\n        const target = event.composedPath()[0] as MenuItem;\n        /* c8 ignore next 1 */\n        if (!target.overlayElement) return;\n        this.descendentOverlays.delete(target.overlayElement);\n    }\n\n    public handleSubmenuClosed = (event: Event): void => {\n        event.stopPropagation();\n        const target = event.composedPath()[0] as Overlay;\n        target.dispatchEvent(\n            new Event('sp-menu-submenu-closed', {\n                bubbles: true,\n                composed: true,\n            })\n        );\n    };\n\n    /**\n     * given a menu item, returns the next focusable menu item before or after it;\n     * if no menu item is provided, returns the first focusable menu item\n     * @param menuItem {MenuItem}\n     * @param before {boolean} return the item before; default is false\n     * @returns {MenuItem}\n     */\n    public getNeighboringFocusableElement(\n        menuItem?: MenuItem,\n        before = false\n    ): MenuItem {\n        const diff = before ? -1 : 1;\n        const elements = this.rovingTabindexController?.elements || [];\n        const index = !!menuItem ? elements.indexOf(menuItem) : -1;\n        let newIndex = Math.min(Math.max(0, index + diff), elements.length - 1);\n        while (\n            !this.isFocusableElement(elements[newIndex]) &&\n            0 < newIndex &&\n            newIndex < elements.length - 1\n        ) {\n            newIndex += diff;\n        }\n        return !!this.isFocusableElement(elements[newIndex])\n            ? (elements[newIndex] as MenuItem)\n            : menuItem || elements[0];\n    }\n\n    public handleSubmenuOpened = (event: Event): void => {\n        event.stopPropagation();\n        const target = event.composedPath()[0] as Overlay;\n        target.dispatchEvent(\n            new Event('sp-menu-submenu-opened', {\n                bubbles: true,\n                composed: true,\n            })\n        );\n\n        const openedItem = event\n            .composedPath()\n            .find((el) => this.childItemSet.has(el as MenuItem));\n        /* c8 ignore next 1 */\n        if (!openedItem) return;\n    };\n\n    public async selectOrToggleItem(targetItem: MenuItem): Promise<void> {\n        const resolvedSelects = this.resolvedSelects;\n        const oldSelectedItemsMap = new Map(this.selectedItemsMap);\n        const oldSelected = this.selected.slice();\n        const oldSelectedItems = this.selectedItems.slice();\n        const oldValue = this.value;\n\n        if (targetItem.menuData.selectionRoot !== this) {\n            return;\n        }\n\n        if (resolvedSelects === 'multiple') {\n            if (this.selectedItemsMap.has(targetItem)) {\n                this.selectedItemsMap.delete(targetItem);\n            } else {\n                this.selectedItemsMap.set(targetItem, true);\n            }\n\n            // Match HTML select and set the first selected\n            // item as the value. Also set the selected array\n            // in the order of the menu items.\n            const selected: string[] = [];\n            const selectedItems: MenuItem[] = [];\n\n            this.childItemSet.forEach((childItem) => {\n                if (childItem.menuData.selectionRoot !== this) return;\n\n                if (this.selectedItemsMap.has(childItem)) {\n                    selected.push(childItem.value);\n                    selectedItems.push(childItem);\n                }\n            });\n            this._selected = selected;\n            this.selectedItems = selectedItems;\n            this.value = this.selected.join(this.valueSeparator);\n        } else {\n            this.selectedItemsMap.clear();\n            this.selectedItemsMap.set(targetItem, true);\n            this.value = targetItem.value;\n            this._selected = [targetItem.value];\n            this.selectedItems = [targetItem];\n        }\n\n        const applyDefault = this.dispatchEvent(\n            new Event('change', {\n                cancelable: true,\n                bubbles: true,\n                composed: true,\n            })\n        );\n\n        if (!applyDefault) {\n            // Cancel the event & don't apply the selection\n            this._selected = oldSelected;\n            this.selectedItems = oldSelectedItems;\n            this.selectedItemsMap = oldSelectedItemsMap;\n            this.value = oldValue;\n            return;\n        }\n        // Apply the selection changes to the menu items\n        if (resolvedSelects === 'single') {\n            for (const oldItem of oldSelectedItemsMap.keys()) {\n                if (oldItem !== targetItem) {\n                    oldItem.selected = false;\n                }\n            }\n            targetItem.selected = true;\n        } else if (resolvedSelects === 'multiple') {\n            targetItem.selected = !targetItem.selected;\n        } else if (\n            !targetItem.hasSubmenu &&\n            targetItem?.menuData?.focusRoot === this\n        ) {\n            this.dispatchEvent(new Event('close', { bubbles: true }));\n        }\n    }\n\n    protected navigateBetweenRelatedMenus(event: MenuItemKeydownEvent): void {\n        const { key, root } = event;\n        const shouldOpenSubmenu =\n            (this.isLTR && key === 'ArrowRight') ||\n            (!this.isLTR && key === 'ArrowLeft');\n        const shouldCloseSelfAsSubmenu =\n            (this.isLTR && key === 'ArrowLeft') ||\n            (!this.isLTR && key === 'ArrowRight') ||\n            key === 'Escape';\n        const lastFocusedItem = root as MenuItem;\n        if (shouldOpenSubmenu) {\n            if (lastFocusedItem?.hasSubmenu) {\n                //open submenu and set focus\n                event.stopPropagation();\n                lastFocusedItem.openOverlay(true);\n            }\n        } else if (shouldCloseSelfAsSubmenu && this.isSubmenu) {\n            event.stopPropagation();\n            this.dispatchEvent(new Event('close', { bubbles: true }));\n            this.updateSelectedItemIndex();\n        }\n    }\n\n    public handleKeydown(event: Event): void {\n        if (event.defaultPrevented || !this.rovingTabindexController) {\n            return;\n        }\n        const { key, root, shiftKey, target } = event as MenuItemKeydownEvent;\n        const openSubmenuKey = ['Enter', ' '].includes(key);\n        if (shiftKey && target !== this && this.hasAttribute('tabindex')) {\n            this.removeAttribute('tabindex');\n            const replaceTabindex = (\n                event: FocusEvent | KeyboardEvent\n            ): void => {\n                if (\n                    !(event as KeyboardEvent).shiftKey &&\n                    !this.hasAttribute('tabindex')\n                ) {\n                    document.removeEventListener('keyup', replaceTabindex);\n                    this.removeEventListener('focusout', replaceTabindex);\n                }\n            };\n            document.addEventListener('keyup', replaceTabindex);\n            this.addEventListener('focusout', replaceTabindex);\n        }\n        if (key === 'Tab') {\n            this.closeDescendentOverlays();\n            return;\n        }\n        if (openSubmenuKey && root?.hasSubmenu && !root.open) {\n            // Remove focus while opening overlay from keyboard or the visible focus\n            // will slip back to the first item in the menu.\n            event.preventDefault();\n            root.openOverlay(true);\n            return;\n        }\n        if (key === ' ' || key === 'Enter') {\n            event.preventDefault();\n            root?.focusElement?.click();\n            if (root) this.selectOrToggleItem(root);\n            return;\n        }\n        this.navigateBetweenRelatedMenus(event as MenuItemKeydownEvent);\n    }\n\n    private _hasUpdatedSelectedItemIndex = false;\n\n    /**\n     * on focus, removes focus from focus styling item, and updates the selected item index\n     */\n    private prepareToCleanUp(): void {\n        document.addEventListener(\n            'focusout',\n            () => {\n                requestAnimationFrame(() => {\n                    const focusedItem = this.focusInItem;\n                    if (focusedItem) {\n                        focusedItem.focused = false;\n                    }\n                });\n            },\n            { once: true }\n        );\n    }\n\n    public updateSelectedItemIndex(): void {\n        let firstOrFirstSelectedIndex = 0;\n        const selectedItemsMap = new Map<MenuItem, boolean>();\n        const selected: string[] = [];\n        const selectedItems: MenuItem[] = [];\n        let itemIndex = this.childItems.length;\n        while (itemIndex) {\n            itemIndex -= 1;\n            const childItem = this.childItems[itemIndex];\n            if (childItem.menuData.selectionRoot === this) {\n                if (\n                    childItem.selected ||\n                    (!this._hasUpdatedSelectedItemIndex &&\n                        this.selected.includes(childItem.value))\n                ) {\n                    firstOrFirstSelectedIndex = itemIndex;\n                    selectedItemsMap.set(childItem, true);\n                    selected.unshift(childItem.value);\n                    selectedItems.unshift(childItem);\n                }\n                // Remove \"focused\" from non-\"selected\" items ONLY\n                // Preserve \"focused\" on index===0 when no selection\n                if (itemIndex !== firstOrFirstSelectedIndex) {\n                    childItem.focused = false;\n                }\n            }\n        }\n\n        this.selectedItemsMap = selectedItemsMap;\n        this._selected = selected;\n        this.selectedItems = selectedItems;\n        this.value = this.selected.join(this.valueSeparator);\n        this.focusedItemIndex = firstOrFirstSelectedIndex;\n        this.focusInItemIndex = firstOrFirstSelectedIndex;\n    }\n\n    private _willUpdateItems = false;\n    private _updateFocus?: MenuItem;\n\n    private handleItemsChanged(): void {\n        this.cachedChildItems = undefined;\n        if (!this._willUpdateItems) {\n            this._willUpdateItems = true;\n            this.cacheUpdated = this.updateCache();\n        }\n    }\n\n    private async updateCache(): Promise<void> {\n        if (!this.hasUpdated) {\n            await Promise.all([\n                new Promise((res) => requestAnimationFrame(() => res(true))),\n                this.updateComplete,\n            ]);\n        } else {\n            await new Promise((res) => requestAnimationFrame(() => res(true)));\n        }\n        if (this.cachedChildItems === undefined) {\n            this.updateSelectedItemIndex();\n            this.updateItemFocus();\n        }\n\n        this._willUpdateItems = false;\n    }\n\n    private updateItemFocus(): void {\n        this.focusInItem?.setAttribute('tabindex', '0');\n        if (this.childItems.length == 0) {\n            return;\n        }\n    }\n\n    public closeDescendentOverlays(): void {\n        this.descendentOverlays.forEach((overlay) => {\n            overlay.open = false;\n        });\n        this.descendentOverlays = new Map<Overlay, Overlay>();\n    }\n\n    private handleSlotchange({\n        target,\n    }: Event & { target: HTMLSlotElement }): void {\n        const assignedElements = target.assignedElements({\n            flatten: true,\n        }) as MenuItem[];\n        if (this.childItems.length !== assignedElements.length) {\n            assignedElements.forEach((item) => {\n                if (typeof item.triggerUpdate !== 'undefined') {\n                    item.triggerUpdate();\n                } else if (\n                    typeof (item as unknown as Menu).childItems !== 'undefined'\n                ) {\n                    (item as unknown as Menu).childItems.forEach((child) => {\n                        child.triggerUpdate();\n                    });\n                }\n            });\n        }\n        if (!!this._updateFocus) {\n            this.rovingTabindexController?.focusOnItem(this._updateFocus);\n            this._updateFocus = undefined;\n        }\n    }\n\n    protected renderMenuItemSlot(): TemplateResult {\n        return html`\n            <slot\n                @sp-menu-submenu-opened=${this.handleDescendentOverlayOpened}\n                @sp-menu-submenu-closed=${this.handleDescendentOverlayClosed}\n                @slotchange=${this.handleSlotchange}\n            ></slot>\n        `;\n    }\n\n    public override render(): TemplateResult {\n        return this.renderMenuItemSlot();\n    }\n\n    protected override firstUpdated(changed: PropertyValues): void {\n        super.firstUpdated(changed);\n        const updates: Promise<unknown>[] = [\n            new Promise((res) => requestAnimationFrame(() => res(true))),\n        ];\n        [...this.children].forEach((item) => {\n            if ((item as MenuItem).localName === 'sp-menu-item') {\n                updates.push((item as MenuItem).updateComplete);\n            }\n        });\n        this.childItemsUpdated = Promise.all(updates);\n    }\n\n    protected override updated(changes: PropertyValues<this>): void {\n        super.updated(changes);\n        if (changes.has('selects') && this.hasUpdated) {\n            this.selectsChanged();\n        }\n        if (\n            changes.has('label') &&\n            (this.label || typeof changes.get('label') !== 'undefined')\n        ) {\n            if (this.label) {\n                this.setAttribute('aria-label', this.label);\n                /* c8 ignore next 3 */\n            } else {\n                this.removeAttribute('aria-label');\n            }\n        }\n    }\n\n    protected selectsChanged(): void {\n        const updates: Promise<unknown>[] = [\n            new Promise((res) => requestAnimationFrame(() => res(true))),\n        ];\n        this.childItemSet.forEach((childItem) => {\n            updates.push(childItem.triggerUpdate());\n        });\n        this.childItemsUpdated = Promise.all(updates);\n    }\n\n    public override connectedCallback(): void {\n        super.connectedCallback();\n        if (!this.hasAttribute('role') && !this.ignore) {\n            this.setAttribute('role', this.ownRole);\n        }\n        this.updateComplete.then(() => this.updateItemFocus());\n    }\n\n    private isFocusableElement(el: MenuItem): boolean {\n        return el ? !el.disabled : false;\n    }\n\n    public override disconnectedCallback(): void {\n        this.cachedChildItems = undefined;\n        this.selectedItems = [];\n        this.selectedItemsMap.clear();\n        this.childItemSet.clear();\n        this.descendentOverlays = new Map<Overlay, Overlay>();\n        super.disconnectedCallback();\n    }\n\n    protected childItemsUpdated!: Promise<unknown[]>;\n    protected cacheUpdated = Promise.resolve();\n    /* c8 ignore next 3 */\n    protected resolveCacheUpdated = (): void => {\n        return;\n    };\n\n    protected override async getUpdateComplete(): Promise<boolean> {\n        const complete = (await super.getUpdateComplete()) as boolean;\n        await this.childItemsUpdated;\n        await this.cacheUpdated;\n        return complete;\n    }\n}\n"],
  "mappings": "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",
  "names": ["html", "SizedMixin", "SpectrumElement", "property", "query", "menuStyles", "RovingTabindexController", "event", "el", "elements", "firstEnabledIndex", "firstSelectedIndex", "index", "selected", "old", "item", "_a", "itemsList", "slottedElements", "slottedElement", "flattenedChildren", "_b", "ignoreMenu", "selects", "preventScroll", "selectedItem", "childItem", "target", "menuItem", "before", "diff", "newIndex", "targetItem", "resolvedSelects", "oldSelectedItemsMap", "oldSelected", "oldSelectedItems", "oldValue", "selectedItems", "oldItem", "key", "root", "shouldOpenSubmenu", "shouldCloseSelfAsSubmenu", "lastFocusedItem", "shiftKey", "openSubmenuKey", "replaceTabindex", "focusedItem", "firstOrFirstSelectedIndex", "selectedItemsMap", "itemIndex", "res", "overlay", "assignedElements", "child", "changed", "updates", "changes", "complete", "__decorateClass"]
}
