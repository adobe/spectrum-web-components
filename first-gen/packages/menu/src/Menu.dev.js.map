{
  "version": 3,
  "sources": ["Menu.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n    CSSResultArray,\n    html,\n    PropertyValues,\n    SizedMixin,\n    SpectrumElement,\n    TemplateResult,\n} from '@spectrum-web-components/base';\nimport {\n    property,\n    query,\n} from '@spectrum-web-components/base/src/decorators.js';\n\nimport { MenuItem } from './MenuItem.dev.js'\nimport type {\n    MenuItemAddedOrUpdatedEvent,\n    MenuItemKeydownEvent,\n} from './MenuItem.dev.js'\nimport type { Overlay } from '@spectrum-web-components/overlay';\nimport menuStyles from './menu.css.js';\nimport { RovingTabindexController } from '@spectrum-web-components/reactive-controllers/src/RovingTabindex.js';\n\nexport interface MenuChildItem {\n    menuItem: MenuItem;\n    managed: boolean;\n    active: boolean;\n    focusable: boolean;\n    focusRoot: Menu;\n}\n\ntype SelectsType = 'none' | 'ignore' | 'inherit' | 'multiple' | 'single';\ntype RoleType = 'group' | 'menu' | 'listbox' | 'none';\n\n/**\n * Spectrum Menu Component\n * @element sp-menu\n *\n * @slot - menu items to be listed in the menu\n * @fires change - Announces that the `value` of the element has changed\n * @attr selects - whether the element has a specific selection algorithm that it applies\n *   to its item descendants. `single` allows only one descendent to be selected at a time.\n *   `multiple` allows many descendants to be selected. `inherit` will be applied dynamically\n *   when an ancestor of this element is actively managing the selection of its descendents.\n *   When the `selects` attribute is not present a `value` will not be maintained and the Menu\n *   Item children of this Menu will not have their `selected` state managed.\n */\nexport class Menu extends SizedMixin(SpectrumElement, { noDefaultSize: true }) {\n    public static override get styles(): CSSResultArray {\n        return [menuStyles];\n    }\n\n    static override shadowRootOptions = {\n        ...SpectrumElement.shadowRootOptions,\n        delegatesFocus: true,\n    };\n\n    private get isSubmenu(): boolean {\n        return this.slot === 'submenu';\n    }\n\n    protected rovingTabindexController?: RovingTabindexController<MenuItem>;\n\n    /**\n     * label of the menu\n     */\n    @property({ type: String, reflect: true })\n    public label = '';\n\n    /**\n     * whether menu should be ignored by roving tabindex controller\n     */\n    @property({ type: Boolean, reflect: true })\n    public ignore = false;\n\n    /**\n     * how the menu allows selection of its items:\n     * - `undefined` (default): no selection is allowed\n     * - `\"inherit\"`: the selection behavior is managed from an ancestor\n     * - `\"single\"`: only one item can be selected at a time\n     *  - `\"multiple\"`: multiple items can be selected\n     */\n    @property({ type: String, reflect: true })\n    public selects: undefined | 'inherit' | 'single' | 'multiple';\n\n    /**\n     * value of the selected item(s)\n     */\n    @property({ type: String })\n    public value = '';\n\n    // For the multiple select case, we'll join the value strings together\n    // for the value property with this separator\n    @property({ type: String, attribute: 'value-separator' })\n    public valueSeparator = ',';\n\n    /**\n     * selected items values as string\n     */\n    @property({ attribute: false })\n    public get selected(): string[] {\n        return !this.selects ? [] : this._selected;\n    }\n\n    public set selected(selected: string[]) {\n        if (selected === this.selected) {\n            return;\n        }\n        const old = this.selected;\n        this._selected = selected;\n        this.selectedItems = [];\n        this.selectedItemsMap.clear();\n        this.childItems.forEach((item) => {\n            if (this !== item.menuData.selectionRoot) {\n                return;\n            }\n            item.selected = this.selected.includes(item.value);\n            if (item.selected) {\n                this.selectedItems.push(item);\n                this.selectedItemsMap.set(item, true);\n            }\n        });\n        this.requestUpdate('selected', old);\n    }\n\n    protected _selected = [] as string[];\n\n    /**\n     * array of selected menu items\n     */\n    @property({ attribute: false })\n    public selectedItems = [] as MenuItem[];\n\n    @query('slot:not([name])')\n    public menuSlot!: HTMLSlotElement;\n\n    private childItemSet = new Set<MenuItem>();\n    public focusedItemIndex = 0;\n    public focusInItemIndex = 0;\n\n    /**\n     * Whether to support the pointerdown-drag-pointerup selection strategy.\n     * Defaults to false to prevent click/touch events from being captured\n     * behind the menu tray in mobile environments (since the menu closes\n     * immediately on pointerup).\n     */\n\n    public shouldSupportDragAndSelect = false;\n\n    public get focusInItem(): MenuItem | undefined {\n        return this.rovingTabindexController?.focusInElement;\n    }\n\n    protected get controlsRovingTabindex(): boolean {\n        return true;\n    }\n\n    private selectedItemsMap = new Map<MenuItem, boolean>();\n\n    /**\n     * child items managed by menu\n     */\n    public get childItems(): MenuItem[] {\n        if (!this.cachedChildItems) {\n            this.cachedChildItems = this.updateCachedMenuItems();\n        }\n        return this.cachedChildItems;\n    }\n\n    private cachedChildItems: MenuItem[] | undefined;\n\n    private updateCachedMenuItems(): MenuItem[] {\n        if (!this.menuSlot) {\n            return [];\n        }\n        const itemsList = [];\n        const slottedElements = this.menuSlot.assignedElements({\n            flatten: true,\n        }) as HTMLElement[];\n        // Recursively flatten <slot> and non-<sp-menu-item> elements assigned to the menu into a single array.\n        for (const [i, slottedElement] of slottedElements.entries()) {\n            if (this.childItemSet.has(slottedElement as MenuItem)) {\n                // Assign <sp-menu-item> members of the array that are in this.childItemSet to this.chachedChildItems.\n                itemsList.push(slottedElement as MenuItem);\n                continue;\n            }\n            const isHTMLSlotElement = slottedElement.localName === 'slot';\n            const flattenedChildren = isHTMLSlotElement\n                ? (slottedElement as HTMLSlotElement).assignedElements({\n                      flatten: true,\n                  })\n                : [...slottedElement.querySelectorAll(`:scope > *`)];\n            slottedElements.splice(\n                i,\n                1,\n                slottedElement,\n                ...(flattenedChildren as HTMLElement[])\n            );\n        }\n\n        this.cachedChildItems = [...itemsList];\n        this.rovingTabindexController?.clearElementCache();\n\n        return this.cachedChildItems;\n    }\n\n    /**\n     * Hide this getter from web-component-analyzer until\n     * https://github.com/runem/web-component-analyzer/issues/131\n     * has been addressed.\n     *\n     * @private\n     */\n    public get childRole(): string {\n        if (this.resolvedRole === 'listbox') {\n            return 'option';\n        }\n        switch (this.resolvedSelects) {\n            case 'single':\n                return 'menuitemradio';\n            case 'multiple':\n                return 'menuitemcheckbox';\n            default:\n                return 'menuitem';\n        }\n    }\n\n    protected get ownRole(): string {\n        return 'menu';\n    }\n\n    /**\n     * menuitem role based on selection type\n     */\n    private resolvedSelects?: SelectsType;\n\n    /**\n     * menu role based on selection type\n     */\n    private resolvedRole?: RoleType;\n\n    /**\n     * When a descendant `<sp-menu-item>` element is added or updated it will dispatch\n     * this event to announce its presence in the DOM. During the CAPTURE phase the first\n     * Menu based element that the event encounters will manage the focus state of the\n     * dispatching `<sp-menu-item>` element.\n     * @param event\n     */\n    private onFocusableItemAddedOrUpdated(\n        event: MenuItemAddedOrUpdatedEvent\n    ): void {\n        event.menuCascade.set(this, {\n            hadFocusRoot: !!event.item.menuData.focusRoot,\n            ancestorWithSelects: event.currentAncestorWithSelects,\n        });\n        if (this.selects) {\n            event.currentAncestorWithSelects = this;\n        }\n        event.item.menuData.focusRoot = event.item.menuData.focusRoot || this;\n    }\n\n    /**\n     * When a descendant `<sp-menu-item>` element is added or updated it will dispatch\n     * this event to announce its presence in the DOM. During the BUBBLE phase the first\n     * Menu based element that the event encounters that does not inherit selection will\n     * manage the selection state of the dispatching `<sp-menu-item>` element.\n     * @param event\n     */\n    private onSelectableItemAddedOrUpdated(\n        event: MenuItemAddedOrUpdatedEvent\n    ): void {\n        const cascadeData = event.menuCascade.get(this);\n        /* c8 ignore next 1 */\n        if (!cascadeData) return;\n\n        event.item.menuData.parentMenu = event.item.menuData.parentMenu || this;\n        this.addChildItem(event.item);\n\n        if (this.selects === 'inherit') {\n            this.resolvedSelects = 'inherit';\n            const ignoreMenu = event.currentAncestorWithSelects?.ignore;\n            this.resolvedRole = ignoreMenu\n                ? 'none'\n                : ((event.currentAncestorWithSelects?.getAttribute('role') ||\n                      this.getAttribute('role') ||\n                      undefined) as RoleType);\n        } else if (this.selects) {\n            this.resolvedRole = this.ignore\n                ? 'none'\n                : ((this.getAttribute('role') || undefined) as RoleType);\n            this.resolvedSelects = this.selects;\n        } else {\n            this.resolvedRole = this.ignore\n                ? 'none'\n                : ((this.getAttribute('role') || undefined) as RoleType);\n            this.resolvedSelects =\n                this.resolvedRole === 'none' ? 'ignore' : 'none';\n        }\n\n        if (this.resolvedRole === 'none') {\n            return;\n        }\n\n        const selects =\n            this.resolvedSelects === 'single' ||\n            this.resolvedSelects === 'multiple';\n        event.item.menuData.cleanupSteps.push((item: MenuItem) =>\n            this.removeChildItem(item)\n        );\n        if (\n            (selects || (!this.selects && this.resolvedSelects !== 'ignore')) &&\n            !event.item.menuData.selectionRoot\n        ) {\n            event.item.setRole(this.childRole);\n            event.item.menuData.selectionRoot =\n                event.item.menuData.selectionRoot || this;\n            if (event.item.selected) {\n                this.selectedItemsMap.set(event.item, true);\n                this.selectedItems = [...this.selectedItems, event.item];\n                this._selected = [...this.selected, event.item.value];\n                this.value = this.selected.join(this.valueSeparator);\n            }\n        }\n    }\n\n    private addChildItem(item: MenuItem): void {\n        this.childItemSet.add(item);\n        this.handleItemsChanged();\n    }\n\n    private async removeChildItem(item: MenuItem): Promise<void> {\n        if (item.focused || item.hasAttribute('focused') || item.active) {\n            this._updateFocus = this.getNeighboringFocusableElement(item);\n        }\n        this.childItemSet.delete(item);\n        this.cachedChildItems = undefined;\n    }\n\n    public constructor() {\n        super();\n\n        /**\n         * only create an RTI if menu controls keyboard navigation and one does not already exist\n         */\n        if (!this.rovingTabindexController && this.controlsRovingTabindex) {\n            this.rovingTabindexController =\n                new RovingTabindexController<MenuItem>(this, {\n                    direction: 'vertical',\n                    focusInIndex: (elements: MenuItem[] | undefined) => {\n                        let firstEnabledIndex = -1;\n                        const firstSelectedIndex = elements?.findIndex(\n                            (el, index) => {\n                                if (\n                                    !elements[firstEnabledIndex] &&\n                                    !el.disabled\n                                ) {\n                                    firstEnabledIndex = index;\n                                }\n                                return el.selected && !el.disabled;\n                            }\n                        );\n                        return elements &&\n                            firstSelectedIndex &&\n                            elements[firstSelectedIndex]\n                            ? firstSelectedIndex\n                            : firstEnabledIndex;\n                    },\n                    elements: () => this.childItems,\n                    isFocusableElement: this.isFocusableElement.bind(this),\n                    hostDelegatesFocus: true,\n                });\n        }\n\n        this.addEventListener(\n            'sp-menu-item-added-or-updated',\n            this.onSelectableItemAddedOrUpdated\n        );\n        this.addEventListener(\n            'sp-menu-item-added-or-updated',\n            this.onFocusableItemAddedOrUpdated,\n            {\n                capture: true,\n            }\n        );\n        this.addEventListener('click', this.handleClick);\n        this.addEventListener('touchend', this.handlePointerup);\n        this.addEventListener('focusout', this.handleFocusout);\n        this.addEventListener('sp-menu-item-keydown', this.handleKeydown);\n        this.addEventListener('pointerup', this.handlePointerup);\n        this.addEventListener('sp-opened', this.handleSubmenuOpened);\n        this.addEventListener('sp-closed', this.handleSubmenuClosed);\n    }\n\n    /**\n     * for picker elements, will set focus on first selected item\n     */\n    public focusOnFirstSelectedItem({\n        preventScroll,\n    }: FocusOptions = {}): void {\n        if (!this.rovingTabindexController) return;\n        const selectedItem = this.selectedItems.find((el) =>\n            this.isFocusableElement(el)\n        );\n        if (!selectedItem) {\n            this.focus({ preventScroll });\n            return;\n        }\n\n        if (selectedItem && !preventScroll) {\n            selectedItem.scrollIntoView({ block: 'nearest' });\n        }\n        this.rovingTabindexController?.focusOnItem(selectedItem);\n    }\n\n    public override focus({ preventScroll }: FocusOptions = {}): void {\n        if (this.rovingTabindexController) {\n            if (\n                !this.childItems.length ||\n                this.childItems.every((childItem) => childItem.disabled)\n            ) {\n                return;\n            }\n            if (\n                this.childItems.some(\n                    (childItem) => childItem.menuData.focusRoot !== this\n                )\n            ) {\n                super.focus({ preventScroll });\n                return;\n            }\n            this.rovingTabindexController.focus({ preventScroll });\n        }\n    }\n\n    // if the click and pointerup events are on the same target, we should not\n    // handle the click event.\n    private pointerUpTarget = null as EventTarget | null;\n\n    private handleFocusout(): void {\n        if (!this.matches(':focus-within'))\n            this.rovingTabindexController?.reset();\n    }\n\n    private handleClick(event: Event): void {\n        if (this.pointerUpTarget === event.target) {\n            this.pointerUpTarget = null;\n            return;\n        }\n        this.handlePointerBasedSelection(event);\n    }\n\n    private handlePointerup(event: Event): void {\n        /*\n         * early return if drag and select is not supported\n         * in this case, selection will be handled by the click event\n         */\n        if (!this.shouldSupportDragAndSelect) {\n            return;\n        }\n        this.pointerUpTarget = event.target;\n        this.handlePointerBasedSelection(event);\n    }\n\n    private async handlePointerBasedSelection(event: Event): Promise<void> {\n        // Only handle left clicks\n        if (event instanceof MouseEvent && event.button !== 0) {\n            return;\n        }\n\n        const path = event.composedPath();\n        const target = path.find((el) => {\n            /* c8 ignore next 3 */\n            if (!(el instanceof Element)) {\n                return false;\n            }\n            return el.getAttribute('role') === this.childRole;\n        }) as MenuItem;\n        if (event.defaultPrevented) {\n            const index = this.childItems.indexOf(target);\n            if (target?.menuData?.focusRoot === this && index > -1) {\n                this.focusedItemIndex = index;\n            }\n            return;\n        }\n        if (target?.href && target.href.length) {\n            // This event will NOT ALLOW CANCELATION as link action\n            // cancelation should occur on the `<sp-menu-item>` itself.\n            this.dispatchEvent(\n                new Event('change', {\n                    bubbles: true,\n                    composed: true,\n                })\n            );\n            return;\n        } else if (\n            target?.menuData?.selectionRoot === this &&\n            this.childItems.length\n        ) {\n            event.preventDefault();\n            if (target.hasSubmenu || target.open) {\n                return;\n            }\n            this.selectOrToggleItem(target);\n        } else {\n            return;\n        }\n        this.prepareToCleanUp();\n    }\n\n    private descendentOverlays = new Map<Overlay, Overlay>();\n\n    protected handleDescendentOverlayOpened(event: Event): void {\n        const target = event.composedPath()[0] as MenuItem;\n        /* c8 ignore next 1 */\n        if (!target.overlayElement) return;\n        this.descendentOverlays.set(\n            target.overlayElement,\n            target.overlayElement\n        );\n    }\n\n    protected handleDescendentOverlayClosed(event: Event): void {\n        const target = event.composedPath()[0] as MenuItem;\n        /* c8 ignore next 1 */\n        if (!target.overlayElement) return;\n        this.descendentOverlays.delete(target.overlayElement);\n    }\n\n    public handleSubmenuClosed = (event: Event): void => {\n        event.stopPropagation();\n        const target = event.composedPath()[0] as Overlay;\n        target.dispatchEvent(\n            new Event('sp-menu-submenu-closed', {\n                bubbles: true,\n                composed: true,\n            })\n        );\n    };\n\n    /**\n     * given a menu item, returns the next focusable menu item before or after it;\n     * if no menu item is provided, returns the first focusable menu item\n     * @param menuItem {MenuItem}\n     * @param before {boolean} return the item before; default is false\n     * @returns {MenuItem}\n     */\n    public getNeighboringFocusableElement(\n        menuItem?: MenuItem,\n        before = false\n    ): MenuItem {\n        const diff = before ? -1 : 1;\n        const elements = this.rovingTabindexController?.elements || [];\n        const index = !!menuItem ? elements.indexOf(menuItem) : -1;\n        let newIndex = Math.min(Math.max(0, index + diff), elements.length - 1);\n        while (\n            !this.isFocusableElement(elements[newIndex]) &&\n            0 < newIndex &&\n            newIndex < elements.length - 1\n        ) {\n            newIndex += diff;\n        }\n        return !!this.isFocusableElement(elements[newIndex])\n            ? (elements[newIndex] as MenuItem)\n            : menuItem || elements[0];\n    }\n\n    public handleSubmenuOpened = (event: Event): void => {\n        event.stopPropagation();\n        const target = event.composedPath()[0] as Overlay;\n        target.dispatchEvent(\n            new Event('sp-menu-submenu-opened', {\n                bubbles: true,\n                composed: true,\n            })\n        );\n\n        const openedItem = event\n            .composedPath()\n            .find((el) => this.childItemSet.has(el as MenuItem));\n        /* c8 ignore next 1 */\n        if (!openedItem) return;\n    };\n\n    public async selectOrToggleItem(targetItem: MenuItem): Promise<void> {\n        const resolvedSelects = this.resolvedSelects;\n        const oldSelectedItemsMap = new Map(this.selectedItemsMap);\n        const oldSelected = this.selected.slice();\n        const oldSelectedItems = this.selectedItems.slice();\n        const oldValue = this.value;\n\n        if (targetItem.menuData.selectionRoot !== this) {\n            return;\n        }\n\n        if (resolvedSelects === 'multiple') {\n            if (this.selectedItemsMap.has(targetItem)) {\n                this.selectedItemsMap.delete(targetItem);\n            } else {\n                this.selectedItemsMap.set(targetItem, true);\n            }\n\n            // Match HTML select and set the first selected\n            // item as the value. Also set the selected array\n            // in the order of the menu items.\n            const selected: string[] = [];\n            const selectedItems: MenuItem[] = [];\n\n            this.childItemSet.forEach((childItem) => {\n                if (childItem.menuData.selectionRoot !== this) return;\n\n                if (this.selectedItemsMap.has(childItem)) {\n                    selected.push(childItem.value);\n                    selectedItems.push(childItem);\n                }\n            });\n            this._selected = selected;\n            this.selectedItems = selectedItems;\n            this.value = this.selected.join(this.valueSeparator);\n        } else {\n            this.selectedItemsMap.clear();\n            this.selectedItemsMap.set(targetItem, true);\n            this.value = targetItem.value;\n            this._selected = [targetItem.value];\n            this.selectedItems = [targetItem];\n        }\n\n        const applyDefault = this.dispatchEvent(\n            new Event('change', {\n                cancelable: true,\n                bubbles: true,\n                composed: true,\n            })\n        );\n\n        if (!applyDefault) {\n            // Cancel the event & don't apply the selection\n            this._selected = oldSelected;\n            this.selectedItems = oldSelectedItems;\n            this.selectedItemsMap = oldSelectedItemsMap;\n            this.value = oldValue;\n            return;\n        }\n        // Apply the selection changes to the menu items\n        if (resolvedSelects === 'single') {\n            for (const oldItem of oldSelectedItemsMap.keys()) {\n                if (oldItem !== targetItem) {\n                    oldItem.selected = false;\n                }\n            }\n            targetItem.selected = true;\n        } else if (resolvedSelects === 'multiple') {\n            targetItem.selected = !targetItem.selected;\n        } else if (\n            !targetItem.hasSubmenu &&\n            targetItem?.menuData?.focusRoot === this\n        ) {\n            this.dispatchEvent(new Event('close', { bubbles: true }));\n        }\n    }\n\n    protected navigateBetweenRelatedMenus(event: MenuItemKeydownEvent): void {\n        const { key, root } = event;\n        const shouldOpenSubmenu =\n            (this.isLTR && key === 'ArrowRight') ||\n            (!this.isLTR && key === 'ArrowLeft');\n        const shouldCloseSelfAsSubmenu =\n            (this.isLTR && key === 'ArrowLeft') ||\n            (!this.isLTR && key === 'ArrowRight') ||\n            key === 'Escape';\n        const lastFocusedItem = root as MenuItem;\n        if (shouldOpenSubmenu) {\n            if (lastFocusedItem?.hasSubmenu) {\n                //open submenu and set focus\n                event.stopPropagation();\n                lastFocusedItem.openOverlay(true);\n            }\n        } else if (shouldCloseSelfAsSubmenu && this.isSubmenu) {\n            event.stopPropagation();\n            this.dispatchEvent(new Event('close', { bubbles: true }));\n            this.updateSelectedItemIndex();\n        }\n    }\n\n    public handleKeydown(event: Event): void {\n        if (event.defaultPrevented || !this.rovingTabindexController) {\n            return;\n        }\n        const { key, root, shiftKey, target } = event as MenuItemKeydownEvent;\n        const openSubmenuKey = ['Enter', ' '].includes(key);\n        if (shiftKey && target !== this && this.hasAttribute('tabindex')) {\n            this.removeAttribute('tabindex');\n            const replaceTabindex = (\n                event: FocusEvent | KeyboardEvent\n            ): void => {\n                if (\n                    !(event as KeyboardEvent).shiftKey &&\n                    !this.hasAttribute('tabindex')\n                ) {\n                    document.removeEventListener('keyup', replaceTabindex);\n                    this.removeEventListener('focusout', replaceTabindex);\n                }\n            };\n            document.addEventListener('keyup', replaceTabindex);\n            this.addEventListener('focusout', replaceTabindex);\n        }\n        if (key === 'Tab') {\n            this.closeDescendentOverlays();\n            return;\n        }\n        if (openSubmenuKey && root?.hasSubmenu && !root.open) {\n            // Remove focus while opening overlay from keyboard or the visible focus\n            // will slip back to the first item in the menu.\n            event.preventDefault();\n            root.openOverlay(true);\n            return;\n        }\n        if (key === ' ' || key === 'Enter') {\n            event.preventDefault();\n            root?.focusElement?.click();\n            if (root) this.selectOrToggleItem(root);\n            return;\n        }\n        this.navigateBetweenRelatedMenus(event as MenuItemKeydownEvent);\n    }\n\n    private _hasUpdatedSelectedItemIndex = false;\n\n    /**\n     * on focus, removes focus from focus styling item, and updates the selected item index\n     */\n    private prepareToCleanUp(): void {\n        document.addEventListener(\n            'focusout',\n            () => {\n                requestAnimationFrame(() => {\n                    const focusedItem = this.focusInItem;\n                    if (focusedItem) {\n                        focusedItem.focused = false;\n                    }\n                });\n            },\n            { once: true }\n        );\n    }\n\n    public updateSelectedItemIndex(): void {\n        let firstOrFirstSelectedIndex = 0;\n        const selectedItemsMap = new Map<MenuItem, boolean>();\n        const selected: string[] = [];\n        const selectedItems: MenuItem[] = [];\n        let itemIndex = this.childItems.length;\n        while (itemIndex) {\n            itemIndex -= 1;\n            const childItem = this.childItems[itemIndex];\n            if (childItem.menuData.selectionRoot === this) {\n                if (\n                    childItem.selected ||\n                    (!this._hasUpdatedSelectedItemIndex &&\n                        this.selected.includes(childItem.value))\n                ) {\n                    firstOrFirstSelectedIndex = itemIndex;\n                    selectedItemsMap.set(childItem, true);\n                    selected.unshift(childItem.value);\n                    selectedItems.unshift(childItem);\n                }\n                // Remove \"focused\" from non-\"selected\" items ONLY\n                // Preserve \"focused\" on index===0 when no selection\n                if (itemIndex !== firstOrFirstSelectedIndex) {\n                    childItem.focused = false;\n                }\n            }\n        }\n\n        this.selectedItemsMap = selectedItemsMap;\n        this._selected = selected;\n        this.selectedItems = selectedItems;\n        this.value = this.selected.join(this.valueSeparator);\n        this.focusedItemIndex = firstOrFirstSelectedIndex;\n        this.focusInItemIndex = firstOrFirstSelectedIndex;\n    }\n\n    private _willUpdateItems = false;\n    private _updateFocus?: MenuItem;\n\n    private handleItemsChanged(): void {\n        this.cachedChildItems = undefined;\n        if (!this._willUpdateItems) {\n            this._willUpdateItems = true;\n            this.cacheUpdated = this.updateCache();\n        }\n    }\n\n    private async updateCache(): Promise<void> {\n        if (!this.hasUpdated) {\n            await Promise.all([\n                new Promise((res) => requestAnimationFrame(() => res(true))),\n                this.updateComplete,\n            ]);\n        } else {\n            await new Promise((res) => requestAnimationFrame(() => res(true)));\n        }\n        if (this.cachedChildItems === undefined) {\n            this.updateSelectedItemIndex();\n            this.updateItemFocus();\n        }\n\n        this._willUpdateItems = false;\n    }\n\n    private updateItemFocus(): void {\n        this.focusInItem?.setAttribute('tabindex', '0');\n        if (this.childItems.length == 0) {\n            return;\n        }\n    }\n\n    public closeDescendentOverlays(): void {\n        this.descendentOverlays.forEach((overlay) => {\n            overlay.open = false;\n        });\n        this.descendentOverlays = new Map<Overlay, Overlay>();\n    }\n\n    private handleSlotchange({\n        target,\n    }: Event & { target: HTMLSlotElement }): void {\n        const assignedElements = target.assignedElements({\n            flatten: true,\n        }) as MenuItem[];\n        if (this.childItems.length !== assignedElements.length) {\n            assignedElements.forEach((item) => {\n                if (typeof item.triggerUpdate !== 'undefined') {\n                    item.triggerUpdate();\n                } else if (\n                    typeof (item as unknown as Menu).childItems !== 'undefined'\n                ) {\n                    (item as unknown as Menu).childItems.forEach((child) => {\n                        child.triggerUpdate();\n                    });\n                }\n            });\n        }\n        if (!!this._updateFocus) {\n            this.rovingTabindexController?.focusOnItem(this._updateFocus);\n            this._updateFocus = undefined;\n        }\n    }\n\n    protected renderMenuItemSlot(): TemplateResult {\n        return html`\n            <slot\n                @sp-menu-submenu-opened=${this.handleDescendentOverlayOpened}\n                @sp-menu-submenu-closed=${this.handleDescendentOverlayClosed}\n                @slotchange=${this.handleSlotchange}\n            ></slot>\n        `;\n    }\n\n    public override render(): TemplateResult {\n        return this.renderMenuItemSlot();\n    }\n\n    protected override firstUpdated(changed: PropertyValues): void {\n        super.firstUpdated(changed);\n        const updates: Promise<unknown>[] = [\n            new Promise((res) => requestAnimationFrame(() => res(true))),\n        ];\n        [...this.children].forEach((item) => {\n            if ((item as MenuItem).localName === 'sp-menu-item') {\n                updates.push((item as MenuItem).updateComplete);\n            }\n        });\n        this.childItemsUpdated = Promise.all(updates);\n    }\n\n    protected override updated(changes: PropertyValues<this>): void {\n        super.updated(changes);\n        if (changes.has('selects') && this.hasUpdated) {\n            this.selectsChanged();\n        }\n        if (\n            changes.has('label') &&\n            (this.label || typeof changes.get('label') !== 'undefined')\n        ) {\n            if (this.label) {\n                this.setAttribute('aria-label', this.label);\n                /* c8 ignore next 3 */\n            } else {\n                this.removeAttribute('aria-label');\n            }\n        }\n    }\n\n    protected selectsChanged(): void {\n        const updates: Promise<unknown>[] = [\n            new Promise((res) => requestAnimationFrame(() => res(true))),\n        ];\n        this.childItemSet.forEach((childItem) => {\n            updates.push(childItem.triggerUpdate());\n        });\n        this.childItemsUpdated = Promise.all(updates);\n    }\n\n    public override connectedCallback(): void {\n        super.connectedCallback();\n        if (!this.hasAttribute('role') && !this.ignore) {\n            this.setAttribute('role', this.ownRole);\n        }\n        this.updateComplete.then(() => this.updateItemFocus());\n    }\n\n    private isFocusableElement(el: MenuItem): boolean {\n        return el ? !el.disabled : false;\n    }\n\n    public override disconnectedCallback(): void {\n        this.cachedChildItems = undefined;\n        this.selectedItems = [];\n        this.selectedItemsMap.clear();\n        this.childItemSet.clear();\n        this.descendentOverlays = new Map<Overlay, Overlay>();\n        super.disconnectedCallback();\n    }\n\n    protected childItemsUpdated!: Promise<unknown[]>;\n    protected cacheUpdated = Promise.resolve();\n    /* c8 ignore next 3 */\n    protected resolveCacheUpdated = (): void => {\n        return;\n    };\n\n    protected override async getUpdateComplete(): Promise<boolean> {\n        const complete = (await super.getUpdateComplete()) as boolean;\n        await this.childItemsUpdated;\n        await this.cacheUpdated;\n        return complete;\n    }\n}\n"],
  "mappings": "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",
  "names": ["event"]
}
