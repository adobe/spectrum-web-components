{
  "version": 3,
  "sources": ["ColorWheel.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {\n    CSSResultArray,\n    html,\n    PropertyValues,\n    TemplateResult,\n} from '@spectrum-web-components/base';\nimport { ifDefined } from '@spectrum-web-components/base/src/directives.js';\nimport {\n    property,\n    query,\n} from '@spectrum-web-components/base/src/decorators.js';\nimport { streamingListener } from '@spectrum-web-components/base/src/streaming-listener.js';\nimport { SWCResizeObserverEntry, WithSWCResizeObserver } from './types';\nimport { Focusable } from '@spectrum-web-components/shared/src/focusable.js';\nimport type { ColorHandle } from '@spectrum-web-components/color-handle';\nimport '@spectrum-web-components/color-handle/sp-color-handle.js';\nimport {\n    ColorController,\n    ColorTypes,\n} from '@spectrum-web-components/reactive-controllers/src/ColorController.js';\nimport { LanguageResolutionController } from '@spectrum-web-components/reactive-controllers/src/LanguageResolution.js';\n\nimport styles from './color-wheel.css.js';\n\n/**\n * @element sp-color-wheel\n * @slot gradient - a custom gradient visually outlining the available color values\n * @fires input - The value of the Color Wheel has changed.\n * @fires change - An alteration to the value of the Color Wheel has been committed by the user.\n */\nexport class ColorWheel extends Focusable {\n    public static override get styles(): CSSResultArray {\n        return [styles];\n    }\n\n    @property({ type: String, reflect: true })\n    public override dir!: 'ltr' | 'rtl';\n\n    @property({ type: Boolean, reflect: true })\n    public override disabled = false;\n\n    @property({ type: Boolean, reflect: true })\n    public focused = false;\n\n    @query('.handle')\n    private handle!: ColorHandle;\n\n    @property({ type: String })\n    public label = 'hue';\n\n    @property({ type: Number })\n    public step = 1;\n\n    private languageResolver = new LanguageResolutionController(this);\n\n    private colorController = new ColorController(this, { manageAs: 'hsv' });\n\n    @property({ type: Number })\n    public get value(): number {\n        return this.colorController.hue;\n    }\n\n    public set value(hue: number) {\n        this.colorController.hue = hue;\n    }\n\n    @property({ type: String })\n    public get color(): ColorTypes {\n        return this.colorController.colorValue;\n    }\n\n    public set color(color: ColorTypes) {\n        this.colorController.color = color;\n    }\n\n    private get altered(): number {\n        return this._altered;\n    }\n\n    private set altered(altered: number) {\n        this._altered = altered;\n        this.step = Math.max(1, this.altered * 10);\n    }\n\n    private _altered = 0;\n\n    @query('input')\n    public input!: HTMLInputElement;\n\n    public override get focusElement(): HTMLInputElement {\n        return this.input;\n    }\n\n    private handleKeydown(event: KeyboardEvent): void {\n        const { key } = event;\n        this.focused = true;\n        this.altered = [event.shiftKey, event.ctrlKey, event.altKey].filter(\n            (key) => !!key\n        ).length;\n        let delta = 0;\n        switch (key) {\n            case 'ArrowUp':\n                delta = this.step;\n                break;\n            case 'ArrowDown':\n                delta = -this.step;\n                break;\n            case 'ArrowLeft':\n                delta = this.step * (this.isLTR ? -1 : 1);\n                break;\n            case 'ArrowRight':\n                delta = this.step * (this.isLTR ? 1 : -1);\n                break;\n            default:\n                return;\n        }\n        event.preventDefault();\n        this.value = (360 + this.value + delta) % 360;\n        this.colorController.savePreviousColor();\n        this.dispatchEvent(\n            new Event('input', {\n                bubbles: true,\n                composed: true,\n            })\n        );\n        const applyDefault = this.dispatchEvent(\n            new Event('change', {\n                bubbles: true,\n                composed: true,\n                cancelable: true,\n            })\n        );\n        if (!applyDefault) {\n            this.colorController.restorePreviousColor();\n        }\n    }\n\n    private handleInput(event: Event & { target: HTMLInputElement }): void {\n        const { valueAsNumber } = event.target;\n\n        this.value = valueAsNumber;\n    }\n\n    private handleChange(event: Event & { target: HTMLInputElement }): void {\n        this.handleInput(event);\n        this.dispatchEvent(\n            new Event('change', {\n                bubbles: true,\n                composed: true,\n            })\n        );\n    }\n\n    public override focus(focusOptions: FocusOptions = {}): void {\n        super.focus(focusOptions);\n        this.forwardFocus();\n    }\n\n    private forwardFocus(): void {\n        this.focused = this.hasVisibleFocusInTree();\n        this.input.focus();\n    }\n\n    private handleFocus(): void {\n        this.focused = true;\n    }\n\n    private handleBlur(): void {\n        if (this._pointerDown) {\n            return;\n        }\n        this.altered = 0;\n        this.focused = false;\n    }\n\n    private boundingClientRect!: DOMRect;\n    private _pointerDown = false;\n\n    private handlePointerdown(event: PointerEvent): void {\n        if (event.button !== 0) {\n            event.preventDefault();\n            return;\n        }\n        this._pointerDown = true;\n        this.colorController.savePreviousColor();\n        this.boundingClientRect = this.getBoundingClientRect();\n        (event.target as HTMLElement).setPointerCapture(event.pointerId);\n        if (event.pointerType === 'mouse') {\n            this.focused = true;\n        }\n    }\n\n    private handlePointermove(event: PointerEvent): void {\n        this.value = this.calculateHandlePosition(event);\n\n        this.dispatchEvent(\n            new Event('input', {\n                bubbles: true,\n                composed: true,\n                cancelable: true,\n            })\n        );\n    }\n\n    private handlePointerup(event: PointerEvent): void {\n        this._pointerDown = false;\n        (event.target as HTMLElement).releasePointerCapture(event.pointerId);\n\n        const applyDefault = this.dispatchEvent(\n            new Event('change', {\n                bubbles: true,\n                composed: true,\n                cancelable: true,\n            })\n        );\n        if (!applyDefault) {\n            this.colorController.restorePreviousColor();\n        }\n        // Retain focus on input element after mouse up to enable keyboard interactions\n        this.focus();\n        if (event.pointerType === 'mouse') {\n            this.focused = false;\n        }\n    }\n\n    /**\n     * Returns the value under the cursor\n     * @param: PointerEvent on slider\n     * @return: Slider value that correlates to the position under the pointer\n     */\n    private calculateHandlePosition(event: PointerEvent): number {\n        /* c8 ignore next 3 */\n        if (!this.boundingClientRect) {\n            return this.value;\n        }\n        const rect = this.boundingClientRect;\n        const { width, height, left, top } = rect;\n        const centerX = left + width / 2;\n        const centerY = top + height / 2;\n        const pointX = event.clientX - centerX;\n        const pointY = event.clientY - centerY;\n        const value = (Math.atan2(pointY, pointX) * 180) / Math.PI;\n\n        return (360 + (360 + (this.isLTR ? value : 180 - value))) % 360;\n    }\n\n    private handleGradientPointerdown(event: PointerEvent): void {\n        if (\n            event.button !== 0 ||\n            (event.target as SVGElement).classList.contains('innerCircle')\n        ) {\n            return;\n        }\n        event.stopPropagation();\n        event.preventDefault();\n        const { button, pointerId, pointerType } = event;\n        this.handle.dispatchEvent(\n            new PointerEvent('pointerdown', {\n                button,\n                pointerId,\n                pointerType,\n            })\n        );\n        this.handlePointermove(event);\n    }\n\n    calculateStyleData(): {\n        clipPath: string;\n        clipPathBorders: string;\n        diameter: number;\n        handleLocationStyles: string;\n    } {\n        // Extract values from element.\n        const { width: diameter = 160 } = this.boundingClientRect || {};\n        const styles = getComputedStyle(this);\n        const borderWidth = parseFloat(\n            styles.getPropertyValue('--_border-width')\n        );\n        const trackWidth = parseFloat(\n            styles.getPropertyValue('--_track-width')\n        );\n\n        // Calculate wheel data.\n        const radius = diameter / 2;\n        const diameterAfterBoarder = diameter - borderWidth * 2;\n        const radiusAfterBoarder = radius - borderWidth;\n        const innerRadius = radius - trackWidth;\n        const innerDiameter = innerRadius * 2;\n        const innerRadiusAfterBorder = innerRadius + borderWidth;\n        const innerDiameterAfterBorder = innerDiameter + borderWidth * 2;\n        const clipPathBorders = `\"M ${radius} ${radius} m -${radius} 0 a ${radius} ${radius} 0 1 0 ${diameter} 0 a ${radius} ${radius} 0 1 0 -${diameter} 0 M ${radius} ${radius} m -${innerRadius} 0 a ${innerRadius} ${innerRadius} 0 1 0 ${innerDiameter} 0 a ${innerRadius} ${innerRadius} 0 1 0 -${innerDiameter} 0\"`;\n        const clipPath = `\"M ${radiusAfterBoarder} ${radiusAfterBoarder} m -${radiusAfterBoarder} 0 a ${radiusAfterBoarder} ${radiusAfterBoarder} 0 1 0 ${diameterAfterBoarder} 0 a ${radiusAfterBoarder} ${radiusAfterBoarder} 0 1 0 -${diameterAfterBoarder} 0 M ${radiusAfterBoarder} ${radiusAfterBoarder} m -${innerRadiusAfterBorder} 0 a ${innerRadiusAfterBorder} ${innerRadiusAfterBorder} 0 1 0 ${innerDiameterAfterBorder} 0 a ${innerRadiusAfterBorder} ${innerRadiusAfterBorder} 0 1 0 -${innerDiameterAfterBorder} 0\"`;\n\n        // Calculate handle position on the wheel.\n        const translateX =\n            (this.isLTR ? 1 : -1) *\n            (radius - trackWidth / 2) *\n            Math.cos((this.value * Math.PI) / 180);\n        const translateY =\n            (radius - trackWidth / 2) * Math.sin((this.value * Math.PI) / 180);\n        const handleLocationStyles = `transform: translate(${translateX}px, ${translateY}px);`;\n\n        return {\n            clipPath,\n            clipPathBorders,\n            diameter,\n            handleLocationStyles,\n        };\n    }\n\n    protected override render(): TemplateResult {\n        const { clipPath, clipPathBorders, diameter, handleLocationStyles } =\n            this.calculateStyleData();\n\n        return html`\n            <slot\n                name=\"gradient\"\n                @pointerdown=${this.handleGradientPointerdown}\n                style=\"\n                    --spectrum-colorwheel-colorarea-container-size: ${diameter}px;\n                    --spectrum-colorwheel-height: ${diameter}px;\n                    --spectrum-colorwheel-width: ${diameter}px;\n                    --spectrum-colorwheel-path-borders: ${clipPathBorders};\n                    --spectrum-colorwheel-path: ${clipPath};\n                \"\n            >\n                <div class=\"inner\">\n                    <div class=\"colorarea-container\"></div>\n                </div>\n                <div class=\"border\">\n                    <div class=\"wheel\"></div>\n                </div>\n            </slot>\n\n            <sp-color-handle\n                tabindex=${ifDefined(this.focused ? undefined : '0')}\n                @focus=${this.forwardFocus}\n                ?focused=${this.focused}\n                class=\"handle\"\n                color=\"hsl(${this.value}, 100%, 50%)\"\n                ?disabled=${this.disabled}\n                style=${handleLocationStyles}\n                ${streamingListener({\n                    start: ['pointerdown', this.handlePointerdown],\n                    streamInside: ['pointermove', this.handlePointermove],\n                    end: [\n                        ['pointerup', 'pointercancel', 'pointerleave'],\n                        this.handlePointerup,\n                    ],\n                })}\n            ></sp-color-handle>\n\n            <input\n                type=\"range\"\n                class=\"slider\"\n                aria-label=${this.label}\n                min=\"0\"\n                max=\"360\"\n                step=${this.step}\n                .value=${String(this.value)}\n                aria-valuetext=${`${new Intl.NumberFormat(\n                    this.languageResolver.language,\n                    {\n                        maximumFractionDigits: 0,\n                        minimumIntegerDigits: 1,\n                        style: 'unit',\n                        unit: 'degree',\n                        unitDisplay: 'narrow',\n                    }\n                ).format(this.value)}`}\n                @input=${this.handleInput}\n                @change=${this.handleChange}\n                @keydown=${this.handleKeydown}\n            />\n        `;\n    }\n\n    protected override firstUpdated(changed: PropertyValues): void {\n        super.firstUpdated(changed);\n        this.boundingClientRect = this.getBoundingClientRect();\n        this.addEventListener('focus', this.handleFocus);\n        this.addEventListener('blur', this.handleBlur);\n    }\n\n    private observer?: WithSWCResizeObserver['ResizeObserver'];\n\n    public override connectedCallback(): void {\n        super.connectedCallback();\n        if (\n            !this.observer &&\n            (window as unknown as WithSWCResizeObserver).ResizeObserver\n        ) {\n            this.observer = new (\n                window as unknown as WithSWCResizeObserver\n            ).ResizeObserver((entries: SWCResizeObserverEntry[]) => {\n                for (const entry of entries) {\n                    this.boundingClientRect = entry.contentRect;\n                }\n                this.requestUpdate();\n            });\n        }\n        this.observer?.observe(this);\n    }\n\n    public override disconnectedCallback(): void {\n        this.observer?.unobserve(this);\n        super.disconnectedCallback();\n    }\n}\n"],
  "mappings": "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",
  "names": ["html", "ifDefined", "property", "query", "streamingListener", "Focusable", "ColorController", "LanguageResolutionController", "styles", "hue", "color", "altered", "event", "key", "delta", "valueAsNumber", "focusOptions", "rect", "width", "height", "left", "top", "centerX", "centerY", "pointX", "pointY", "value", "button", "pointerId", "pointerType", "diameter", "borderWidth", "trackWidth", "radius", "diameterAfterBoarder", "radiusAfterBoarder", "innerRadius", "innerDiameter", "innerRadiusAfterBorder", "innerDiameterAfterBorder", "clipPathBorders", "clipPath", "translateX", "translateY", "handleLocationStyles", "changed", "_a", "entries", "entry", "__decorateClass"]
}
