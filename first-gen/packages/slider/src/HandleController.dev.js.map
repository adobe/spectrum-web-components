{
  "version": 3,
  "sources": ["HandleController.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { html, TemplateResult } from '@spectrum-web-components/base';\nimport {\n    classMap,\n    ifDefined,\n    styleMap,\n} from '@spectrum-web-components/base/src/directives.js';\nimport { MutationController } from '@lit-labs/observers/mutation-controller.js';\nimport { Slider } from './Slider.dev.js'\nimport { SliderHandle, SliderNormalization } from './SliderHandle.dev.js'\n\ninterface HandleReference {\n    handle: HTMLElement;\n    input: HTMLInputElement;\n}\n\ninterface HandleComponents extends HandleReference {\n    model: SliderHandle;\n}\n\ninterface RangeAndClamp {\n    range: { min: number; max: number };\n    clamp: { min: number; max: number };\n}\ninterface ModelValue extends RangeAndClamp {\n    name: string;\n    value: number;\n    normalizedValue: number;\n    step: number;\n    highlight: boolean;\n    ariaLabel?: string;\n    normalization: SliderNormalization;\n    handle: SliderHandle;\n}\n\ninterface InputWithModel extends HTMLInputElement {\n    model: ModelValue;\n}\n\ninterface DataFromPointerEvent {\n    resolvedInput: boolean;\n    input: InputWithModel;\n    model?: ModelValue;\n}\n\nexport interface HandleValueDictionary {\n    [key: string]: number;\n}\n\nexport class HandleController {\n    private host!: Slider;\n    private handles: Map<string, SliderHandle> = new Map();\n    private model: ModelValue[] = [];\n    private handleOrder: string[] = [];\n    private draggingHandle?: SliderHandle;\n    private handleRefMap?: WeakMap<SliderHandle, HandleReference>;\n\n    constructor(host: Slider) {\n        this.host = host;\n\n        new MutationController(this.host, {\n            config: {\n                subtree: true,\n                childList: true,\n            },\n            callback: () => {\n                this.extractModelFromLightDom();\n            },\n        });\n\n        this.extractModelFromLightDom();\n    }\n\n    public get values(): HandleValueDictionary {\n        const result: HandleValueDictionary = {};\n        for (const model of this.handles.values()) {\n            result[model.handleName] = model.value;\n        }\n        return result;\n    }\n\n    public get size(): number {\n        return this.handles.size;\n    }\n\n    public inputForHandle(handle: SliderHandle): HTMLInputElement | undefined {\n        if (this.handles.has(handle.handleName)) {\n            const { input } = this.getHandleElements(handle) || {};\n            return input;\n        }\n        /* c8 ignore next 2 */\n        throw new Error(`No input for handle \"${handle.name}\"`);\n    }\n\n    public requestUpdate(): void {\n        if (this.host.hasUpdated) {\n            this.host.requestUpdate();\n        }\n    }\n\n    /**\n     * It is possible for value attributes to be set programmatically. The <input>\n     * for a particular slider needs to have an opportunity to validate any such\n     * values\n     *\n     * @param handle Handle who's value needs validation\n     */\n    public setValueFromHandle(handle: SliderHandle): void {\n        const elements = this.getHandleElements(handle);\n        /* c8 ignore next */\n        if (!elements) return;\n\n        const { input } = elements;\n\n        input.valueAsNumber = handle.value;\n        this.requestUpdate();\n        // reset to potentially clamped value\n        handle.value = input.valueAsNumber;\n\n        if (handle.dragging) {\n            handle.dispatchInputEvent();\n        }\n    }\n\n    public handleHasChanged(handle: SliderHandle): void {\n        if (handle !== this.host) {\n            this.requestUpdate();\n        }\n    }\n\n    public formattedValueForHandle(model: ModelValue): string {\n        const { handle } = model;\n        const numberFormat = handle.numberFormat ?? this.host.numberFormat;\n        const _forcedUnit =\n            handle._forcedUnit === ''\n                ? this.host._forcedUnit\n                : handle._forcedUnit;\n        return (\n            handle.getAriaHandleText(model.value, numberFormat) + _forcedUnit\n        );\n    }\n\n    public get formattedValues(): Map<string, string> {\n        const result = new Map<string, string>();\n        for (const model of this.model) {\n            result.set(model.name, this.formattedValueForHandle(model));\n        }\n        return result;\n    }\n\n    public get focusElement(): HTMLElement {\n        const { input } = this.getActiveHandleElements();\n        if (\n            !input ||\n            (this.host.editable &&\n                !(input as InputWithModel).model.handle.dragging)\n        ) {\n            return this.host.numberField;\n        }\n        return input;\n    }\n\n    protected handleOrientation = (): void => {\n        this.updateBoundingRect();\n    };\n\n    public hostConnected(): void {\n        if ('orientation' in screen) {\n            screen.orientation.addEventListener(\n                'change',\n                this.handleOrientation\n            );\n        } else {\n            window.addEventListener(\n                'orientationchange',\n                this.handleOrientation\n            );\n        }\n    }\n\n    public hostDisconnected(): void {\n        if ('orientation' in screen) {\n            screen.orientation.removeEventListener(\n                'change',\n                this.handleOrientation\n            );\n        } else {\n            window.removeEventListener(\n                'orientationchange',\n                this.handleOrientation\n            );\n        }\n    }\n\n    public hostUpdate(): void {\n        this.updateModel();\n    }\n\n    // Since extractModelFromLightDom bails on the first un-upgraded handle,\n    // a maximum of one listener will be set up per extraction attempt.\n    private waitForUpgrade(handle: HTMLElement): boolean {\n        if (handle instanceof SliderHandle) {\n            return false;\n        }\n        handle.addEventListener(\n            'sp-slider-handle-ready',\n            () => this.extractModelFromLightDom(),\n            { once: true, passive: true }\n        );\n        return true;\n    }\n\n    private extractModelFromLightDom = (): void => {\n        let handles = [\n            ...this.host.querySelectorAll('[slot=\"handle\"]'),\n        ] as SliderHandle[];\n        if (handles.length === 0) {\n            handles = [this.host as SliderHandle];\n        }\n        // extractModelFromLightDom depends on slotted handles already having been upgraded\n        if (handles.some((h) => this.waitForUpgrade(h))) {\n            return;\n        }\n        this.handles = new Map();\n        this.handleOrder = [];\n        handles.forEach((handle, index) => {\n            /* c8 ignore next */\n            if (!handle.handleName?.length) {\n                handle.name = `handle${index + 1}`;\n            }\n            this.handles.set(handle.handleName, handle);\n            this.handleOrder.push(handle.handleName);\n            handle.handleController = this;\n        });\n        this.requestUpdate();\n    };\n\n    public get activeHandle(): string {\n        return this.handleOrder[this.handleOrder.length - 1];\n    }\n\n    public get activeHandleInputId(): string {\n        const active = this.activeHandle;\n        const index = this.model.findIndex((model) => model.name === active);\n        return `input-${index}`;\n    }\n\n    public activateHandle(name: string): void {\n        const index = this.handleOrder.findIndex((item) => item === name);\n        if (index >= 0) {\n            this.handleOrder.splice(index, 1);\n        }\n        this.handleOrder.push(name);\n    }\n\n    public get activeHandleModel(): ModelValue {\n        const active = this.activeHandle;\n        return this.model.find((model) => model.name === active)!;\n    }\n\n    private getActiveHandleElements(): HandleComponents {\n        const name = this.activeHandle;\n        const handleSlider = this.handles.get(name) as SliderHandle;\n        const elements = this.getHandleElements(\n            handleSlider\n        ) as HandleReference;\n        return { model: handleSlider, ...elements };\n    }\n\n    private getHandleElements(sliderHandle: SliderHandle): HandleReference {\n        if (!this.handleRefMap) {\n            this.handleRefMap = new WeakMap();\n\n            const inputNodes =\n                this.host.shadowRoot.querySelectorAll('.handle > input');\n            for (const inputNode of inputNodes) {\n                const input = inputNode as HTMLInputElement;\n                const handle = input.parentElement as HTMLElement;\n                const model = this.handles.get(\n                    handle.getAttribute('name') as string\n                );\n                if (model) {\n                    this.handleRefMap.set(model, { input, handle });\n                }\n            }\n        }\n\n        const components = this.handleRefMap.get(\n            sliderHandle\n        ) as HandleReference;\n        return components;\n    }\n\n    private clearHandleComponentCache(): void {\n        delete this.handleRefMap;\n    }\n\n    private _boundingClientRect?: DOMRect;\n\n    private get boundingClientRect(): DOMRect {\n        if (!this._boundingClientRect) {\n            this._boundingClientRect = this.host.track.getBoundingClientRect();\n        }\n        return this._boundingClientRect;\n    }\n\n    private updateBoundingRect(): void {\n        delete this._boundingClientRect;\n    }\n\n    /**\n     * Return the `input` and `model` associated with the event and\n     * whether the `input` is a `resolvedInput` meaning it was acquired\n     * from the `model` rather than the event.\n     */\n    protected extractDataFromEvent(event: PointerEvent): DataFromPointerEvent {\n        if (!this._activePointerEventData) {\n            let input = (event.target as Element).querySelector(\n                ':scope > .input'\n            ) as InputWithModel;\n            const resolvedInput = !input;\n            const model = input\n                ? input.model\n                : this.model.find((item) => item.name === this.activeHandle);\n            if (!input && !!model) {\n                input = model.handle.focusElement as InputWithModel;\n            }\n            this._activePointerEventData = {\n                input,\n                model,\n                resolvedInput,\n            };\n        }\n        return this._activePointerEventData;\n    }\n\n    private _activePointerEventData!: DataFromPointerEvent | undefined;\n\n    /**\n     * @description check for defaultvalue(value) property in sp-slider and reset on double click on sliderHandle\n     * @param event\n     */\n    public handleDoubleClick(event: PointerEvent): void {\n        const input = (event.target as Element).querySelector(\n            '.input'\n        ) as InputWithModel;\n\n        if (input.model?.handle.defaultValue !== undefined) {\n            input.model.handle.value = input.model.handle.defaultValue;\n            this.dispatchChangeEvent(input, input.model.handle);\n            input.model.handle.dispatchInputEvent();\n            this.requestUpdate();\n        }\n    }\n\n    public handlePointerdown(event: PointerEvent): void {\n        const { resolvedInput, model } = this.extractDataFromEvent(event);\n        if (!model || this.host.disabled || event.button !== 0) {\n            event.preventDefault();\n            return;\n        }\n        this.host.track.setPointerCapture(event.pointerId);\n        this.updateBoundingRect();\n        if (event.pointerType === 'mouse') {\n            this.host.labelEl.click();\n        }\n        this.draggingHandle = model.handle;\n        model.handle.dragging = true;\n        this.activateHandle(model.name);\n        if (resolvedInput) {\n            // When the input is resolved forward the pointer event to\n            // `handlePointermove` in order to update the value/UI becuase\n            // the pointer event was on the track not a handle\n            this.handlePointermove(event);\n        }\n        this.requestUpdate();\n    }\n\n    public handlePointerup(event: PointerEvent): void {\n        const { input, model } = this.extractDataFromEvent(event);\n        delete this._activePointerEventData;\n        if (!model) return;\n        if (event.pointerType === 'mouse') {\n            this.host.labelEl.click();\n        }\n        this.cancelDrag(model);\n        this.requestUpdate();\n        this.host.track.releasePointerCapture(event.pointerId);\n        this.dispatchChangeEvent(input, model.handle);\n    }\n\n    public handlePointermove(event: PointerEvent): void {\n        const { input, model } = this.extractDataFromEvent(event);\n        if (!model) return;\n        /* c8 ignore next 3 */\n        if (!this.draggingHandle) {\n            return;\n        }\n        input.value = this.calculateHandlePosition(event, model).toString();\n        model.handle.value = parseFloat(input.value);\n        this.host.indeterminate = false;\n        this.requestUpdate();\n    }\n\n    public cancelDrag(model?: ModelValue): void {\n        model =\n            model || this.model.find((item) => item.name === this.activeHandle);\n        if (!model) return;\n        model.handle.highlight = false;\n        delete this.draggingHandle;\n        model.handle.dragging = false;\n    }\n\n    /**\n     * Keep the slider value property in sync with the input element's value\n     */\n    private onInputChange = (event: Event): void => {\n        const input = event.target as InputWithModel;\n        input.model.handle.value = input.valueAsNumber;\n\n        this.requestUpdate();\n        this.dispatchChangeEvent(input, input.model.handle);\n    };\n\n    private onInputFocus = (event: Event): void => {\n        const input = event.target as InputWithModel;\n        let isFocusVisible;\n        try {\n            isFocusVisible =\n                input.matches(':focus-visible') ||\n                this.host.matches('.focus-visible');\n            /* c8 ignore next 3 */\n        } catch (error) {\n            isFocusVisible = this.host.matches('.focus-visible');\n        }\n        input.model.handle.highlight = isFocusVisible;\n        this.requestUpdate();\n    };\n\n    private onInputBlur = (event: Event): void => {\n        const input = event.target as InputWithModel;\n        input.model.handle.highlight = false;\n        this.requestUpdate();\n    };\n\n    private onInputKeydown = (event: KeyboardEvent): void => {\n        if (event.key == 'Escape') {\n            const input = event.target as InputWithModel;\n            if (\n                input.model.handle?.defaultValue !== undefined &&\n                input.model.handle.value !== input.model.handle.defaultValue\n            ) {\n                input.model.handle.value = input.model.handle.defaultValue;\n                input.model.handle.dispatchInputEvent();\n                this.dispatchChangeEvent(input, input.model.handle);\n                this.requestUpdate();\n                event.preventDefault();\n                event.stopPropagation();\n            }\n            return;\n        }\n        const input = event.target as InputWithModel;\n        input.model.handle.highlight = true;\n        this.requestUpdate();\n    };\n\n    private dispatchChangeEvent(\n        input: HTMLInputElement,\n        handle: SliderHandle\n    ): void {\n        input.valueAsNumber = handle.value;\n\n        const changeEvent = new Event('change', {\n            bubbles: true,\n            composed: true,\n        });\n\n        handle.dispatchEvent(changeEvent);\n    }\n\n    /**\n     * Returns the value under the cursor\n     * @param: PointerEvent on slider\n     * @return: Slider value that correlates to the position under the pointer\n     */\n    private calculateHandlePosition(\n        event: PointerEvent | MouseEvent,\n        model: ModelValue\n    ): number {\n        const rect = this.boundingClientRect;\n        const minOffset = rect.left;\n        const offset = event.clientX;\n        const size = rect.width;\n\n        const directionalOffset = this.host.isLTR\n            ? offset - minOffset\n            : size - (offset - minOffset);\n        const normalized = directionalOffset / size;\n\n        return model.normalization.fromNormalized(\n            normalized,\n            model.range.min,\n            model.range.max\n        );\n    }\n\n    public renderHandle(\n        model: ModelValue,\n        index: number,\n        zIndex: number,\n        isMultiHandle: boolean\n    ): TemplateResult {\n        const classes = {\n            handle: true,\n            dragging: this.draggingHandle?.handleName === model.name,\n            'handle-highlight': model.highlight,\n        };\n        const style = {\n            [this.host.isLTR ? 'left' : 'right']: `${\n                model.normalizedValue * 100\n            }%`,\n            'z-index': zIndex.toString(),\n            ...(isMultiHandle && {\n                'background-color': `var(--spectrum-slider-handle-background-color-${index}, var(--spectrum-slider-handle-background-color))`,\n                'border-color': `var(--spectrum-slider-handle-border-color-${index}, var(--spectrum-slider-handle-border-color))`,\n            }),\n        };\n        const ariaLabelledBy = isMultiHandle ? `label input-${index}` : 'label';\n        return html`\n            <div\n                class=${classMap(classes)}\n                name=${model.name}\n                style=${styleMap(style)}\n                role=\"presentation\"\n            >\n                <input\n                    type=\"range\"\n                    class=\"input\"\n                    id=\"input-${index}\"\n                    min=${model.clamp.min}\n                    max=${model.clamp.max}\n                    step=${model.step}\n                    value=${model.value}\n                    aria-disabled=${ifDefined(\n                        this.host.disabled ? 'true' : undefined\n                    )}\n                    tabindex=${ifDefined(this.host.editable ? -1 : undefined)}\n                    aria-label=${ifDefined(model.ariaLabel)}\n                    aria-labelledby=${ariaLabelledBy}\n                    aria-valuetext=${this.formattedValueForHandle(model)}\n                    aria-describedby=\"slider-description\"\n                    @change=${this.onInputChange}\n                    @focus=${this.onInputFocus}\n                    @blur=${this.onInputBlur}\n                    @keydown=${this.onInputKeydown}\n                    .model=${model}\n                />\n                <span id=\"slider-description\">\n                    Press escape or double click to reset the slider to its\n                    default value.\n                </span>\n            </div>\n        `;\n    }\n\n    public render(): TemplateResult[] {\n        this.clearHandleComponentCache();\n        return this.model.map((model, index) => {\n            const zIndex = this.handleOrder.indexOf(model.name) + 2;\n            return this.renderHandle(\n                model,\n                index,\n                zIndex,\n                this.model.length > 1\n            );\n        });\n    }\n\n    /**\n     * Returns a list of track segment [start, end] tuples where the values are\n     * normalized to be between 0 and 1.\n     * @returns A list of track segment tuples [start, end]\n     */\n    public trackSegments(): [number, number][] {\n        const values = this.model.map((model) => model.normalizedValue);\n        values.sort((a, b) => a - b);\n\n        // The first segment always starts at 0\n        values.unshift(0);\n        return values.map((value, index, array) => [\n            value,\n            array[index + 1] ?? 1,\n        ]);\n    }\n\n    private updateModel(): void {\n        const handles = [...this.handles.values()];\n\n        const getRangeAndClamp = (index: number): RangeAndClamp => {\n            const handle = handles[index];\n            const previous = handles[index - 1];\n            const next = handles[index + 1];\n\n            const min =\n                typeof handle.min === 'number'\n                    ? handle.min\n                    : (this.host.min as number);\n            const max =\n                typeof handle.max === 'number'\n                    ? handle.max\n                    : (this.host.max as number);\n\n            const result: RangeAndClamp = {\n                range: { min: min, max: max },\n                clamp: { min: min, max: max },\n            };\n\n            if (handle.min === 'previous') {\n                if (previous) {\n                    for (let j = index - 1; j >= 0; j--) {\n                        const item = handles[j];\n                        if (typeof item.min === 'number') {\n                            result.range.min = item.min;\n                            break;\n                        }\n                    }\n                    result.clamp.min = Math.max(\n                        previous.value,\n                        result.range.min\n                    );\n                }\n                if (window.__swc.DEBUG) {\n                    if (!previous) {\n                        window.__swc.warn(\n                            this.host,\n                            '<sp-slider-handle> elements that are the first child of an <sp-slider> element cannot have attribute \"min=\\'previous\\'\"`',\n                            'https://opensource.adobe.com/spectrum-web-components/components/slider-handle/#multi-handle-slider-with-ordered-handles'\n                        );\n                    }\n                }\n            }\n            if (handle.max === 'next') {\n                if (next) {\n                    for (let j = index + 1; j < handles.length; j++) {\n                        const item = handles[j];\n                        if (typeof item.max === 'number') {\n                            result.range.max = item.max;\n                            break;\n                        }\n                    }\n                    result.clamp.max = Math.min(next.value, result.range.max);\n                }\n                if (window.__swc.DEBUG) {\n                    if (!next) {\n                        window.__swc.warn(\n                            this.host,\n                            '<sp-slider-handle> elements that are the last child of an <sp-slider> element cannot have attribute \"max=\\'next\\'\"',\n                            'https://opensource.adobe.com/spectrum-web-components/components/slider-handle/#multi-handle-slider-with-ordered-handles'\n                        );\n                    }\n                }\n            }\n            return result;\n        };\n\n        const modelValues = handles.map((handle, index) => {\n            const rangeAndClamp = getRangeAndClamp(index);\n            const { toNormalized } = handle.normalization;\n            const clampedValue = Math.max(\n                Math.min(handle.value, rangeAndClamp.clamp.max),\n                rangeAndClamp.clamp.min\n            );\n            const normalizedValue = toNormalized(\n                clampedValue,\n                rangeAndClamp.range.min,\n                rangeAndClamp.range.max\n            );\n            const model = {\n                name: handle.handleName,\n                value: clampedValue,\n                normalizedValue,\n                highlight: handle.highlight,\n                step: handle.step ?? this.host.step,\n                normalization: handle.normalization,\n                handle,\n                ariaLabel:\n                    handle !== this.host && handle?.label.length > 0\n                        ? handle.label\n                        : undefined,\n                ...rangeAndClamp,\n            };\n            return model;\n        });\n\n        this.model = modelValues;\n    }\n\n    public async handleUpdatesComplete(): Promise<void> {\n        const updates = [...this.handles.values()]\n            .filter((handle) => handle !== this.host)\n            .map((handle) => handle.updateComplete);\n        await Promise.all(updates);\n    }\n}\n"],
  "mappings": "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",
  "names": ["input"]
}
