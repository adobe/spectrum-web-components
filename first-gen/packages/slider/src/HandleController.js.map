{
  "version": 3,
  "sources": ["HandleController.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nimport { html, TemplateResult } from '@spectrum-web-components/base';\nimport {\n    classMap,\n    ifDefined,\n    styleMap,\n} from '@spectrum-web-components/base/src/directives.js';\nimport { MutationController } from '@lit-labs/observers/mutation-controller.js';\nimport { Slider } from './Slider.js';\nimport { SliderHandle, SliderNormalization } from './SliderHandle.js';\n\ninterface HandleReference {\n    handle: HTMLElement;\n    input: HTMLInputElement;\n}\n\ninterface HandleComponents extends HandleReference {\n    model: SliderHandle;\n}\n\ninterface RangeAndClamp {\n    range: { min: number; max: number };\n    clamp: { min: number; max: number };\n}\ninterface ModelValue extends RangeAndClamp {\n    name: string;\n    value: number;\n    normalizedValue: number;\n    step: number;\n    highlight: boolean;\n    ariaLabel?: string;\n    normalization: SliderNormalization;\n    handle: SliderHandle;\n}\n\ninterface InputWithModel extends HTMLInputElement {\n    model: ModelValue;\n}\n\ninterface DataFromPointerEvent {\n    resolvedInput: boolean;\n    input: InputWithModel;\n    model?: ModelValue;\n}\n\nexport interface HandleValueDictionary {\n    [key: string]: number;\n}\n\nexport class HandleController {\n    private host!: Slider;\n    private handles: Map<string, SliderHandle> = new Map();\n    private model: ModelValue[] = [];\n    private handleOrder: string[] = [];\n    private draggingHandle?: SliderHandle;\n    private handleRefMap?: WeakMap<SliderHandle, HandleReference>;\n\n    constructor(host: Slider) {\n        this.host = host;\n\n        new MutationController(this.host, {\n            config: {\n                subtree: true,\n                childList: true,\n            },\n            callback: () => {\n                this.extractModelFromLightDom();\n            },\n        });\n\n        this.extractModelFromLightDom();\n    }\n\n    public get values(): HandleValueDictionary {\n        const result: HandleValueDictionary = {};\n        for (const model of this.handles.values()) {\n            result[model.handleName] = model.value;\n        }\n        return result;\n    }\n\n    public get size(): number {\n        return this.handles.size;\n    }\n\n    public inputForHandle(handle: SliderHandle): HTMLInputElement | undefined {\n        if (this.handles.has(handle.handleName)) {\n            const { input } = this.getHandleElements(handle) || {};\n            return input;\n        }\n        /* c8 ignore next 2 */\n        throw new Error(`No input for handle \"${handle.name}\"`);\n    }\n\n    public requestUpdate(): void {\n        if (this.host.hasUpdated) {\n            this.host.requestUpdate();\n        }\n    }\n\n    /**\n     * It is possible for value attributes to be set programmatically. The <input>\n     * for a particular slider needs to have an opportunity to validate any such\n     * values\n     *\n     * @param handle Handle who's value needs validation\n     */\n    public setValueFromHandle(handle: SliderHandle): void {\n        const elements = this.getHandleElements(handle);\n        /* c8 ignore next */\n        if (!elements) return;\n\n        const { input } = elements;\n\n        input.valueAsNumber = handle.value;\n        this.requestUpdate();\n        // reset to potentially clamped value\n        handle.value = input.valueAsNumber;\n\n        if (handle.dragging) {\n            handle.dispatchInputEvent();\n        }\n    }\n\n    public handleHasChanged(handle: SliderHandle): void {\n        if (handle !== this.host) {\n            this.requestUpdate();\n        }\n    }\n\n    public formattedValueForHandle(model: ModelValue): string {\n        const { handle } = model;\n        const numberFormat = handle.numberFormat ?? this.host.numberFormat;\n        const _forcedUnit =\n            handle._forcedUnit === ''\n                ? this.host._forcedUnit\n                : handle._forcedUnit;\n        return (\n            handle.getAriaHandleText(model.value, numberFormat) + _forcedUnit\n        );\n    }\n\n    public get formattedValues(): Map<string, string> {\n        const result = new Map<string, string>();\n        for (const model of this.model) {\n            result.set(model.name, this.formattedValueForHandle(model));\n        }\n        return result;\n    }\n\n    public get focusElement(): HTMLElement {\n        const { input } = this.getActiveHandleElements();\n        if (\n            !input ||\n            (this.host.editable &&\n                !(input as InputWithModel).model.handle.dragging)\n        ) {\n            return this.host.numberField;\n        }\n        return input;\n    }\n\n    protected handleOrientation = (): void => {\n        this.updateBoundingRect();\n    };\n\n    public hostConnected(): void {\n        if ('orientation' in screen) {\n            screen.orientation.addEventListener(\n                'change',\n                this.handleOrientation\n            );\n        } else {\n            window.addEventListener(\n                'orientationchange',\n                this.handleOrientation\n            );\n        }\n    }\n\n    public hostDisconnected(): void {\n        if ('orientation' in screen) {\n            screen.orientation.removeEventListener(\n                'change',\n                this.handleOrientation\n            );\n        } else {\n            window.removeEventListener(\n                'orientationchange',\n                this.handleOrientation\n            );\n        }\n    }\n\n    public hostUpdate(): void {\n        this.updateModel();\n    }\n\n    // Since extractModelFromLightDom bails on the first un-upgraded handle,\n    // a maximum of one listener will be set up per extraction attempt.\n    private waitForUpgrade(handle: HTMLElement): boolean {\n        if (handle instanceof SliderHandle) {\n            return false;\n        }\n        handle.addEventListener(\n            'sp-slider-handle-ready',\n            () => this.extractModelFromLightDom(),\n            { once: true, passive: true }\n        );\n        return true;\n    }\n\n    private extractModelFromLightDom = (): void => {\n        let handles = [\n            ...this.host.querySelectorAll('[slot=\"handle\"]'),\n        ] as SliderHandle[];\n        if (handles.length === 0) {\n            handles = [this.host as SliderHandle];\n        }\n        // extractModelFromLightDom depends on slotted handles already having been upgraded\n        if (handles.some((h) => this.waitForUpgrade(h))) {\n            return;\n        }\n        this.handles = new Map();\n        this.handleOrder = [];\n        handles.forEach((handle, index) => {\n            /* c8 ignore next */\n            if (!handle.handleName?.length) {\n                handle.name = `handle${index + 1}`;\n            }\n            this.handles.set(handle.handleName, handle);\n            this.handleOrder.push(handle.handleName);\n            handle.handleController = this;\n        });\n        this.requestUpdate();\n    };\n\n    public get activeHandle(): string {\n        return this.handleOrder[this.handleOrder.length - 1];\n    }\n\n    public get activeHandleInputId(): string {\n        const active = this.activeHandle;\n        const index = this.model.findIndex((model) => model.name === active);\n        return `input-${index}`;\n    }\n\n    public activateHandle(name: string): void {\n        const index = this.handleOrder.findIndex((item) => item === name);\n        if (index >= 0) {\n            this.handleOrder.splice(index, 1);\n        }\n        this.handleOrder.push(name);\n    }\n\n    public get activeHandleModel(): ModelValue {\n        const active = this.activeHandle;\n        return this.model.find((model) => model.name === active)!;\n    }\n\n    private getActiveHandleElements(): HandleComponents {\n        const name = this.activeHandle;\n        const handleSlider = this.handles.get(name) as SliderHandle;\n        const elements = this.getHandleElements(\n            handleSlider\n        ) as HandleReference;\n        return { model: handleSlider, ...elements };\n    }\n\n    private getHandleElements(sliderHandle: SliderHandle): HandleReference {\n        if (!this.handleRefMap) {\n            this.handleRefMap = new WeakMap();\n\n            const inputNodes =\n                this.host.shadowRoot.querySelectorAll('.handle > input');\n            for (const inputNode of inputNodes) {\n                const input = inputNode as HTMLInputElement;\n                const handle = input.parentElement as HTMLElement;\n                const model = this.handles.get(\n                    handle.getAttribute('name') as string\n                );\n                if (model) {\n                    this.handleRefMap.set(model, { input, handle });\n                }\n            }\n        }\n\n        const components = this.handleRefMap.get(\n            sliderHandle\n        ) as HandleReference;\n        return components;\n    }\n\n    private clearHandleComponentCache(): void {\n        delete this.handleRefMap;\n    }\n\n    private _boundingClientRect?: DOMRect;\n\n    private get boundingClientRect(): DOMRect {\n        if (!this._boundingClientRect) {\n            this._boundingClientRect = this.host.track.getBoundingClientRect();\n        }\n        return this._boundingClientRect;\n    }\n\n    private updateBoundingRect(): void {\n        delete this._boundingClientRect;\n    }\n\n    /**\n     * Return the `input` and `model` associated with the event and\n     * whether the `input` is a `resolvedInput` meaning it was acquired\n     * from the `model` rather than the event.\n     */\n    protected extractDataFromEvent(event: PointerEvent): DataFromPointerEvent {\n        if (!this._activePointerEventData) {\n            let input = (event.target as Element).querySelector(\n                ':scope > .input'\n            ) as InputWithModel;\n            const resolvedInput = !input;\n            const model = input\n                ? input.model\n                : this.model.find((item) => item.name === this.activeHandle);\n            if (!input && !!model) {\n                input = model.handle.focusElement as InputWithModel;\n            }\n            this._activePointerEventData = {\n                input,\n                model,\n                resolvedInput,\n            };\n        }\n        return this._activePointerEventData;\n    }\n\n    private _activePointerEventData!: DataFromPointerEvent | undefined;\n\n    /**\n     * @description check for defaultvalue(value) property in sp-slider and reset on double click on sliderHandle\n     * @param event\n     */\n    public handleDoubleClick(event: PointerEvent): void {\n        const input = (event.target as Element).querySelector(\n            '.input'\n        ) as InputWithModel;\n\n        if (input.model?.handle.defaultValue !== undefined) {\n            input.model.handle.value = input.model.handle.defaultValue;\n            this.dispatchChangeEvent(input, input.model.handle);\n            input.model.handle.dispatchInputEvent();\n            this.requestUpdate();\n        }\n    }\n\n    public handlePointerdown(event: PointerEvent): void {\n        const { resolvedInput, model } = this.extractDataFromEvent(event);\n        if (!model || this.host.disabled || event.button !== 0) {\n            event.preventDefault();\n            return;\n        }\n        this.host.track.setPointerCapture(event.pointerId);\n        this.updateBoundingRect();\n        if (event.pointerType === 'mouse') {\n            this.host.labelEl.click();\n        }\n        this.draggingHandle = model.handle;\n        model.handle.dragging = true;\n        this.activateHandle(model.name);\n        if (resolvedInput) {\n            // When the input is resolved forward the pointer event to\n            // `handlePointermove` in order to update the value/UI becuase\n            // the pointer event was on the track not a handle\n            this.handlePointermove(event);\n        }\n        this.requestUpdate();\n    }\n\n    public handlePointerup(event: PointerEvent): void {\n        const { input, model } = this.extractDataFromEvent(event);\n        delete this._activePointerEventData;\n        if (!model) return;\n        if (event.pointerType === 'mouse') {\n            this.host.labelEl.click();\n        }\n        this.cancelDrag(model);\n        this.requestUpdate();\n        this.host.track.releasePointerCapture(event.pointerId);\n        this.dispatchChangeEvent(input, model.handle);\n    }\n\n    public handlePointermove(event: PointerEvent): void {\n        const { input, model } = this.extractDataFromEvent(event);\n        if (!model) return;\n        /* c8 ignore next 3 */\n        if (!this.draggingHandle) {\n            return;\n        }\n        input.value = this.calculateHandlePosition(event, model).toString();\n        model.handle.value = parseFloat(input.value);\n        this.host.indeterminate = false;\n        this.requestUpdate();\n    }\n\n    public cancelDrag(model?: ModelValue): void {\n        model =\n            model || this.model.find((item) => item.name === this.activeHandle);\n        if (!model) return;\n        model.handle.highlight = false;\n        delete this.draggingHandle;\n        model.handle.dragging = false;\n    }\n\n    /**\n     * Keep the slider value property in sync with the input element's value\n     */\n    private onInputChange = (event: Event): void => {\n        const input = event.target as InputWithModel;\n        input.model.handle.value = input.valueAsNumber;\n\n        this.requestUpdate();\n        this.dispatchChangeEvent(input, input.model.handle);\n    };\n\n    private onInputFocus = (event: Event): void => {\n        const input = event.target as InputWithModel;\n        let isFocusVisible;\n        try {\n            isFocusVisible =\n                input.matches(':focus-visible') ||\n                this.host.matches('.focus-visible');\n            /* c8 ignore next 3 */\n        } catch (error) {\n            isFocusVisible = this.host.matches('.focus-visible');\n        }\n        input.model.handle.highlight = isFocusVisible;\n        this.requestUpdate();\n    };\n\n    private onInputBlur = (event: Event): void => {\n        const input = event.target as InputWithModel;\n        input.model.handle.highlight = false;\n        this.requestUpdate();\n    };\n\n    private onInputKeydown = (event: KeyboardEvent): void => {\n        if (event.key == 'Escape') {\n            const input = event.target as InputWithModel;\n            if (\n                input.model.handle?.defaultValue !== undefined &&\n                input.model.handle.value !== input.model.handle.defaultValue\n            ) {\n                input.model.handle.value = input.model.handle.defaultValue;\n                input.model.handle.dispatchInputEvent();\n                this.dispatchChangeEvent(input, input.model.handle);\n                this.requestUpdate();\n                event.preventDefault();\n                event.stopPropagation();\n            }\n            return;\n        }\n        const input = event.target as InputWithModel;\n        input.model.handle.highlight = true;\n        this.requestUpdate();\n    };\n\n    private dispatchChangeEvent(\n        input: HTMLInputElement,\n        handle: SliderHandle\n    ): void {\n        input.valueAsNumber = handle.value;\n\n        const changeEvent = new Event('change', {\n            bubbles: true,\n            composed: true,\n        });\n\n        handle.dispatchEvent(changeEvent);\n    }\n\n    /**\n     * Returns the value under the cursor\n     * @param: PointerEvent on slider\n     * @return: Slider value that correlates to the position under the pointer\n     */\n    private calculateHandlePosition(\n        event: PointerEvent | MouseEvent,\n        model: ModelValue\n    ): number {\n        const rect = this.boundingClientRect;\n        const minOffset = rect.left;\n        const offset = event.clientX;\n        const size = rect.width;\n\n        const directionalOffset = this.host.isLTR\n            ? offset - minOffset\n            : size - (offset - minOffset);\n        const normalized = directionalOffset / size;\n\n        return model.normalization.fromNormalized(\n            normalized,\n            model.range.min,\n            model.range.max\n        );\n    }\n\n    public renderHandle(\n        model: ModelValue,\n        index: number,\n        zIndex: number,\n        isMultiHandle: boolean\n    ): TemplateResult {\n        const classes = {\n            handle: true,\n            dragging: this.draggingHandle?.handleName === model.name,\n            'handle-highlight': model.highlight,\n        };\n        const style = {\n            [this.host.isLTR ? 'left' : 'right']: `${\n                model.normalizedValue * 100\n            }%`,\n            'z-index': zIndex.toString(),\n            ...(isMultiHandle && {\n                'background-color': `var(--spectrum-slider-handle-background-color-${index}, var(--spectrum-slider-handle-background-color))`,\n                'border-color': `var(--spectrum-slider-handle-border-color-${index}, var(--spectrum-slider-handle-border-color))`,\n            }),\n        };\n        const ariaLabelledBy = isMultiHandle ? `label input-${index}` : 'label';\n        return html`\n            <div\n                class=${classMap(classes)}\n                name=${model.name}\n                style=${styleMap(style)}\n                role=\"presentation\"\n            >\n                <input\n                    type=\"range\"\n                    class=\"input\"\n                    id=\"input-${index}\"\n                    min=${model.clamp.min}\n                    max=${model.clamp.max}\n                    step=${model.step}\n                    value=${model.value}\n                    aria-disabled=${ifDefined(\n                        this.host.disabled ? 'true' : undefined\n                    )}\n                    tabindex=${ifDefined(this.host.editable ? -1 : undefined)}\n                    aria-label=${ifDefined(model.ariaLabel)}\n                    aria-labelledby=${ariaLabelledBy}\n                    aria-valuetext=${this.formattedValueForHandle(model)}\n                    aria-describedby=\"slider-description\"\n                    @change=${this.onInputChange}\n                    @focus=${this.onInputFocus}\n                    @blur=${this.onInputBlur}\n                    @keydown=${this.onInputKeydown}\n                    .model=${model}\n                />\n                <span id=\"slider-description\">\n                    Press escape or double click to reset the slider to its\n                    default value.\n                </span>\n            </div>\n        `;\n    }\n\n    public render(): TemplateResult[] {\n        this.clearHandleComponentCache();\n        return this.model.map((model, index) => {\n            const zIndex = this.handleOrder.indexOf(model.name) + 2;\n            return this.renderHandle(\n                model,\n                index,\n                zIndex,\n                this.model.length > 1\n            );\n        });\n    }\n\n    /**\n     * Returns a list of track segment [start, end] tuples where the values are\n     * normalized to be between 0 and 1.\n     * @returns A list of track segment tuples [start, end]\n     */\n    public trackSegments(): [number, number][] {\n        const values = this.model.map((model) => model.normalizedValue);\n        values.sort((a, b) => a - b);\n\n        // The first segment always starts at 0\n        values.unshift(0);\n        return values.map((value, index, array) => [\n            value,\n            array[index + 1] ?? 1,\n        ]);\n    }\n\n    private updateModel(): void {\n        const handles = [...this.handles.values()];\n\n        const getRangeAndClamp = (index: number): RangeAndClamp => {\n            const handle = handles[index];\n            const previous = handles[index - 1];\n            const next = handles[index + 1];\n\n            const min =\n                typeof handle.min === 'number'\n                    ? handle.min\n                    : (this.host.min as number);\n            const max =\n                typeof handle.max === 'number'\n                    ? handle.max\n                    : (this.host.max as number);\n\n            const result: RangeAndClamp = {\n                range: { min: min, max: max },\n                clamp: { min: min, max: max },\n            };\n\n            if (handle.min === 'previous') {\n                if (previous) {\n                    for (let j = index - 1; j >= 0; j--) {\n                        const item = handles[j];\n                        if (typeof item.min === 'number') {\n                            result.range.min = item.min;\n                            break;\n                        }\n                    }\n                    result.clamp.min = Math.max(\n                        previous.value,\n                        result.range.min\n                    );\n                }\n                if (window.__swc.DEBUG) {\n                    if (!previous) {\n                        window.__swc.warn(\n                            this.host,\n                            '<sp-slider-handle> elements that are the first child of an <sp-slider> element cannot have attribute \"min=\\'previous\\'\"`',\n                            'https://opensource.adobe.com/spectrum-web-components/components/slider-handle/#multi-handle-slider-with-ordered-handles'\n                        );\n                    }\n                }\n            }\n            if (handle.max === 'next') {\n                if (next) {\n                    for (let j = index + 1; j < handles.length; j++) {\n                        const item = handles[j];\n                        if (typeof item.max === 'number') {\n                            result.range.max = item.max;\n                            break;\n                        }\n                    }\n                    result.clamp.max = Math.min(next.value, result.range.max);\n                }\n                if (window.__swc.DEBUG) {\n                    if (!next) {\n                        window.__swc.warn(\n                            this.host,\n                            '<sp-slider-handle> elements that are the last child of an <sp-slider> element cannot have attribute \"max=\\'next\\'\"',\n                            'https://opensource.adobe.com/spectrum-web-components/components/slider-handle/#multi-handle-slider-with-ordered-handles'\n                        );\n                    }\n                }\n            }\n            return result;\n        };\n\n        const modelValues = handles.map((handle, index) => {\n            const rangeAndClamp = getRangeAndClamp(index);\n            const { toNormalized } = handle.normalization;\n            const clampedValue = Math.max(\n                Math.min(handle.value, rangeAndClamp.clamp.max),\n                rangeAndClamp.clamp.min\n            );\n            const normalizedValue = toNormalized(\n                clampedValue,\n                rangeAndClamp.range.min,\n                rangeAndClamp.range.max\n            );\n            const model = {\n                name: handle.handleName,\n                value: clampedValue,\n                normalizedValue,\n                highlight: handle.highlight,\n                step: handle.step ?? this.host.step,\n                normalization: handle.normalization,\n                handle,\n                ariaLabel:\n                    handle !== this.host && handle?.label.length > 0\n                        ? handle.label\n                        : undefined,\n                ...rangeAndClamp,\n            };\n            return model;\n        });\n\n        this.model = modelValues;\n    }\n\n    public async handleUpdatesComplete(): Promise<void> {\n        const updates = [...this.handles.values()]\n            .filter((handle) => handle !== this.host)\n            .map((handle) => handle.updateComplete);\n        await Promise.all(updates);\n    }\n}\n"],
  "mappings": "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",
  "names": ["html", "classMap", "ifDefined", "styleMap", "MutationController", "SliderHandle", "host", "handles", "h", "handle", "index", "_a", "event", "input", "isFocusVisible", "error", "result", "model", "elements", "numberFormat", "_forcedUnit", "active", "name", "item", "handleSlider", "sliderHandle", "inputNodes", "inputNode", "resolvedInput", "changeEvent", "rect", "minOffset", "offset", "size", "normalized", "zIndex", "isMultiHandle", "classes", "style", "ariaLabelledBy", "values", "a", "b", "value", "array", "getRangeAndClamp", "previous", "next", "min", "max", "j", "modelValues", "rangeAndClamp", "toNormalized", "clampedValue", "normalizedValue", "updates"]
}
