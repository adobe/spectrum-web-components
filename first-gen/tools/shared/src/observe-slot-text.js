"use strict";var h=Object.defineProperty;var x=Object.getOwnPropertyDescriptor;var u=(c,e,s,o)=>{for(var t=o>1?void 0:o?x(e,s):e,a=c.length-1,i;a>=0;a--)(i=c[a])&&(t=(o?i(e,s,t):i(t))||t);return o&&t&&h(e,s,t),t};import{property as T,queryAssignedNodes as b}from"@spectrum-web-components/base/src/decorators.js";import{MutationController as v}from"@lit-labs/observers/mutation-controller.js";const p=Symbol("assignedNodes");export function ObserveSlotText(c,e,s=[]){var a,i;const o=f=>m=>f.matches(m);class t extends(i=c,a=p,i){constructor(...n){super(n);this.slotHasContent=!1;new v(this,{config:{characterData:!0,subtree:!0},callback:d=>{for(const r of d)if(r.type==="characterData"){this.manageTextObservedSlot();return}}})}manageTextObservedSlot(){if(!this[p])return;const n=[...this[p]].filter(d=>{const r=d;return r.tagName?!s.some(o(r)):r.textContent?r.textContent.trim():!1});this.slotHasContent=n.length>0}update(n){if(!this.hasUpdated){const{childNodes:d}=this,r=[...d].filter(g=>{const l=g;return l.tagName?s.some(o(l))?!1:e?l.getAttribute("slot")===e:!l.hasAttribute("slot"):l.textContent?l.textContent.trim():!1});this.slotHasContent=r.length>0}super.update(n)}firstUpdated(n){super.firstUpdated(n),this.updateComplete.then(()=>{this.manageTextObservedSlot()})}}return u([T({type:Boolean,attribute:!1})],t.prototype,"slotHasContent",2),u([b({slot:e,flatten:!0})],t.prototype,a,2),t}
//# sourceMappingURL=observe-slot-text.js.map
