{
  "version": 3,
  "sources": ["ColorController.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type { ReactiveElement } from 'lit';\nimport Color from 'colorjs.io';\nimport type {\n    ColorObject,\n    ColorTypes as DefaultColorTypes,\n} from 'colorjs.io/types/src/color';\nimport type ColorSpace from 'colorjs.io/types/src/space';\n\n/**\n * Represents various color types that can be used in the application.\n *\n * This type can be one of the following:\n * - `DefaultColorTypes`: A predefined set of color types.\n * - An object representing an RGBA color with properties:\n *   - `r`: Red component, can be a number or string.\n *   - `g`: Green component, can be a number or string.\n *   - `b`: Blue component, can be a number or string.\n *   - `a` (optional): Alpha component, can be a number or string.\n * - An object representing an HSLA color with properties:\n *   - `h`: Hue component, can be a number or string.\n *   - `s`: Saturation component, can be a number or string.\n *   - `l`: Lightness component, can be a number or string.\n *   - `a` (optional): Alpha component, can be a number or string.\n * - An object representing an HSVA color with properties:\n *   - `h`: Hue component, can be a number or string.\n *   - `s`: Saturation component, can be a number or string.\n *   - `v`: Value component, can be a number or string.\n *   - `a` (optional): Alpha component, can be a number or string.\n */\ntype ColorTypes =\n    | DefaultColorTypes\n    | {\n          r: number | string;\n          g: number | string;\n          b: number | string;\n          a?: number | string;\n      }\n    | {\n          h: number | string;\n          s: number | string;\n          l: number | string;\n          a?: number | string;\n      }\n    | {\n          h: number | string;\n          s: number | string;\n          v: number | string;\n          a?: number | string;\n      };\n\nexport type { Color, ColorTypes };\n\ntype ColorValidationResult = {\n    spaceId: string | null;\n    coords: number[];\n    isValid: boolean;\n    alpha: number;\n};\n\n/**\n * The `ColorController` class is responsible for managing and validating color values\n * in various color spaces (RGB, HSL, HSV, Hex). It provides methods to set, get, and\n * validate colors, as well as convert between different color formats.\n *\n * @class\n * @property {Color} color - Gets or sets the current color value.\n * @property {ColorTypes} colorValue - Gets the color value in various formats based on the original color input.\n * @property {number} hue - Gets or sets the hue value of the current color.\n *\n * @method validateColorString(color: string): ColorValidationResult - Validates a color string and returns the validation result.\n * @method getColor(format: string | ColorSpace): ColorObject - Converts the current color to the specified format.\n * @method getHslString(): string - Returns the current color in HSL string format.\n * @method savePreviousColor(): void - Saves the current color as the previous color.\n * @method restorePreviousColor(): void - Restores the previous color.\n *\n * @constructor\n * @param {ReactiveElement} host - The host element that uses this controller.\n * @param {Object} [options] - Optional configuration options.\n * @param {string} [options.manageAs] - Specifies the color space to manage the color as.\n */\n\nexport class ColorController {\n    get color(): Color {\n        return this._color;\n    }\n\n    /**\n     * Validates a color string and returns a result indicating the color space,\n     * coordinates, alpha value, and whether the color is valid.\n     *\n     * @param color - The color string to validate. Supported formats include:\n     *  - RGB: `rgb(r, g, b)`, `rgba(r, g, b, a)`, `rgb r g b`, `rgba r g b a`\n     *  - HSL: `hsl(h, s, l)`, `hsla(h, s, l, a)`, `hsl h s l`, `hsla h s l a`\n     *  - HSV: `hsv(h, s, v)`, `hsva(h, s, v, a)`, `hsv h s v`, `hsva h s v a`\n     *  - HEX: `#rgb`, `#rgba`, `#rrggbb`, `#rrggbbaa`\n     *\n     * @returns An object containing the following properties:\n     *  - `spaceId`: The color space identifier (`'srgb'`, `'hsl'`, or `'hsv'`).\n     *  - `coords`: An array of numeric values representing the color coordinates.\n     *  - `alpha`: The alpha value of the color (0 to 1).\n     *  - `isValid`: A boolean indicating whether the color string is valid.\n     */\n    public validateColorString(color: string): ColorValidationResult {\n        const result: ColorValidationResult = {\n            spaceId: null,\n            coords: [0, 0, 0],\n            isValid: false,\n            alpha: 1,\n        };\n\n        // RGB color formats\n        const rgbRegExpArray = [\n            // With commas\n            /rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d*\\.?\\d+)\\s*\\)/i, // rgba(r, g, b, a)\n            /rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)/i, // rgb(r, g, b)\n\n            // With spaces\n            /^rgba\\s+(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})\\s+(0|0?\\.\\d+|1)\\s*$/i, // rgba r g b a\n            /^rgb\\s+(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})\\s*$/i, // rgb r g b\n\n            // Spaces inside parentheses\n            /^rgba\\(\\s*(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d*\\.?\\d+)\\s*\\)$/i, // rgba(r g b a)\n            /^rgb\\(\\s*(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})\\s*\\)$/i, // rgb(r g b)\n\n            // Percentage values\n            /rgb\\(\\s*(100|[0-9]{1,2}%)\\s*,\\s*(100|[0-9]{1,2}%)\\s*,\\s*(100|[0-9]{1,2}%)\\s*\\)/i, // rgb(r%, g%, b%)\n            /rgba\\(\\s*(100|[0-9]{1,2})%\\s*,\\s*(100|[0-9]{1,2})%\\s*,\\s*(100|[0-9]{1,2})%\\s*,\\s*(\\d*\\.?\\d+)\\s*\\)/i, // rgba(r%, g%, b%, a)\n        ];\n\n        // HSL color formats\n        const hslRegExpArray = [\n            // With commas\n            /hsla\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d*\\.?\\d+)\\s*\\)/i, // hsla(h, s, l, a)\n            /hsl\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*\\)/i, // hsl(h, s, l)\n\n            // With spaces\n            /^hsla\\s+(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s+(\\d*\\.?\\d+)\\s*$/i, // hsla h s l a\n            /^hsl\\s+(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s*$/i, // hsl h s l\n\n            // Spaces inside parentheses\n            /^hsla\\(\\s*(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s+(\\d*\\.?\\d+)\\s*\\)$/i, // hsla(h s l a)\n            /^hsl\\(\\s*(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s*\\)$/i, // hsl(h s l)\n        ];\n\n        // HSV color formats\n        const hsvRegExpArray = [\n            // With commas\n            /hsva\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d*\\.?\\d+)\\s*\\)/i, // hsva(h, s, v, a)\n            /hsv\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*\\)/i, // hsv(h, s, v)\n\n            // With spaces\n            /^hsva\\s+(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s+(\\d*\\.?\\d+)\\s*$/i, // hsva h s v a\n            /^hsv\\s+(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s*$/i, // hsv h s v\n\n            // Spaces inside parentheses\n            /^hsva\\(\\s*(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s+(\\d*\\.?\\d+)\\s*\\)$/i, // hsva(h s v a)\n            /^hsv\\(\\s*(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s*\\)$/i, // hsv(h s v)\n        ];\n\n        // HEX color formats\n        const hexRegExpArray = [\n            /^#([A-Fa-f0-9]{6})([A-Fa-f0-9]{2})?$/, // 6-digit hex with optional hex alpha\n            /^#([A-Fa-f0-9]{3})([A-Fa-f0-9]{1})?$/, // 3-digit hex with optional hex alpha\n        ];\n\n        const rgbaMatch = rgbRegExpArray\n            .find((regex) => regex.test(color))\n            ?.exec(color);\n        const hslaMatch = hslRegExpArray\n            .find((regex) => regex.test(color))\n            ?.exec(color);\n        const hsvaMatch = hsvRegExpArray\n            .find((regex) => regex.test(color))\n            ?.exec(color);\n        const hexMatch = hexRegExpArray\n            .find((regex) => regex.test(color))\n            ?.exec(color);\n\n        if (rgbaMatch) {\n            const [, r, g, b, a] = rgbaMatch.filter(\n                (element) => typeof element === 'string'\n            );\n            const alpha = a === undefined ? 1 : Number(a);\n            const processValue = (value: string): number => {\n                if (value.includes('%')) {\n                    return Number(value.replace('%', '')) / 100;\n                } else {\n                    return Number(value) / 255;\n                }\n            };\n            const numericR = processValue(r);\n            const numericG = processValue(g);\n            const numericB = processValue(b);\n\n            result.spaceId = 'srgb';\n            result.coords = [numericR, numericG, numericB];\n            result.alpha = alpha;\n            result.isValid =\n                numericR >= 0 &&\n                numericR <= 1 &&\n                numericG >= 0 &&\n                numericG <= 1 &&\n                numericB >= 0 &&\n                numericB <= 1 &&\n                alpha >= 0 &&\n                alpha <= 1;\n        } else if (hslaMatch) {\n            const [, h, s, l, a] = hslaMatch;\n            const values = [h, s, l, a === undefined ? '1' : a].map((value) =>\n                Number(value.replace(/[^\\d.]/g, ''))\n            );\n            const [numericH, numericS, numericL, numericA] = values;\n\n            result.spaceId = 'hsl';\n            result.coords = [numericH, numericS, numericL];\n            result.alpha = numericA;\n            result.isValid =\n                numericH >= 0 &&\n                numericH <= 360 &&\n                numericS >= 0 &&\n                numericS <= 100 &&\n                numericL >= 0 &&\n                numericL <= 100 &&\n                numericA >= 0 &&\n                numericA <= 1;\n        } else if (hsvaMatch) {\n            const [, h, s, v, a] = hsvaMatch;\n            const values = [h, s, v, a === undefined ? '1' : a].map((value) =>\n                Number(value.replace(/[^\\d.]/g, ''))\n            );\n            const [numericH, numericS, numericV, numericA] = values;\n\n            result.spaceId = 'hsv';\n            result.coords = [numericH, numericS, numericV];\n            result.alpha = numericA;\n            result.isValid =\n                numericH >= 0 &&\n                numericH <= 360 &&\n                numericS >= 0 &&\n                numericS <= 100 &&\n                numericV >= 0 &&\n                numericV <= 100 &&\n                numericA >= 0 &&\n                numericA <= 1;\n        } else if (hexMatch) {\n            const [, hex, alphaHex] = hexMatch;\n\n            // Function to process 2-digit or repeated 1-digit hex\n            const processHex = (hex: string): number => {\n                // For 3-digit hex values, repeat each digit\n                if (hex.length === 1) {\n                    hex = hex + hex;\n                }\n                return parseInt(hex, 16) / 255;\n            };\n\n            // Handle both 3-digit and 6-digit hex\n            let numericR, numericG, numericB;\n            if (hex.length === 3) {\n                // 3-digit hex (e.g., #3a7 -> #33aa77)\n                numericR = processHex(hex.substring(0, 1));\n                numericG = processHex(hex.substring(1, 2));\n                numericB = processHex(hex.substring(2, 3));\n            } else {\n                // 6-digit hex (e.g., #33aa77)\n                numericR = processHex(hex.substring(0, 2));\n                numericG = processHex(hex.substring(2, 4));\n                numericB = processHex(hex.substring(4, 6));\n            }\n\n            // Process hex alpha if provided (convert from 0-255 to 0-1)\n            const numericA = alphaHex ? processHex(alphaHex) : 1;\n\n            // Validate the color values\n            result.spaceId = 'srgb';\n            result.coords = [numericR, numericG, numericB];\n            result.alpha = numericA;\n            result.isValid =\n                numericR >= 0 &&\n                numericR <= 1 &&\n                numericG >= 0 &&\n                numericG <= 1 &&\n                numericB >= 0 &&\n                numericB <= 1 &&\n                numericA >= 0 &&\n                numericA <= 1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Represents the color state of the component.\n     * Initialized with an HSV color model with hue 0, saturation 100, and value 100, and an alpha value of 1.\n     *\n     * @private\n     * @type {Color}\n     */\n    private _color: Color = new Color('hsv', [0, 100, 100], 1);\n\n    /**\n     * Represents the original color value provided by the user.\n     *\n     * @private\n     * @type {ColorTypes}\n     */\n    private _colorOrigin!: ColorTypes;\n\n    /**\n     * Gets the original color value provided by the user.\n     *\n     * @returns {ColorTypes} The original color value.\n     */\n    get colorOrigin(): ColorTypes {\n        return this._colorOrigin;\n    }\n\n    /**\n     * Sets the original color value provided by the user.\n     *\n     * @param {ColorTypes} colorOrigin - The original color value to set.\n     */\n    set colorOrigin(colorOrigin: ColorTypes) {\n        this._colorOrigin = colorOrigin;\n    }\n\n    /**\n     * An optional string property that specifies how the color should be managed(its value is the name of color space in which color object will be managed).\n     * This property can be used to define a specific management strategy or identifier.\n     */\n    private manageAs?: string;\n\n    /**\n     * Stores the previous color value.\n     * This is used to keep track of the color before any changes are made.\n     *\n     * @private\n     */\n    private _previousColor!: Color;\n\n    /**\n     * Private helper method to convert RGB color to hex format with optional alpha\n     *\n     * @private\n     * @param {boolean} includeHash - Whether to include the # prefix in the returned string\n     * @param {boolean} includeAlpha - Whether to include the alpha channel in the returned string\n     * @returns {string} The color in hex format\n     */\n    private _getHexString(includeHash: boolean, includeAlpha: boolean): string {\n        const { r, g, b } = (this._color.to('srgb') as Color).srgb;\n        const a = this._color.alpha;\n\n        const rHex = Math.round(r * 255)\n            .toString(16)\n            .padStart(2, '0');\n        const gHex = Math.round(g * 255)\n            .toString(16)\n            .padStart(2, '0');\n        const bHex = Math.round(b * 255)\n            .toString(16)\n            .padStart(2, '0');\n        const aHex = Math.round(a * 255)\n            .toString(16)\n            .padStart(2, '0');\n\n        return `${includeHash ? '#' : ''}${rHex}${gHex}${bHex}${includeAlpha ? aHex : ''}`;\n    }\n\n    /**\n     * Sets the color value for the controller. The color can be provided in various formats:\n     * - A string representing a color name, hex code, or other color format.\n     * - An instance of the `Color` class.\n     * - An object containing color properties such as `h`, `s`, `l`, `v`, `r`, `g`, `b`, and optionally `a`.\n     *\n     * The method validates and parses the input color, converting it to a `Color` instance.\n     * If the color is invalid, it attempts to parse it as a hex code or returns without setting a new color.\n     *\n     * @param {ColorTypes} color - The color value to set. It can be a string, an instance of `Color`, or an object with color properties.\n     */\n    set color(color: ColorTypes) {\n        this._colorOrigin = color;\n        let newColor!: Color;\n        if (typeof color === 'string') {\n            const colorValidationResult = this.validateColorString(\n                color as string\n            );\n            if (colorValidationResult.isValid) {\n                const [coord1, coord2, coord3] = colorValidationResult.coords;\n                newColor = new Color(\n                    `${colorValidationResult.spaceId}`,\n                    [coord1, coord2, coord3],\n                    colorValidationResult.alpha\n                );\n            } else {\n                try {\n                    Color.parse(color);\n                } catch (error) {\n                    try {\n                        newColor = new Color(`#${color}`);\n                    } catch (error) {\n                        return;\n                    }\n                }\n            }\n        } else if (color instanceof Color) {\n            newColor = color;\n        } else if (!Array.isArray(color)) {\n            const { h, s, l, v, r, g, b, a } = color as {\n                h: string;\n                s: string;\n                l: string;\n                v: string;\n                r: string;\n                g: string;\n                b: string;\n                a?: string;\n            };\n            if (typeof h !== 'undefined' && typeof s !== 'undefined') {\n                const lv = l ?? v;\n                newColor = new Color(\n                    typeof l !== 'undefined' ? 'hsl' : 'hsv',\n                    [\n                        parseFloat(h),\n                        typeof s !== 'string' ? s * 100 : parseFloat(s),\n                        typeof lv !== 'string' ? lv * 100 : parseFloat(lv),\n                    ],\n                    parseFloat(a || '1')\n                );\n            } else if (\n                typeof r !== 'undefined' &&\n                typeof g !== 'undefined' &&\n                typeof b !== 'undefined'\n            ) {\n                newColor = new Color(\n                    'srgb',\n                    [\n                        parseFloat(r) / 255,\n                        parseFloat(g) / 255,\n                        parseFloat(b) / 255,\n                    ],\n                    parseFloat(a || '1')\n                );\n            }\n        }\n\n        if (!newColor) {\n            newColor = new Color(color as DefaultColorTypes);\n        }\n\n        if (this.manageAs) {\n            this._color = newColor.to(this.manageAs) as Color;\n        } else {\n            this._color = newColor;\n        }\n        this.host.requestUpdate();\n    }\n\n    /**\n     * Gets the color value in various formats based on the original color input.\n     *\n     * The method determines the color space of the original color input and converts\n     * the color to the appropriate format. The supported color spaces are:\n     * - HSV (Hue, Saturation, Value)\n     * - HSL (Hue, Saturation, Lightness)\n     * - Hexadecimal (with or without alpha)\n     * - RGB (Red, Green, Blue) with optional alpha\n     *\n     * @returns {ColorTypes} The color value in the appropriate format.\n     *\n     * The method handles the following cases:\n     * - If the original color input is a string, it checks the prefix to determine the color space.\n     * - If the original color input is an object, it checks the properties to determine the color space.\n     * - If the original color input is not provided, it defaults to the current color space of the color object.\n     *\n     * The returned color value can be in one of the following formats:\n     * - `hsv(h, s%, v%)` or `hsva(h, s%, v%, a)`\n     * - `hsl(h, s%, l%)` or `hsla(h, s%, l%, a)`\n     * - `#rrggbb` or `#rrggbbaa`\n     * - `rgb(r, g, b)` or `rgba(r, g, b, a)`\n     * - `{ h, s, v, a }` for HSV object\n     * - `{ h, s, l, a }` for HSL object\n     * - `{ r, g, b, a }` for RGB object\n     */\n    get colorValue(): ColorTypes {\n        if (typeof this._colorOrigin === 'string') {\n            let spaceId = '';\n            if (this._colorOrigin.startsWith('#')) {\n                spaceId = 'hex string';\n            } else if (this._colorOrigin.startsWith('rgb')) {\n                spaceId = 'rgb';\n            } else if (this._colorOrigin.startsWith('hsl')) {\n                spaceId = 'hsl';\n            } else if (this._colorOrigin.startsWith('hsv')) {\n                spaceId = 'hsv';\n            } else {\n                spaceId = 'hex';\n            }\n            switch (spaceId) {\n                case 'hsv': {\n                    const hadAlpha = this._colorOrigin[3] === 'a';\n                    const { h, s, v } = (this._color.to('hsv') as Color).hsv;\n                    const a = this._color.alpha;\n                    return `hsv${hadAlpha ? `a` : ''}(${Math.round(\n                        h\n                    )}, ${Math.round(s)}%, ${Math.round(v)}%${\n                        hadAlpha ? `, ${a}` : ''\n                    })`;\n                }\n                case 'hsl': {\n                    const hadAlpha = this._colorOrigin[3] === 'a';\n                    const { h, s, l } = (this._color.to('hsl') as Color).hsl;\n                    const a = this._color.alpha;\n                    return `hsl${hadAlpha ? `a` : ''}(${Math.round(\n                        h\n                    )}, ${Math.round(s)}%, ${Math.round(l)}%${\n                        hadAlpha ? `, ${a}` : ''\n                    })`;\n                }\n                case 'hex string': {\n                    // Check if the original input included alpha\n                    const hadAlpha =\n                        this._colorOrigin.length === 9 || // #RRGGBBAA format\n                        this._colorOrigin.length === 5; // #RGBA format\n                    return this._getHexString(true, hadAlpha);\n                }\n                case 'hex': {\n                    // Check if the original input included alpha\n                    const hadAlpha =\n                        this._colorOrigin.length === 8 || // RRGGBBAA format (no #)\n                        this._colorOrigin.length === 4; // RGBA format (no #)\n                    return this._getHexString(false, hadAlpha);\n                }\n                //rgb\n                default: {\n                    const { r, g, b } = (this._color.to('srgb') as Color).srgb;\n                    const hadAlpha = this._colorOrigin[3] === 'a';\n                    const a = this._color.alpha;\n                    if (this._colorOrigin.search('%') > -1) {\n                        return `rgb${hadAlpha ? `a` : ''}(${Math.round(r * 100)}%, ${Math.round(\n                            g * 100\n                        )}%, ${Math.round(b * 100)}%${hadAlpha ? `,${Math.round(a * 100)}%` : ''})`;\n                    }\n                    return `rgb${hadAlpha ? `a` : ''}(${Math.round(r * 255)}, ${Math.round(\n                        g * 255\n                    )}, ${Math.round(b * 255)}${hadAlpha ? `, ${a}` : ''})`;\n                }\n            }\n        }\n        let spaceId;\n        if (this._colorOrigin) {\n            try {\n                ({ spaceId } = new Color(\n                    this._colorOrigin as DefaultColorTypes\n                ));\n            } catch (error) {\n                const { h, s, l, v, r, g, b } = this._colorOrigin as {\n                    h: string;\n                    s: string;\n                    l: string;\n                    v: string;\n                    r: string;\n                    g: string;\n                    b: string;\n                };\n                if (\n                    typeof h !== 'undefined' &&\n                    typeof s !== 'undefined' &&\n                    typeof l !== 'undefined'\n                ) {\n                    spaceId = 'hsl';\n                } else if (\n                    typeof h !== 'undefined' &&\n                    typeof s !== 'undefined' &&\n                    typeof v !== 'undefined'\n                ) {\n                    spaceId = 'hsv';\n                } else if (\n                    typeof r !== 'undefined' &&\n                    typeof g !== 'undefined' &&\n                    typeof b !== 'undefined'\n                ) {\n                    spaceId = 'srgb';\n                }\n            }\n        } else {\n            ({ spaceId } = this.color);\n        }\n        switch (spaceId) {\n            case 'hsv': {\n                const { h, s, v } = (this._color.to('hsv') as Color).hsv;\n                return {\n                    h,\n                    s: s / 100,\n                    v: v / 100,\n                    a: this._color.alpha,\n                };\n            }\n            case 'hsl': {\n                const { h, s, l } = (this._color.to('hsl') as Color).hsl;\n                return {\n                    h,\n                    s: s / 100,\n                    l: l / 100,\n                    a: this._color.alpha,\n                };\n            }\n            case 'srgb': {\n                const { r, g, b } = (this._color.to('srgb') as Color).srgb;\n                if (\n                    this._colorOrigin &&\n                    typeof (this._colorOrigin as { r: string }).r ===\n                        'string' &&\n                    (this._colorOrigin as { r: string }).r.search('%')\n                ) {\n                    return {\n                        r: `${Math.round(r * 255)}%`,\n                        g: `${Math.round(g * 255)}%`,\n                        b: `${Math.round(b * 255)}%`,\n                        a: this._color.alpha,\n                    };\n                }\n                return {\n                    r: Math.round(r * 255),\n                    g: Math.round(g * 255),\n                    b: Math.round(b * 255),\n                    a: this._color.alpha,\n                };\n            }\n        }\n        return this._color;\n    }\n\n    protected host: ReactiveElement;\n\n    /**\n     * Gets the hue value of the current color in HSL format.\n     *\n     * @returns {number} The hue value as a number.\n     */\n    get hue(): number {\n        return Number((this._color.to('hsl') as Color).hsl.h);\n    }\n\n    /**\n     * Sets the hue value of the color and requests an update from the host.\n     *\n     * @param hue - The hue value to set, represented as a number.\n     */\n    set hue(hue: number) {\n        this._color.set('h', hue);\n        this.host.requestUpdate();\n    }\n\n    /**\n     * Creates an instance of ColorController.\n     *\n     * @param host - The ReactiveElement that this controller is associated with.\n     * @param options - An object containing optional parameters.\n     * @param options.manageAs - A string to manage the controller as a specific type.\n     */\n    constructor(\n        host: ReactiveElement,\n        {\n            manageAs,\n        }: {\n            manageAs?: string;\n        } = {}\n    ) {\n        this.host = host;\n        this.manageAs = manageAs;\n    }\n\n    /**\n     * Converts the current color to the specified format.\n     *\n     * @param format - The desired color format. It can be a string representing one of the valid formats\n     * ('srgb', 'hsva', 'hsv', 'hsl', 'hsla') or a ColorSpace object.\n     * @returns The color object in the specified format.\n     * @throws Will throw an error if the provided format is not a valid string format.\n     */\n    getColor(format: string | ColorSpace): ColorObject {\n        const validFormats = ['srgb', 'hsva', 'hsv', 'hsl', 'hsla'];\n        if (typeof format === 'string' && !validFormats.includes(format)) {\n            throw new Error('not a valid format');\n        }\n\n        return this._color.to(format);\n    }\n\n    /**\n     * Converts the current color to an HSL string representation.\n     *\n     * @returns {string} The HSL string representation of the current color.\n     */\n    getHslString(): string {\n        return this._color.to('hsl').toString();\n    }\n\n    /**\n     * Saves the current color state by cloning the current color and storing it\n     * as the previous color. This allows for the ability to revert to the previous\n     * color state if needed.\n     *\n     * @returns {void}\n     */\n    savePreviousColor(): void {\n        this._previousColor = this._color.clone();\n    }\n\n    /**\n     * Restores the color to the previously saved color value.\n     *\n     * This method sets the current color (`_color`) to the previously stored color (`_previousColor`).\n     */\n    restorePreviousColor(): void {\n        this._color = this._previousColor;\n    }\n}\n"],
  "mappings": "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",
  "names": ["Color", "host", "manageAs", "color", "_a", "_b", "_c", "_d", "result", "rgbRegExpArray", "hslRegExpArray", "hsvRegExpArray", "hexRegExpArray", "rgbaMatch", "regex", "hslaMatch", "hsvaMatch", "hexMatch", "r", "g", "b", "a", "element", "alpha", "processValue", "value", "numericR", "numericG", "numericB", "h", "s", "l", "values", "numericH", "numericS", "numericL", "numericA", "v", "numericV", "hex", "alphaHex", "processHex", "colorOrigin", "includeHash", "includeAlpha", "rHex", "gHex", "bHex", "aHex", "newColor", "colorValidationResult", "coord1", "coord2", "coord3", "error", "lv", "spaceId", "hadAlpha", "hue", "format"]
}
