{
  "version": 3,
  "sources": ["ColorController.ts"],
  "sourcesContent": ["/**\n * Copyright 2025 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport type { ReactiveElement } from 'lit';\nimport Color from 'colorjs.io';\nimport type {\n    ColorObject,\n    ColorTypes as DefaultColorTypes,\n} from 'colorjs.io/types/src/color';\nimport type ColorSpace from 'colorjs.io/types/src/space';\n\n/**\n * Represents various color types that can be used in the application.\n *\n * This type can be one of the following:\n * - `DefaultColorTypes`: A predefined set of color types.\n * - An object representing an RGBA color with properties:\n *   - `r`: Red component, can be a number or string.\n *   - `g`: Green component, can be a number or string.\n *   - `b`: Blue component, can be a number or string.\n *   - `a` (optional): Alpha component, can be a number or string.\n * - An object representing an HSLA color with properties:\n *   - `h`: Hue component, can be a number or string.\n *   - `s`: Saturation component, can be a number or string.\n *   - `l`: Lightness component, can be a number or string.\n *   - `a` (optional): Alpha component, can be a number or string.\n * - An object representing an HSVA color with properties:\n *   - `h`: Hue component, can be a number or string.\n *   - `s`: Saturation component, can be a number or string.\n *   - `v`: Value component, can be a number or string.\n *   - `a` (optional): Alpha component, can be a number or string.\n */\ntype ColorTypes =\n    | DefaultColorTypes\n    | {\n          r: number | string;\n          g: number | string;\n          b: number | string;\n          a?: number | string;\n      }\n    | {\n          h: number | string;\n          s: number | string;\n          l: number | string;\n          a?: number | string;\n      }\n    | {\n          h: number | string;\n          s: number | string;\n          v: number | string;\n          a?: number | string;\n      };\n\nexport type { Color, ColorTypes };\n\ntype ColorValidationResult = {\n    spaceId: string | null;\n    coords: number[];\n    isValid: boolean;\n    alpha: number;\n};\n\n/**\n * The `ColorController` class is responsible for managing and validating color values\n * in various color spaces (RGB, HSL, HSV, Hex). It provides methods to set, get, and\n * validate colors, as well as convert between different color formats.\n *\n * @class\n * @property {Color} color - Gets or sets the current color value.\n * @property {ColorTypes} colorValue - Gets the color value in various formats based on the original color input.\n * @property {number} hue - Gets or sets the hue value of the current color.\n *\n * @method validateColorString(color: string): ColorValidationResult - Validates a color string and returns the validation result.\n * @method getColor(format: string | ColorSpace): ColorObject - Converts the current color to the specified format.\n * @method getHslString(): string - Returns the current color in HSL string format.\n * @method savePreviousColor(): void - Saves the current color as the previous color.\n * @method restorePreviousColor(): void - Restores the previous color.\n *\n * @constructor\n * @param {ReactiveElement} host - The host element that uses this controller.\n * @param {Object} [options] - Optional configuration options.\n * @param {string} [options.manageAs] - Specifies the color space to manage the color as.\n */\n\nexport class ColorController {\n    get color(): Color {\n        return this._color;\n    }\n\n    /**\n     * Validates a color string and returns a result indicating the color space,\n     * coordinates, alpha value, and whether the color is valid.\n     *\n     * @param color - The color string to validate. Supported formats include:\n     *  - RGB: `rgb(r, g, b)`, `rgba(r, g, b, a)`, `rgb r g b`, `rgba r g b a`\n     *  - HSL: `hsl(h, s, l)`, `hsla(h, s, l, a)`, `hsl h s l`, `hsla h s l a`\n     *  - HSV: `hsv(h, s, v)`, `hsva(h, s, v, a)`, `hsv h s v`, `hsva h s v a`\n     *  - HEX: `#rgb`, `#rgba`, `#rrggbb`, `#rrggbbaa`\n     *\n     * @returns An object containing the following properties:\n     *  - `spaceId`: The color space identifier (`'srgb'`, `'hsl'`, or `'hsv'`).\n     *  - `coords`: An array of numeric values representing the color coordinates.\n     *  - `alpha`: The alpha value of the color (0 to 1).\n     *  - `isValid`: A boolean indicating whether the color string is valid.\n     */\n    public validateColorString(color: string): ColorValidationResult {\n        const result: ColorValidationResult = {\n            spaceId: null,\n            coords: [0, 0, 0],\n            isValid: false,\n            alpha: 1,\n        };\n\n        // RGB color formats\n        const rgbRegExpArray = [\n            // With commas\n            /rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d*\\.?\\d+)\\s*\\)/i, // rgba(r, g, b, a)\n            /rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)/i, // rgb(r, g, b)\n\n            // With spaces\n            /^rgba\\s+(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})\\s+(0|0?\\.\\d+|1)\\s*$/i, // rgba r g b a\n            /^rgb\\s+(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})\\s*$/i, // rgb r g b\n\n            // Spaces inside parentheses\n            /^rgba\\(\\s*(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d*\\.?\\d+)\\s*\\)$/i, // rgba(r g b a)\n            /^rgb\\(\\s*(\\d{1,3})\\s+(\\d{1,3})\\s+(\\d{1,3})\\s*\\)$/i, // rgb(r g b)\n\n            // Percentage values\n            /rgb\\(\\s*(100|[0-9]{1,2}%)\\s*,\\s*(100|[0-9]{1,2}%)\\s*,\\s*(100|[0-9]{1,2}%)\\s*\\)/i, // rgb(r%, g%, b%)\n            /rgba\\(\\s*(100|[0-9]{1,2})%\\s*,\\s*(100|[0-9]{1,2})%\\s*,\\s*(100|[0-9]{1,2})%\\s*,\\s*(\\d*\\.?\\d+)\\s*\\)/i, // rgba(r%, g%, b%, a)\n        ];\n\n        // HSL color formats\n        const hslRegExpArray = [\n            // With commas\n            /hsla\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d*\\.?\\d+)\\s*\\)/i, // hsla(h, s, l, a)\n            /hsl\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*\\)/i, // hsl(h, s, l)\n\n            // With spaces\n            /^hsla\\s+(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s+(\\d*\\.?\\d+)\\s*$/i, // hsla h s l a\n            /^hsl\\s+(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s*$/i, // hsl h s l\n\n            // Spaces inside parentheses\n            /^hsla\\(\\s*(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s+(\\d*\\.?\\d+)\\s*\\)$/i, // hsla(h s l a)\n            /^hsl\\(\\s*(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s*\\)$/i, // hsl(h s l)\n        ];\n\n        // HSV color formats\n        const hsvRegExpArray = [\n            // With commas\n            /hsva\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d*\\.?\\d+)\\s*\\)/i, // hsva(h, s, v, a)\n            /hsv\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3}%?)\\s*,\\s*(\\d{1,3}%?)\\s*\\)/i, // hsv(h, s, v)\n\n            // With spaces\n            /^hsva\\s+(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s+(\\d*\\.?\\d+)\\s*$/i, // hsva h s v a\n            /^hsv\\s+(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s*$/i, // hsv h s v\n\n            // Spaces inside parentheses\n            /^hsva\\(\\s*(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s+(\\d*\\.?\\d+)\\s*\\)$/i, // hsva(h s v a)\n            /^hsv\\(\\s*(\\d{1,3})\\s+(\\d{1,3}%?)\\s+(\\d{1,3}%?)\\s*\\)$/i, // hsv(h s v)\n        ];\n\n        // HEX color formats\n        const hexRegExpArray = [\n            /^#([A-Fa-f0-9]{6})([A-Fa-f0-9]{2})?$/, // 6-digit hex with optional hex alpha\n            /^#([A-Fa-f0-9]{3})([A-Fa-f0-9]{1})?$/, // 3-digit hex with optional hex alpha\n        ];\n\n        const rgbaMatch = rgbRegExpArray\n            .find((regex) => regex.test(color))\n            ?.exec(color);\n        const hslaMatch = hslRegExpArray\n            .find((regex) => regex.test(color))\n            ?.exec(color);\n        const hsvaMatch = hsvRegExpArray\n            .find((regex) => regex.test(color))\n            ?.exec(color);\n        const hexMatch = hexRegExpArray\n            .find((regex) => regex.test(color))\n            ?.exec(color);\n\n        if (rgbaMatch) {\n            const [, r, g, b, a] = rgbaMatch.filter(\n                (element) => typeof element === 'string'\n            );\n            const alpha = a === undefined ? 1 : Number(a);\n            const processValue = (value: string): number => {\n                if (value.includes('%')) {\n                    return Number(value.replace('%', '')) / 100;\n                } else {\n                    return Number(value) / 255;\n                }\n            };\n            const numericR = processValue(r);\n            const numericG = processValue(g);\n            const numericB = processValue(b);\n\n            result.spaceId = 'srgb';\n            result.coords = [numericR, numericG, numericB];\n            result.alpha = alpha;\n            result.isValid =\n                numericR >= 0 &&\n                numericR <= 1 &&\n                numericG >= 0 &&\n                numericG <= 1 &&\n                numericB >= 0 &&\n                numericB <= 1 &&\n                alpha >= 0 &&\n                alpha <= 1;\n        } else if (hslaMatch) {\n            const [, h, s, l, a] = hslaMatch;\n            const values = [h, s, l, a === undefined ? '1' : a].map((value) =>\n                Number(value.replace(/[^\\d.]/g, ''))\n            );\n            const [numericH, numericS, numericL, numericA] = values;\n\n            result.spaceId = 'hsl';\n            result.coords = [numericH, numericS, numericL];\n            result.alpha = numericA;\n            result.isValid =\n                numericH >= 0 &&\n                numericH <= 360 &&\n                numericS >= 0 &&\n                numericS <= 100 &&\n                numericL >= 0 &&\n                numericL <= 100 &&\n                numericA >= 0 &&\n                numericA <= 1;\n        } else if (hsvaMatch) {\n            const [, h, s, v, a] = hsvaMatch;\n            const values = [h, s, v, a === undefined ? '1' : a].map((value) =>\n                Number(value.replace(/[^\\d.]/g, ''))\n            );\n            const [numericH, numericS, numericV, numericA] = values;\n\n            result.spaceId = 'hsv';\n            result.coords = [numericH, numericS, numericV];\n            result.alpha = numericA;\n            result.isValid =\n                numericH >= 0 &&\n                numericH <= 360 &&\n                numericS >= 0 &&\n                numericS <= 100 &&\n                numericV >= 0 &&\n                numericV <= 100 &&\n                numericA >= 0 &&\n                numericA <= 1;\n        } else if (hexMatch) {\n            const [, hex, alphaHex] = hexMatch;\n\n            // Function to process 2-digit or repeated 1-digit hex\n            const processHex = (hex: string): number => {\n                // For 3-digit hex values, repeat each digit\n                if (hex.length === 1) {\n                    hex = hex + hex;\n                }\n                return parseInt(hex, 16) / 255;\n            };\n\n            // Handle both 3-digit and 6-digit hex\n            let numericR, numericG, numericB;\n            if (hex.length === 3) {\n                // 3-digit hex (e.g., #3a7 -> #33aa77)\n                numericR = processHex(hex.substring(0, 1));\n                numericG = processHex(hex.substring(1, 2));\n                numericB = processHex(hex.substring(2, 3));\n            } else {\n                // 6-digit hex (e.g., #33aa77)\n                numericR = processHex(hex.substring(0, 2));\n                numericG = processHex(hex.substring(2, 4));\n                numericB = processHex(hex.substring(4, 6));\n            }\n\n            // Process hex alpha if provided (convert from 0-255 to 0-1)\n            const numericA = alphaHex ? processHex(alphaHex) : 1;\n\n            // Validate the color values\n            result.spaceId = 'srgb';\n            result.coords = [numericR, numericG, numericB];\n            result.alpha = numericA;\n            result.isValid =\n                numericR >= 0 &&\n                numericR <= 1 &&\n                numericG >= 0 &&\n                numericG <= 1 &&\n                numericB >= 0 &&\n                numericB <= 1 &&\n                numericA >= 0 &&\n                numericA <= 1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Represents the color state of the component.\n     * Initialized with an HSV color model with hue 0, saturation 100, and value 100, and an alpha value of 1.\n     *\n     * @private\n     * @type {Color}\n     */\n    private _color: Color = new Color('hsv', [0, 100, 100], 1);\n\n    /**\n     * Represents the original color value provided by the user.\n     *\n     * @private\n     * @type {ColorTypes}\n     */\n    private _colorOrigin!: ColorTypes;\n\n    /**\n     * Gets the original color value provided by the user.\n     *\n     * @returns {ColorTypes} The original color value.\n     */\n    get colorOrigin(): ColorTypes {\n        return this._colorOrigin;\n    }\n\n    /**\n     * Sets the original color value provided by the user.\n     *\n     * @param {ColorTypes} colorOrigin - The original color value to set.\n     */\n    set colorOrigin(colorOrigin: ColorTypes) {\n        this._colorOrigin = colorOrigin;\n    }\n\n    /**\n     * An optional string property that specifies how the color should be managed(its value is the name of color space in which color object will be managed).\n     * This property can be used to define a specific management strategy or identifier.\n     */\n    private manageAs?: string;\n\n    /**\n     * Stores the previous color value.\n     * This is used to keep track of the color before any changes are made.\n     *\n     * @private\n     */\n    private _previousColor!: Color;\n\n    /**\n     * Private helper method to convert RGB color to hex format with optional alpha\n     *\n     * @private\n     * @param {boolean} includeHash - Whether to include the # prefix in the returned string\n     * @param {boolean} includeAlpha - Whether to include the alpha channel in the returned string\n     * @returns {string} The color in hex format\n     */\n    private _getHexString(includeHash: boolean, includeAlpha: boolean): string {\n        const { r, g, b } = (this._color.to('srgb') as Color).srgb;\n        const a = this._color.alpha;\n\n        const rHex = Math.round(r * 255)\n            .toString(16)\n            .padStart(2, '0');\n        const gHex = Math.round(g * 255)\n            .toString(16)\n            .padStart(2, '0');\n        const bHex = Math.round(b * 255)\n            .toString(16)\n            .padStart(2, '0');\n        const aHex = Math.round(a * 255)\n            .toString(16)\n            .padStart(2, '0');\n\n        return `${includeHash ? '#' : ''}${rHex}${gHex}${bHex}${includeAlpha ? aHex : ''}`;\n    }\n\n    /**\n     * Sets the color value for the controller. The color can be provided in various formats:\n     * - A string representing a color name, hex code, or other color format.\n     * - An instance of the `Color` class.\n     * - An object containing color properties such as `h`, `s`, `l`, `v`, `r`, `g`, `b`, and optionally `a`.\n     *\n     * The method validates and parses the input color, converting it to a `Color` instance.\n     * If the color is invalid, it attempts to parse it as a hex code or returns without setting a new color.\n     *\n     * @param {ColorTypes} color - The color value to set. It can be a string, an instance of `Color`, or an object with color properties.\n     */\n    set color(color: ColorTypes) {\n        this._colorOrigin = color;\n        let newColor!: Color;\n        if (typeof color === 'string') {\n            const colorValidationResult = this.validateColorString(\n                color as string\n            );\n            if (colorValidationResult.isValid) {\n                const [coord1, coord2, coord3] = colorValidationResult.coords;\n                newColor = new Color(\n                    `${colorValidationResult.spaceId}`,\n                    [coord1, coord2, coord3],\n                    colorValidationResult.alpha\n                );\n            } else {\n                try {\n                    Color.parse(color);\n                } catch (error) {\n                    try {\n                        newColor = new Color(`#${color}`);\n                    } catch (error) {\n                        return;\n                    }\n                }\n            }\n        } else if (color instanceof Color) {\n            newColor = color;\n        } else if (!Array.isArray(color)) {\n            const { h, s, l, v, r, g, b, a } = color as {\n                h: string;\n                s: string;\n                l: string;\n                v: string;\n                r: string;\n                g: string;\n                b: string;\n                a?: string;\n            };\n            if (typeof h !== 'undefined' && typeof s !== 'undefined') {\n                const lv = l ?? v;\n                newColor = new Color(\n                    typeof l !== 'undefined' ? 'hsl' : 'hsv',\n                    [\n                        parseFloat(h),\n                        typeof s !== 'string' ? s * 100 : parseFloat(s),\n                        typeof lv !== 'string' ? lv * 100 : parseFloat(lv),\n                    ],\n                    parseFloat(a || '1')\n                );\n            } else if (\n                typeof r !== 'undefined' &&\n                typeof g !== 'undefined' &&\n                typeof b !== 'undefined'\n            ) {\n                newColor = new Color(\n                    'srgb',\n                    [\n                        parseFloat(r) / 255,\n                        parseFloat(g) / 255,\n                        parseFloat(b) / 255,\n                    ],\n                    parseFloat(a || '1')\n                );\n            }\n        }\n\n        if (!newColor) {\n            newColor = new Color(color as DefaultColorTypes);\n        }\n\n        if (this.manageAs) {\n            this._color = newColor.to(this.manageAs) as Color;\n        } else {\n            this._color = newColor;\n        }\n        this.host.requestUpdate();\n    }\n\n    /**\n     * Gets the color value in various formats based on the original color input.\n     *\n     * The method determines the color space of the original color input and converts\n     * the color to the appropriate format. The supported color spaces are:\n     * - HSV (Hue, Saturation, Value)\n     * - HSL (Hue, Saturation, Lightness)\n     * - Hexadecimal (with or without alpha)\n     * - RGB (Red, Green, Blue) with optional alpha\n     *\n     * @returns {ColorTypes} The color value in the appropriate format.\n     *\n     * The method handles the following cases:\n     * - If the original color input is a string, it checks the prefix to determine the color space.\n     * - If the original color input is an object, it checks the properties to determine the color space.\n     * - If the original color input is not provided, it defaults to the current color space of the color object.\n     *\n     * The returned color value can be in one of the following formats:\n     * - `hsv(h, s%, v%)` or `hsva(h, s%, v%, a)`\n     * - `hsl(h, s%, l%)` or `hsla(h, s%, l%, a)`\n     * - `#rrggbb` or `#rrggbbaa`\n     * - `rgb(r, g, b)` or `rgba(r, g, b, a)`\n     * - `{ h, s, v, a }` for HSV object\n     * - `{ h, s, l, a }` for HSL object\n     * - `{ r, g, b, a }` for RGB object\n     */\n    get colorValue(): ColorTypes {\n        if (typeof this._colorOrigin === 'string') {\n            let spaceId = '';\n            if (this._colorOrigin.startsWith('#')) {\n                spaceId = 'hex string';\n            } else if (this._colorOrigin.startsWith('rgb')) {\n                spaceId = 'rgb';\n            } else if (this._colorOrigin.startsWith('hsl')) {\n                spaceId = 'hsl';\n            } else if (this._colorOrigin.startsWith('hsv')) {\n                spaceId = 'hsv';\n            } else {\n                spaceId = 'hex';\n            }\n            switch (spaceId) {\n                case 'hsv': {\n                    const hadAlpha = this._colorOrigin[3] === 'a';\n                    const { h, s, v } = (this._color.to('hsv') as Color).hsv;\n                    const a = this._color.alpha;\n                    return `hsv${hadAlpha ? `a` : ''}(${Math.round(\n                        h\n                    )}, ${Math.round(s)}%, ${Math.round(v)}%${\n                        hadAlpha ? `, ${a}` : ''\n                    })`;\n                }\n                case 'hsl': {\n                    const hadAlpha = this._colorOrigin[3] === 'a';\n                    const { h, s, l } = (this._color.to('hsl') as Color).hsl;\n                    const a = this._color.alpha;\n                    return `hsl${hadAlpha ? `a` : ''}(${Math.round(\n                        h\n                    )}, ${Math.round(s)}%, ${Math.round(l)}%${\n                        hadAlpha ? `, ${a}` : ''\n                    })`;\n                }\n                case 'hex string': {\n                    // Check if the original input included alpha\n                    const hadAlpha =\n                        this._colorOrigin.length === 9 || // #RRGGBBAA format\n                        this._colorOrigin.length === 5; // #RGBA format\n                    return this._getHexString(true, hadAlpha);\n                }\n                case 'hex': {\n                    // Check if the original input included alpha\n                    const hadAlpha =\n                        this._colorOrigin.length === 8 || // RRGGBBAA format (no #)\n                        this._colorOrigin.length === 4; // RGBA format (no #)\n                    return this._getHexString(false, hadAlpha);\n                }\n                //rgb\n                default: {\n                    const { r, g, b } = (this._color.to('srgb') as Color).srgb;\n                    const hadAlpha = this._colorOrigin[3] === 'a';\n                    const a = this._color.alpha;\n                    if (this._colorOrigin.search('%') > -1) {\n                        return `rgb${hadAlpha ? `a` : ''}(${Math.round(r * 100)}%, ${Math.round(\n                            g * 100\n                        )}%, ${Math.round(b * 100)}%${hadAlpha ? `,${Math.round(a * 100)}%` : ''})`;\n                    }\n                    return `rgb${hadAlpha ? `a` : ''}(${Math.round(r * 255)}, ${Math.round(\n                        g * 255\n                    )}, ${Math.round(b * 255)}${hadAlpha ? `, ${a}` : ''})`;\n                }\n            }\n        }\n        let spaceId;\n        if (this._colorOrigin) {\n            try {\n                ({ spaceId } = new Color(\n                    this._colorOrigin as DefaultColorTypes\n                ));\n            } catch (error) {\n                const { h, s, l, v, r, g, b } = this._colorOrigin as {\n                    h: string;\n                    s: string;\n                    l: string;\n                    v: string;\n                    r: string;\n                    g: string;\n                    b: string;\n                };\n                if (\n                    typeof h !== 'undefined' &&\n                    typeof s !== 'undefined' &&\n                    typeof l !== 'undefined'\n                ) {\n                    spaceId = 'hsl';\n                } else if (\n                    typeof h !== 'undefined' &&\n                    typeof s !== 'undefined' &&\n                    typeof v !== 'undefined'\n                ) {\n                    spaceId = 'hsv';\n                } else if (\n                    typeof r !== 'undefined' &&\n                    typeof g !== 'undefined' &&\n                    typeof b !== 'undefined'\n                ) {\n                    spaceId = 'srgb';\n                }\n            }\n        } else {\n            ({ spaceId } = this.color);\n        }\n        switch (spaceId) {\n            case 'hsv': {\n                const { h, s, v } = (this._color.to('hsv') as Color).hsv;\n                return {\n                    h,\n                    s: s / 100,\n                    v: v / 100,\n                    a: this._color.alpha,\n                };\n            }\n            case 'hsl': {\n                const { h, s, l } = (this._color.to('hsl') as Color).hsl;\n                return {\n                    h,\n                    s: s / 100,\n                    l: l / 100,\n                    a: this._color.alpha,\n                };\n            }\n            case 'srgb': {\n                const { r, g, b } = (this._color.to('srgb') as Color).srgb;\n                if (\n                    this._colorOrigin &&\n                    typeof (this._colorOrigin as { r: string }).r ===\n                        'string' &&\n                    (this._colorOrigin as { r: string }).r.search('%')\n                ) {\n                    return {\n                        r: `${Math.round(r * 255)}%`,\n                        g: `${Math.round(g * 255)}%`,\n                        b: `${Math.round(b * 255)}%`,\n                        a: this._color.alpha,\n                    };\n                }\n                return {\n                    r: Math.round(r * 255),\n                    g: Math.round(g * 255),\n                    b: Math.round(b * 255),\n                    a: this._color.alpha,\n                };\n            }\n        }\n        return this._color;\n    }\n\n    protected host: ReactiveElement;\n\n    /**\n     * Gets the hue value of the current color in HSL format.\n     *\n     * @returns {number} The hue value as a number.\n     */\n    get hue(): number {\n        return Number((this._color.to('hsl') as Color).hsl.h);\n    }\n\n    /**\n     * Sets the hue value of the color and requests an update from the host.\n     *\n     * @param hue - The hue value to set, represented as a number.\n     */\n    set hue(hue: number) {\n        this._color.set('h', hue);\n        this.host.requestUpdate();\n    }\n\n    /**\n     * Creates an instance of ColorController.\n     *\n     * @param host - The ReactiveElement that this controller is associated with.\n     * @param options - An object containing optional parameters.\n     * @param options.manageAs - A string to manage the controller as a specific type.\n     */\n    constructor(\n        host: ReactiveElement,\n        {\n            manageAs,\n        }: {\n            manageAs?: string;\n        } = {}\n    ) {\n        this.host = host;\n        this.manageAs = manageAs;\n    }\n\n    /**\n     * Converts the current color to the specified format.\n     *\n     * @param format - The desired color format. It can be a string representing one of the valid formats\n     * ('srgb', 'hsva', 'hsv', 'hsl', 'hsla') or a ColorSpace object.\n     * @returns The color object in the specified format.\n     * @throws Will throw an error if the provided format is not a valid string format.\n     */\n    getColor(format: string | ColorSpace): ColorObject {\n        const validFormats = ['srgb', 'hsva', 'hsv', 'hsl', 'hsla'];\n        if (typeof format === 'string' && !validFormats.includes(format)) {\n            throw new Error('not a valid format');\n        }\n\n        return this._color.to(format);\n    }\n\n    /**\n     * Converts the current color to an HSL string representation.\n     *\n     * @returns {string} The HSL string representation of the current color.\n     */\n    getHslString(): string {\n        return this._color.to('hsl').toString();\n    }\n\n    /**\n     * Saves the current color state by cloning the current color and storing it\n     * as the previous color. This allows for the ability to revert to the previous\n     * color state if needed.\n     *\n     * @returns {void}\n     */\n    savePreviousColor(): void {\n        this._previousColor = this._color.clone();\n    }\n\n    /**\n     * Restores the color to the previously saved color value.\n     *\n     * This method sets the current color (`_color`) to the previously stored color (`_previousColor`).\n     */\n    restorePreviousColor(): void {\n        this._color = this._previousColor;\n    }\n}\n"],
  "mappings": "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",
  "names": ["hex", "error", "spaceId"]
}
