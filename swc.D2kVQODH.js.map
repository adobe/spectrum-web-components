{"version":3,"file":"swc.5zORiZ3L.js","sources":["../../../../node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport function dim1(direction) {\n    return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n    return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n    return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n    return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n    _getDefaultConfig() {\n        return {\n            direction: 'vertical',\n        };\n    }\n    constructor(hostSink, config) {\n        /**\n         * The last set viewport scroll position.\n         */\n        this._latestCoords = { left: 0, top: 0 };\n        /**\n         * Scrolling direction.\n         */\n        this._direction = null;\n        /**\n         * Dimensions of the viewport.\n         */\n        this._viewportSize = { width: 0, height: 0 };\n        this.totalScrollSize = { width: 0, height: 0 };\n        this.offsetWithinScroller = { left: 0, top: 0 };\n        /**\n         * Flag for debouncing asynchronous reflow requests.\n         */\n        this._pendingReflow = false;\n        this._pendingLayoutUpdate = false;\n        this._pin = null;\n        /**\n         * The index of the first item intersecting the viewport.\n         */\n        this._firstVisible = 0;\n        /**\n         * The index of the last item intersecting the viewport.\n         */\n        this._lastVisible = 0;\n        /**\n         * Pixel offset in the scroll direction of the first child.\n         */\n        this._physicalMin = 0;\n        /**\n         * Pixel offset in the scroll direction of the last child.\n         */\n        this._physicalMax = 0;\n        /**\n         * Index of the first child.\n         */\n        this._first = -1;\n        /**\n         * Index of the last child.\n         */\n        this._last = -1;\n        /**\n         * Length in the scrolling direction.\n         */\n        this._sizeDim = 'height';\n        /**\n         * Length in the non-scrolling direction.\n         */\n        this._secondarySizeDim = 'width';\n        /**\n         * Position in the scrolling direction.\n         */\n        this._positionDim = 'top';\n        /**\n         * Position in the non-scrolling direction.\n         */\n        this._secondaryPositionDim = 'left';\n        /**\n         * Current scroll offset in pixels.\n         */\n        this._scrollPosition = 0;\n        /**\n         * Difference between current scroll offset and scroll offset calculated due\n         * to a reflow.\n         */\n        this._scrollError = 0;\n        /**\n         * Total number of items that could possibly be displayed. Used to help\n         * calculate the scroll size.\n         */\n        this._items = [];\n        /**\n         * The total (estimated) length of all items in the scrolling direction.\n         */\n        this._scrollSize = 1;\n        /**\n         * Number of pixels beyond the viewport to still include\n         * in the active range of items.\n         */\n        // TODO (graynorton): Probably want to make this something we calculate based\n        // on viewport size, item size, other factors, possibly still with a dial of some kind\n        this._overhang = 1000;\n        this._hostSink = hostSink;\n        // Delay setting config so that subclasses do setup work first\n        Promise.resolve().then(() => (this.config = config || this._getDefaultConfig()));\n    }\n    set config(config) {\n        Object.assign(this, Object.assign({}, this._getDefaultConfig(), config));\n    }\n    get config() {\n        return {\n            direction: this.direction,\n        };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */\n    get items() {\n        return this._items;\n    }\n    set items(items) {\n        this._setItems(items);\n    }\n    _setItems(items) {\n        if (items !== this._items) {\n            this._items = items;\n            this._scheduleReflow();\n        }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    set direction(dir) {\n        // Force it to be either horizontal or vertical.\n        dir = dir === 'horizontal' ? dir : 'vertical';\n        if (dir !== this._direction) {\n            this._direction = dir;\n            this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n            this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n            this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n            this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n            this._triggerReflow();\n        }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n    get viewportSize() {\n        return this._viewportSize;\n    }\n    set viewportSize(dims) {\n        const { _viewDim1, _viewDim2 } = this;\n        Object.assign(this._viewportSize, dims);\n        if (_viewDim2 !== this._viewDim2) {\n            // this._viewDim2Changed();\n            this._scheduleLayoutUpdate();\n        }\n        else if (_viewDim1 !== this._viewDim1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n    get viewportScroll() {\n        return this._latestCoords;\n    }\n    set viewportScroll(coords) {\n        Object.assign(this._latestCoords, coords);\n        const oldPos = this._scrollPosition;\n        this._scrollPosition = this._latestCoords[this._positionDim];\n        const change = Math.abs(oldPos - this._scrollPosition);\n        if (change >= 1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n    reflowIfNeeded(force = false) {\n        if (force || this._pendingReflow) {\n            this._pendingReflow = false;\n            this._reflow();\n        }\n    }\n    set pin(options) {\n        this._pin = options;\n        this._triggerReflow();\n    }\n    get pin() {\n        if (this._pin !== null) {\n            const { index, block } = this._pin;\n            return {\n                index: Math.max(0, Math.min(index, this.items.length - 1)),\n                block,\n            };\n        }\n        return null;\n    }\n    _clampScrollPosition(val) {\n        return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n    }\n    unpin() {\n        if (this._pin !== null) {\n            this._sendUnpinnedMessage();\n            this._pin = null;\n        }\n    }\n    _updateLayout() {\n        // Override\n    }\n    // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n    get _viewDim1() {\n        return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n    get _viewDim2() {\n        return this._viewportSize[this._secondarySizeDim];\n    }\n    _scheduleReflow() {\n        this._pendingReflow = true;\n    }\n    _scheduleLayoutUpdate() {\n        this._pendingLayoutUpdate = true;\n        this._scheduleReflow();\n    }\n    // For triggering a reflow based on incoming changes to\n    // the layout config.\n    _triggerReflow() {\n        this._scheduleLayoutUpdate();\n        // TODO graynorton@: reflowIfNeeded() isn't really supposed\n        // to be called internally. Address in larger cleanup\n        // of virtualizer / layout interaction pattern.\n        // this.reflowIfNeeded(true);\n        Promise.resolve().then(() => this.reflowIfNeeded());\n    }\n    _reflow() {\n        if (this._pendingLayoutUpdate) {\n            this._updateLayout();\n            this._pendingLayoutUpdate = false;\n        }\n        this._updateScrollSize();\n        this._setPositionFromPin();\n        this._getActiveItems();\n        this._updateVisibleIndices();\n        this._sendStateChangedMessage();\n    }\n    /**\n     * If we are supposed to be pinned to a particular\n     * item or set of coordinates, we set `_scrollPosition`\n     * accordingly and adjust `_scrollError` as needed\n     * so that the virtualizer can keep the scroll\n     * position in the DOM in sync\n     */\n    _setPositionFromPin() {\n        if (this.pin !== null) {\n            const lastScrollPosition = this._scrollPosition;\n            const { index, block } = this.pin;\n            this._scrollPosition =\n                this._calculateScrollIntoViewPosition({\n                    index,\n                    block: block || 'start',\n                }) - this.offsetWithinScroller[this._positionDim];\n            this._scrollError = lastScrollPosition - this._scrollPosition;\n        }\n    }\n    /**\n     * Calculate the coordinates to scroll to, given\n     * a request to scroll to the element at a specific\n     * index.\n     *\n     * Supports the same positioning options (`start`,\n     * `center`, `end`, `nearest`) as the standard\n     * `Element.scrollIntoView()` method, but currently\n     * only considers the provided value in the `block`\n     * dimension, since we don't yet have any layouts\n     * that support virtualization in two dimensions.\n     */\n    _calculateScrollIntoViewPosition(options) {\n        const { block } = options;\n        const index = Math.min(this.items.length, Math.max(0, options.index));\n        const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n        let scrollPosition = itemStartPosition;\n        if (block !== 'start') {\n            const itemSize = this._getItemSize(index)[this._sizeDim];\n            if (block === 'center') {\n                scrollPosition =\n                    itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n            }\n            else {\n                const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n                if (block === 'end') {\n                    scrollPosition = itemEndPosition;\n                }\n                else {\n                    // block === 'nearest'\n                    const currentScrollPosition = this._scrollPosition;\n                    scrollPosition =\n                        Math.abs(currentScrollPosition - itemStartPosition) <\n                            Math.abs(currentScrollPosition - itemEndPosition)\n                            ? itemStartPosition\n                            : itemEndPosition;\n                }\n            }\n        }\n        scrollPosition += this.offsetWithinScroller[this._positionDim];\n        return this._clampScrollPosition(scrollPosition);\n    }\n    getScrollIntoViewCoordinates(options) {\n        return {\n            [this._positionDim]: this._calculateScrollIntoViewPosition(options),\n        };\n    }\n    _sendUnpinnedMessage() {\n        this._hostSink({\n            type: 'unpinned',\n        });\n    }\n    _sendVisibilityChangedMessage() {\n        this._hostSink({\n            type: 'visibilityChanged',\n            firstVisible: this._firstVisible,\n            lastVisible: this._lastVisible,\n        });\n    }\n    _sendStateChangedMessage() {\n        const childPositions = new Map();\n        if (this._first !== -1 && this._last !== -1) {\n            for (let idx = this._first; idx <= this._last; idx++) {\n                childPositions.set(idx, this._getItemPosition(idx));\n            }\n        }\n        const message = {\n            type: 'stateChanged',\n            scrollSize: {\n                [this._sizeDim]: this._scrollSize,\n                [this._secondarySizeDim]: null,\n            },\n            range: {\n                first: this._first,\n                last: this._last,\n                firstVisible: this._firstVisible,\n                lastVisible: this._lastVisible,\n            },\n            childPositions,\n        };\n        if (this._scrollError) {\n            message.scrollError = {\n                [this._positionDim]: this._scrollError,\n                [this._secondaryPositionDim]: 0,\n            };\n            this._scrollError = 0;\n        }\n        this._hostSink(message);\n    }\n    /**\n     * Number of items to display.\n     */\n    get _num() {\n        if (this._first === -1 || this._last === -1) {\n            return 0;\n        }\n        return this._last - this._first + 1;\n    }\n    _checkThresholds() {\n        if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n            this._scheduleReflow();\n        }\n        else {\n            const min = Math.max(0, this._scrollPosition - this._overhang);\n            const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n            if (this._physicalMin > min || this._physicalMax < max) {\n                this._scheduleReflow();\n            }\n            else {\n                this._updateVisibleIndices({ emit: true });\n            }\n        }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n    _updateVisibleIndices(options) {\n        if (this._first === -1 || this._last === -1)\n            return;\n        let firstVisible = this._first;\n        while (firstVisible < this._last &&\n            Math.round(this._getItemPosition(firstVisible)[this._positionDim] +\n                this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n            firstVisible++;\n        }\n        let lastVisible = this._last;\n        while (lastVisible > this._first &&\n            Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n                Math.round(this._scrollPosition + this._viewDim1)) {\n            lastVisible--;\n        }\n        if (firstVisible !== this._firstVisible ||\n            lastVisible !== this._lastVisible) {\n            this._firstVisible = firstVisible;\n            this._lastVisible = lastVisible;\n            if (options && options.emit) {\n                this._sendVisibilityChangedMessage();\n            }\n        }\n    }\n}\n//# sourceMappingURL=BaseLayout.js.map"],"names":["dim1","direction","dim2","BaseLayout","_getDefaultConfig","constructor","hostSink","config","this","_latestCoords","left","top","_direction","_viewportSize","width","height","totalScrollSize","offsetWithinScroller","_pendingReflow","_pendingLayoutUpdate","_pin","_firstVisible","_lastVisible","_physicalMin","_physicalMax","_first","_last","_sizeDim","_secondarySizeDim","_positionDim","_secondaryPositionDim","_scrollPosition","_scrollError","_items","_scrollSize","_overhang","_hostSink","Promise","resolve","then","Object","assign","items","_setItems","_scheduleReflow","dir","_triggerReflow","viewportSize","dims","_viewDim1","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","viewportScroll","coords","oldPos","Math","abs","reflowIfNeeded","force","_reflow","pin","options","index","block","max","min","length","_clampScrollPosition","val","unpin","_sendUnpinnedMessage","_updateLayout","_updateScrollSize","_setPositionFromPin","_getActiveItems","_updateVisibleIndices","_sendStateChangedMessage","lastScrollPosition","_calculateScrollIntoViewPosition","itemStartPosition","_getItemPosition","scrollPosition","itemSize","_getItemSize","itemEndPosition","currentScrollPosition","getScrollIntoViewCoordinates","type","_sendVisibilityChangedMessage","firstVisible","lastVisible","childPositions","Map","idx","set","message","scrollSize","range","first","last","scrollError","_num","emit","round"],"mappings":"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","x_google_ignoreList":[0]}