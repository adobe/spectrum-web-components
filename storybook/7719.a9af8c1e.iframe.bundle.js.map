{"version":3,"file":"7719.a9af8c1e.iframe.bundle.js","mappings":";;AA6YA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;AAQA;;;ACnTA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;;;AA+BA;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;AAKA;AAGA;AACA;AACA;;;AAGA;;;;AAKA;;;;;;;;;;;;;AAmBA;;AAYA;AACA;;AAIA;;AAGA;;AAEA;;AAEA;;;;AAMA;;;AAQA;;;AAIA;;AAoCA;AAIA;;AAGA;AAMA;AAEA;;;AAmBA;;;AAWA;AACA;;AAEA;;;AAOA;;AAMA;AACA;;;;AASA","sources":["webpack://@adobe/spectrum-web-components/./packages/slider/src/HandleController.dev.js","webpack://@adobe/spectrum-web-components/./packages/slider/src/Slider.dev.js"],"sourcesContent":["\"use strict\";\nimport { html } from \"@spectrum-web-components/base\";\nimport {\n  classMap,\n  ifDefined,\n  styleMap\n} from \"@spectrum-web-components/base/src/directives.js\";\nimport { MutationController } from \"@lit-labs/observers/mutation-controller.js\";\nimport { SliderHandle } from \"./SliderHandle.dev.js\";\nexport class HandleController {\n  constructor(host) {\n    this.handles = /* @__PURE__ */ new Map();\n    this.model = [];\n    this.handleOrder = [];\n    this.handleOrientation = () => {\n      this.updateBoundingRect();\n    };\n    this.extractModelFromLightDom = () => {\n      let handles = [\n        ...this.host.querySelectorAll('[slot=\"handle\"]')\n      ];\n      if (handles.length === 0) {\n        handles = [this.host];\n      }\n      if (handles.some((h) => this.waitForUpgrade(h))) {\n        return;\n      }\n      this.handles = /* @__PURE__ */ new Map();\n      this.handleOrder = [];\n      handles.forEach((handle, index) => {\n        var _a;\n        if (!((_a = handle.handleName) == null ? void 0 : _a.length)) {\n          handle.name = `handle${index + 1}`;\n        }\n        this.handles.set(handle.handleName, handle);\n        this.handleOrder.push(handle.handleName);\n        handle.handleController = this;\n      });\n      this.requestUpdate();\n    };\n    /**\n     * Keep the slider value property in sync with the input element's value\n     */\n    this.onInputChange = (event) => {\n      const input = event.target;\n      input.model.handle.value = input.valueAsNumber;\n      this.requestUpdate();\n      this.dispatchChangeEvent(input, input.model.handle);\n    };\n    this.onInputFocus = (event) => {\n      const input = event.target;\n      let isFocusVisible;\n      try {\n        isFocusVisible = input.matches(\":focus-visible\") || this.host.matches(\".focus-visible\");\n      } catch (error) {\n        isFocusVisible = this.host.matches(\".focus-visible\");\n      }\n      input.model.handle.highlight = isFocusVisible;\n      this.requestUpdate();\n    };\n    this.onInputBlur = (event) => {\n      const input = event.target;\n      input.model.handle.highlight = false;\n      this.requestUpdate();\n    };\n    this.onInputKeydown = (event) => {\n      var _a;\n      if (event.key == \"Escape\") {\n        const input2 = event.target;\n        if (((_a = input2.model.handle) == null ? void 0 : _a.defaultValue) !== void 0 && input2.model.handle.value !== input2.model.handle.defaultValue) {\n          input2.model.handle.value = input2.model.handle.defaultValue;\n          input2.model.handle.dispatchInputEvent();\n          this.dispatchChangeEvent(input2, input2.model.handle);\n          this.requestUpdate();\n          event.preventDefault();\n          event.stopPropagation();\n        }\n        return;\n      }\n      const input = event.target;\n      input.model.handle.highlight = true;\n      this.requestUpdate();\n    };\n    this.host = host;\n    new MutationController(this.host, {\n      config: {\n        subtree: true,\n        childList: true\n      },\n      callback: () => {\n        this.extractModelFromLightDom();\n      }\n    });\n    this.extractModelFromLightDom();\n  }\n  get values() {\n    const result = {};\n    for (const model of this.handles.values()) {\n      result[model.handleName] = model.value;\n    }\n    return result;\n  }\n  get size() {\n    return this.handles.size;\n  }\n  inputForHandle(handle) {\n    if (this.handles.has(handle.handleName)) {\n      const { input } = this.getHandleElements(handle) || {};\n      return input;\n    }\n    throw new Error(`No input for handle \"${handle.name}\"`);\n  }\n  requestUpdate() {\n    if (this.host.hasUpdated) {\n      this.host.requestUpdate();\n    }\n  }\n  /**\n   * It is possible for value attributes to be set programmatically. The <input>\n   * for a particular slider needs to have an opportunity to validate any such\n   * values\n   *\n   * @param handle Handle who's value needs validation\n   */\n  setValueFromHandle(handle) {\n    const elements = this.getHandleElements(handle);\n    if (!elements) return;\n    const { input } = elements;\n    if (input.valueAsNumber === handle.value) {\n      if (handle.dragging) {\n        handle.dispatchInputEvent();\n      }\n    } else {\n      input.valueAsNumber = handle.value;\n      this.requestUpdate();\n    }\n    handle.value = input.valueAsNumber;\n  }\n  handleHasChanged(handle) {\n    if (handle !== this.host) {\n      this.requestUpdate();\n    }\n  }\n  formattedValueForHandle(model) {\n    var _a;\n    const { handle } = model;\n    const numberFormat = (_a = handle.numberFormat) != null ? _a : this.host.numberFormat;\n    const _forcedUnit = handle._forcedUnit === \"\" ? this.host._forcedUnit : handle._forcedUnit;\n    return handle.getAriaHandleText(model.value, numberFormat) + _forcedUnit;\n  }\n  get formattedValues() {\n    const result = /* @__PURE__ */ new Map();\n    for (const model of this.model) {\n      result.set(model.name, this.formattedValueForHandle(model));\n    }\n    return result;\n  }\n  get focusElement() {\n    const { input } = this.getActiveHandleElements();\n    if (!input || this.host.editable && !input.model.handle.dragging) {\n      return this.host.numberField;\n    }\n    return input;\n  }\n  hostConnected() {\n    if (\"orientation\" in screen) {\n      screen.orientation.addEventListener(\n        \"change\",\n        this.handleOrientation\n      );\n    } else {\n      window.addEventListener(\n        \"orientationchange\",\n        this.handleOrientation\n      );\n    }\n  }\n  hostDisconnected() {\n    if (\"orientation\" in screen) {\n      screen.orientation.removeEventListener(\n        \"change\",\n        this.handleOrientation\n      );\n    } else {\n      window.removeEventListener(\n        \"orientationchange\",\n        this.handleOrientation\n      );\n    }\n  }\n  hostUpdate() {\n    this.updateModel();\n  }\n  // Since extractModelFromLightDom bails on the first un-upgraded handle,\n  // a maximum of one listener will be set up per extraction attempt.\n  waitForUpgrade(handle) {\n    if (handle instanceof SliderHandle) {\n      return false;\n    }\n    handle.addEventListener(\n      \"sp-slider-handle-ready\",\n      () => this.extractModelFromLightDom(),\n      { once: true, passive: true }\n    );\n    return true;\n  }\n  get activeHandle() {\n    return this.handleOrder[this.handleOrder.length - 1];\n  }\n  get activeHandleInputId() {\n    const active = this.activeHandle;\n    const index = this.model.findIndex((model) => model.name === active);\n    return `input-${index}`;\n  }\n  activateHandle(name) {\n    const index = this.handleOrder.findIndex((item) => item === name);\n    if (index >= 0) {\n      this.handleOrder.splice(index, 1);\n    }\n    this.handleOrder.push(name);\n  }\n  get activeHandleModel() {\n    const active = this.activeHandle;\n    return this.model.find((model) => model.name === active);\n  }\n  getActiveHandleElements() {\n    const name = this.activeHandle;\n    const handleSlider = this.handles.get(name);\n    const elements = this.getHandleElements(\n      handleSlider\n    );\n    return { model: handleSlider, ...elements };\n  }\n  getHandleElements(sliderHandle) {\n    if (!this.handleRefMap) {\n      this.handleRefMap = /* @__PURE__ */ new WeakMap();\n      const inputNodes = this.host.shadowRoot.querySelectorAll(\".handle > input\");\n      for (const inputNode of inputNodes) {\n        const input = inputNode;\n        const handle = input.parentElement;\n        const model = this.handles.get(\n          handle.getAttribute(\"name\")\n        );\n        if (model) {\n          this.handleRefMap.set(model, { input, handle });\n        }\n      }\n    }\n    const components = this.handleRefMap.get(\n      sliderHandle\n    );\n    return components;\n  }\n  clearHandleComponentCache() {\n    delete this.handleRefMap;\n  }\n  get boundingClientRect() {\n    if (!this._boundingClientRect) {\n      this._boundingClientRect = this.host.track.getBoundingClientRect();\n    }\n    return this._boundingClientRect;\n  }\n  updateBoundingRect() {\n    delete this._boundingClientRect;\n  }\n  /**\n   * Return the `input` and `model` associated with the event and\n   * whether the `input` is a `resolvedInput` meaning it was acquired\n   * from the `model` rather than the event.\n   */\n  extractDataFromEvent(event) {\n    if (!this._activePointerEventData) {\n      let input = event.target.querySelector(\n        \":scope > .input\"\n      );\n      const resolvedInput = !input;\n      const model = input ? input.model : this.model.find((item) => item.name === this.activeHandle);\n      if (!input && !!model) {\n        input = model.handle.focusElement;\n      }\n      this._activePointerEventData = {\n        input,\n        model,\n        resolvedInput\n      };\n    }\n    return this._activePointerEventData;\n  }\n  /**\n   * @description check for defaultvalue(value) property in sp-slider and reset on double click on sliderHandle\n   * @param event\n   */\n  handleDoubleClick(event) {\n    var _a;\n    const input = event.target.querySelector(\n      \".input\"\n    );\n    if (((_a = input.model) == null ? void 0 : _a.handle.defaultValue) !== void 0) {\n      input.model.handle.value = input.model.handle.defaultValue;\n      this.dispatchChangeEvent(input, input.model.handle);\n      input.model.handle.dispatchInputEvent();\n      this.requestUpdate();\n    }\n  }\n  handlePointerdown(event) {\n    const { resolvedInput, model } = this.extractDataFromEvent(event);\n    if (!model || this.host.disabled || event.button !== 0) {\n      event.preventDefault();\n      return;\n    }\n    this.host.track.setPointerCapture(event.pointerId);\n    this.updateBoundingRect();\n    if (event.pointerType === \"mouse\") {\n      this.host.labelEl.click();\n    }\n    this.draggingHandle = model.handle;\n    model.handle.dragging = true;\n    this.activateHandle(model.name);\n    if (resolvedInput) {\n      this.handlePointermove(event);\n    }\n    this.requestUpdate();\n  }\n  handlePointerup(event) {\n    const { input, model } = this.extractDataFromEvent(event);\n    delete this._activePointerEventData;\n    if (!model) return;\n    if (event.pointerType === \"mouse\") {\n      this.host.labelEl.click();\n    }\n    this.cancelDrag(model);\n    this.requestUpdate();\n    this.host.track.releasePointerCapture(event.pointerId);\n    this.dispatchChangeEvent(input, model.handle);\n  }\n  handlePointermove(event) {\n    const { input, model } = this.extractDataFromEvent(event);\n    if (!model) return;\n    if (!this.draggingHandle) {\n      return;\n    }\n    input.value = this.calculateHandlePosition(event, model).toString();\n    model.handle.value = parseFloat(input.value);\n    this.host.indeterminate = false;\n    this.requestUpdate();\n  }\n  cancelDrag(model) {\n    model = model || this.model.find((item) => item.name === this.activeHandle);\n    if (!model) return;\n    model.handle.highlight = false;\n    delete this.draggingHandle;\n    model.handle.dragging = false;\n  }\n  dispatchChangeEvent(input, handle) {\n    input.valueAsNumber = handle.value;\n    const changeEvent = new Event(\"change\", {\n      bubbles: true,\n      composed: true\n    });\n    handle.dispatchEvent(changeEvent);\n  }\n  /**\n   * Returns the value under the cursor\n   * @param: PointerEvent on slider\n   * @return: Slider value that correlates to the position under the pointer\n   */\n  calculateHandlePosition(event, model) {\n    const rect = this.boundingClientRect;\n    const minOffset = rect.left;\n    const offset = event.clientX;\n    const size = rect.width;\n    const directionalOffset = this.host.isLTR ? offset - minOffset : size - (offset - minOffset);\n    const normalized = directionalOffset / size;\n    return model.normalization.fromNormalized(\n      normalized,\n      model.range.min,\n      model.range.max\n    );\n  }\n  renderHandle(model, index, zIndex, isMultiHandle) {\n    var _a;\n    const classes = {\n      handle: true,\n      dragging: ((_a = this.draggingHandle) == null ? void 0 : _a.handleName) === model.name,\n      \"handle-highlight\": model.highlight\n    };\n    const style = {\n      [this.host.isLTR ? \"left\" : \"right\"]: `${model.normalizedValue * 100}%`,\n      \"z-index\": zIndex.toString(),\n      ...isMultiHandle && {\n        \"background-color\": `var(--spectrum-slider-handle-background-color-${index}, var(--spectrum-slider-handle-background-color))`,\n        \"border-color\": `var(--spectrum-slider-handle-border-color-${index}, var(--spectrum-slider-handle-border-color))`\n      }\n    };\n    const ariaLabelledBy = isMultiHandle ? `label input-${index}` : \"label\";\n    return html`\n            <div\n                class=${classMap(classes)}\n                name=${model.name}\n                style=${styleMap(style)}\n                role=\"presentation\"\n            >\n                <input\n                    type=\"range\"\n                    class=\"input\"\n                    id=\"input-${index}\"\n                    min=${model.clamp.min}\n                    max=${model.clamp.max}\n                    step=${model.step}\n                    value=${model.value}\n                    aria-disabled=${ifDefined(\n      this.host.disabled ? \"true\" : void 0\n    )}\n                    tabindex=${ifDefined(this.host.editable ? -1 : void 0)}\n                    aria-label=${ifDefined(model.ariaLabel)}\n                    aria-labelledby=${ariaLabelledBy}\n                    aria-valuetext=${this.formattedValueForHandle(model)}\n                    aria-describedby=\"slider-description\"\n                    @change=${this.onInputChange}\n                    @focus=${this.onInputFocus}\n                    @blur=${this.onInputBlur}\n                    @keydown=${this.onInputKeydown}\n                    .model=${model}\n                />\n                <span id=\"slider-description\">\n                    Press escape or double click to reset the slider to its\n                    default value.\n                </span>\n            </div>\n        `;\n  }\n  render() {\n    this.clearHandleComponentCache();\n    return this.model.map((model, index) => {\n      const zIndex = this.handleOrder.indexOf(model.name) + 2;\n      return this.renderHandle(\n        model,\n        index,\n        zIndex,\n        this.model.length > 1\n      );\n    });\n  }\n  /**\n   * Returns a list of track segment [start, end] tuples where the values are\n   * normalized to be between 0 and 1.\n   * @returns A list of track segment tuples [start, end]\n   */\n  trackSegments() {\n    const values = this.model.map((model) => model.normalizedValue);\n    values.sort((a, b) => a - b);\n    values.unshift(0);\n    return values.map((value, index, array) => {\n      var _a;\n      return [\n        value,\n        (_a = array[index + 1]) != null ? _a : 1\n      ];\n    });\n  }\n  updateModel() {\n    const handles = [...this.handles.values()];\n    const getRangeAndClamp = (index) => {\n      const handle = handles[index];\n      const previous = handles[index - 1];\n      const next = handles[index + 1];\n      const min = typeof handle.min === \"number\" ? handle.min : this.host.min;\n      const max = typeof handle.max === \"number\" ? handle.max : this.host.max;\n      const result = {\n        range: { min, max },\n        clamp: { min, max }\n      };\n      if (handle.min === \"previous\") {\n        if (previous) {\n          for (let j = index - 1; j >= 0; j--) {\n            const item = handles[j];\n            if (typeof item.min === \"number\") {\n              result.range.min = item.min;\n              break;\n            }\n          }\n          result.clamp.min = Math.max(\n            previous.value,\n            result.range.min\n          );\n        }\n        if (true) {\n          if (!previous) {\n            window.__swc.warn(\n              this.host,\n              `<sp-slider-handle> elements that are the first child of an <sp-slider> element cannot have attribute \"min='previous'\"\\``,\n              \"https://opensource.adobe.com/spectrum-web-components/components/slider-handle/#multi-handle-slider-with-ordered-handles\"\n            );\n          }\n        }\n      }\n      if (handle.max === \"next\") {\n        if (next) {\n          for (let j = index + 1; j < handles.length; j++) {\n            const item = handles[j];\n            if (typeof item.max === \"number\") {\n              result.range.max = item.max;\n              break;\n            }\n          }\n          result.clamp.max = Math.min(next.value, result.range.max);\n        }\n        if (true) {\n          if (!next) {\n            window.__swc.warn(\n              this.host,\n              `<sp-slider-handle> elements that are the last child of an <sp-slider> element cannot have attribute \"max='next'\"`,\n              \"https://opensource.adobe.com/spectrum-web-components/components/slider-handle/#multi-handle-slider-with-ordered-handles\"\n            );\n          }\n        }\n      }\n      return result;\n    };\n    const modelValues = handles.map((handle, index) => {\n      var _a;\n      const rangeAndClamp = getRangeAndClamp(index);\n      const { toNormalized } = handle.normalization;\n      const clampedValue = Math.max(\n        Math.min(handle.value, rangeAndClamp.clamp.max),\n        rangeAndClamp.clamp.min\n      );\n      const normalizedValue = toNormalized(\n        clampedValue,\n        rangeAndClamp.range.min,\n        rangeAndClamp.range.max\n      );\n      const model = {\n        name: handle.handleName,\n        value: clampedValue,\n        normalizedValue,\n        highlight: handle.highlight,\n        step: (_a = handle.step) != null ? _a : this.host.step,\n        normalization: handle.normalization,\n        handle,\n        ariaLabel: handle !== this.host && (handle == null ? void 0 : handle.label.length) > 0 ? handle.label : void 0,\n        ...rangeAndClamp\n      };\n      return model;\n    });\n    this.model = modelValues;\n  }\n  async handleUpdatesComplete() {\n    const updates = [...this.handles.values()].filter((handle) => handle !== this.host).map((handle) => handle.updateComplete);\n    await Promise.all(updates);\n  }\n}\n//# sourceMappingURL=HandleController.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  nothing,\n  SizedMixin\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport {\n  classMap,\n  ifDefined,\n  repeat,\n  styleMap\n} from \"@spectrum-web-components/base/src/directives.js\";\nimport sliderStyles from \"./slider.css.js\";\nimport { ObserveSlotText } from \"@spectrum-web-components/shared/src/observe-slot-text.js\";\nimport \"@spectrum-web-components/field-label/sp-field-label.js\";\nimport { HandleController } from \"./HandleController.dev.js\";\nimport { SliderHandle } from \"./SliderHandle.dev.js\";\nimport { streamingListener } from \"@spectrum-web-components/base/src/streaming-listener.js\";\nexport const variants = [\"filled\", \"ramp\", \"range\", \"tick\"];\nexport class Slider extends SizedMixin(ObserveSlotText(SliderHandle, \"\"), {\n  noDefaultSize: true,\n  validSizes: [\"s\", \"m\", \"l\", \"xl\"]\n}) {\n  constructor() {\n    super(...arguments);\n    this.handleController = new HandleController(\n      this\n    );\n    this._editable = false;\n    this.hideStepper = false;\n    this.type = \"\";\n    /* Ensure that a '' value for `variant` removes the attribute instead of a blank value */\n    this._variant = \"\";\n    this.getAriaValueText = (values) => {\n      const valueArray = [...values.values()];\n      if (valueArray.length === 2)\n        return `${valueArray[0]} - ${valueArray[1]}`;\n      return valueArray.join(\", \");\n    };\n    this.min = 0;\n    this.max = 100;\n    this.step = 1;\n    this.tickStep = 0;\n    this.tickLabels = false;\n    this.disabled = false;\n    this.quiet = false;\n    this.indeterminate = false;\n    this._numberFieldInput = Promise.resolve();\n  }\n  static get styles() {\n    return [sliderStyles];\n  }\n  get editable() {\n    return this._editable;\n  }\n  set editable(editable) {\n    if (editable === this.editable) return;\n    const oldValue = this.editable;\n    this._editable = this.handleController.size < 2 ? editable : false;\n    if (this.editable) {\n      this._numberFieldInput = import(\"@spectrum-web-components/number-field/sp-number-field.js\");\n    }\n    if (oldValue !== this.editable) {\n      this.requestUpdate(\"editable\", oldValue);\n    }\n  }\n  set variant(variant) {\n    const oldVariant = this.variant;\n    if (variant === this.variant) {\n      return;\n    }\n    if (variants.includes(variant) && this.fillStart === void 0) {\n      this._variant = variant;\n      this.setAttribute(\"variant\", variant);\n    } else {\n      this._variant = \"\";\n      this.removeAttribute(\"variant\");\n    }\n    this.requestUpdate(\"variant\", oldVariant);\n  }\n  get variant() {\n    return this._variant;\n  }\n  get values() {\n    return this.handleController.values;\n  }\n  get handleName() {\n    return \"value\";\n  }\n  get ariaValueText() {\n    if (!this.getAriaValueText) {\n      return `${this.value}${this._forcedUnit}`;\n    }\n    return this.getAriaValueText(this.handleController.formattedValues);\n  }\n  get numberFormat() {\n    return this.getNumberFormat();\n  }\n  get focusElement() {\n    return this.handleController.focusElement;\n  }\n  handleLabelClick(event) {\n    if (this.editable) {\n      event.preventDefault();\n      this.focus();\n    }\n  }\n  render() {\n    return html`\n            ${this.renderLabel()} ${this.renderTrack()}\n            ${this.editable ? html`\n                      <sp-number-field\n                          .formatOptions=${this.formatOptions || {}}\n                          id=\"number-field\"\n                          min=${this.min}\n                          max=${this.max}\n                          step=${this.step}\n                          size=${this.size}\n                          value=${this.value}\n                          ?hide-stepper=${this.hideStepper}\n                          ?disabled=${this.disabled}\n                          ?quiet=${this.quiet}\n                          ?indeterminate=${this.indeterminate}\n                          @input=${this.handleNumberInput}\n                          @change=${this.handleNumberChange}\n                      ></sp-number-field>\n                  ` : nothing}\n        `;\n  }\n  connectedCallback() {\n    var _a;\n    super.connectedCallback();\n    this.handleController.hostConnected();\n    if ((_a = this.textContent) == null ? void 0 : _a.trim()) {\n      window.__swc.warn(\n        this,\n        `The default slot for text label in <${this.localName}> has been deprecated and will be removed in a future release. Use the \"label\" property instead.`,\n        \"https://opensource.adobe.com/spectrum-web-components/components/slider/\",\n        { level: \"deprecation\" }\n      );\n    }\n  }\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this.handleController.hostDisconnected();\n  }\n  update(changedProperties) {\n    this.handleController.hostUpdate();\n    if (changedProperties.has(\"disabled\") && this.disabled) {\n      this.handleController.cancelDrag();\n    }\n    super.update(changedProperties);\n  }\n  renderLabel() {\n    const textLabelVisible = this.labelVisibility === \"none\" || this.labelVisibility === \"value\";\n    const valueLabelVisible = this.labelVisibility === \"none\" || this.labelVisibility === \"text\";\n    return html`\n            <div id=\"label-container\">\n                <sp-field-label\n                    class=${classMap({\n      \"visually-hidden\": textLabelVisible\n    })}\n                    ?disabled=${this.disabled}\n                    id=\"label\"\n                    for=${this.editable ? \"number-field\" : this.handleController.activeHandleInputId}\n                    @click=${this.handleLabelClick}\n                    size=${this.size}\n                >\n                    ${this.slotHasContent ? nothing : html`\n                              <span>${this.label}</span>\n                          `}\n                    <slot></slot>\n                </sp-field-label>\n                <sp-field-label\n                    class=${classMap({\n      \"visually-hidden\": valueLabelVisible\n    })}\n                    ?disabled=${this.disabled}\n                    for=${this.editable ? \"number-field\" : this.handleController.activeHandleInputId}\n                    size=${this.size}\n                >\n                    <output id=\"value\" aria-live=\"off\" for=\"input\">\n                        ${this.ariaValueText}\n                    </output>\n                </sp-field-label>\n            </div>\n        `;\n  }\n  renderRamp() {\n    if (this.variant !== \"ramp\") {\n      return html``;\n    }\n    return html`\n            <div id=\"ramp\">\n                <svg\n                    viewBox=\"0 0 240 16\"\n                    preserveAspectRatio=\"none\"\n                    aria-hidden=\"true\"\n                    focusable=\"false\"\n                >\n                    <path\n                        d=\"M240,4v8c0,2.3-1.9,4.1-4.2,4L1,9C0.4,9,0,8.5,0,8c0-0.5,0.4-1,1-1l234.8-7C238.1-0.1,240,1.7,240,4z\"\n                    ></path>\n                </svg>\n            </div>\n        `;\n  }\n  renderTicks() {\n    if (this.variant !== \"tick\") {\n      return html``;\n    }\n    const tickStep = this.tickStep || this.step;\n    const tickCount = (this.max - this.min) / tickStep;\n    const partialFit = tickCount % 1 !== 0;\n    const ticks = new Array(Math.floor(tickCount + 1));\n    ticks.fill(0, 0, tickCount + 1);\n    return html`\n            <div\n                class=\"${partialFit ? \"not-exact \" : \"\"}ticks\"\n                style=${ifDefined(\n      partialFit ? `--sp-slider-tick-offset: calc(100% / ${this.max} * ${this.tickStep}` : void 0\n    )}\n            >\n                ${ticks.map(\n      (_tick, i) => html`\n                        <div class=\"tick\">\n                            ${this.tickLabels ? html`\n                                      <div class=\"tickLabel\">\n                                          ${i * tickStep + this.min}\n                                      </div>\n                                  ` : nothing}\n                        </div>\n                    `\n    )}\n            </div>\n        `;\n  }\n  renderTrackSegment(start, end) {\n    if (this.variant === \"ramp\") {\n      return html``;\n    }\n    return html`\n            <div\n                class=\"track\"\n                style=${styleMap(this.trackSegmentStyles(start, end))}\n                role=\"presentation\"\n            ></div>\n        `;\n  }\n  /**\n   * @description calculates the fill width\n   * @param fillStartValue\n   * @param currentValue\n   * @returns\n   */\n  getOffsetWidth(fillStartValue, currentValue) {\n    const distance = Math.abs(currentValue - fillStartValue);\n    return distance * 100;\n  }\n  fillStyles(centerPoint) {\n    const activeModel = this.handleController.activeHandleModel;\n    const centerPointNormalized = activeModel.normalization.toNormalized(\n      centerPoint,\n      this.min,\n      this.max\n    );\n    const position = this.dir === \"rtl\" ? \"right\" : \"left\";\n    const offsetPosition = (this.value > centerPoint ? centerPointNormalized : activeModel.normalizedValue) * 100;\n    const offsetWidth = this.getOffsetWidth(\n      centerPointNormalized,\n      activeModel.normalizedValue\n    );\n    const styles = {\n      [position]: `${offsetPosition}%`,\n      width: `${offsetWidth}%`\n    };\n    return styles;\n  }\n  renderFillOffset() {\n    if (this._cachedValue === void 0 || this.centerPoint === void 0) {\n      return html``;\n    }\n    return html`\n            <div\n                class=${classMap({\n      fill: true,\n      offset: this.value > this.centerPoint\n    })}\n                style=${styleMap(this.fillStyles(this.centerPoint))}\n            ></div>\n        `;\n  }\n  renderHandle() {\n    if (this.variant === \"tick\") {\n      return html``;\n    }\n    return html`\n            ${this.handleController.render()}\n        `;\n  }\n  renderTrack() {\n    const segments = this.handleController.trackSegments();\n    const handleItems = [\n      { id: \"handles\", html: this.handleController.render() }\n    ];\n    const trackItems = [\n      { id: \"track0\", html: this.renderTrackSegment(...segments[0]) },\n      { id: \"fill\", html: this.renderFillOffset() },\n      { id: \"ramp\", html: this.renderRamp() },\n      { id: \"handles\", html: this.renderHandle() },\n      ...segments.slice(1).map(([start, end], index) => ({\n        id: `track${index + 1}`,\n        html: this.renderTrackSegment(start, end)\n      }))\n    ];\n    return html`\n            <div\n                id=\"track\"\n                ${streamingListener({\n      start: [\"pointerdown\", this.handlePointerdown],\n      streamInside: [\"pointermove\", this.handlePointermove],\n      end: [\n        [\"pointerup\", \"pointercancel\", \"pointerleave\"],\n        this.handlePointerup\n      ],\n      streamOutside: [\"dblclick\", this.handleDoubleClick]\n    })}\n            >\n                <div id=\"controls\">\n                    ${this.variant === \"tick\" ? html`\n                              ${this.renderTicks()}\n                              <div class=\"trackContainer\">\n                                  ${repeat(\n      trackItems,\n      (item) => item.id,\n      (item) => item.html\n    )}\n                              </div>\n                              <div class=\"handleContainer\">\n                                  ${repeat(\n      handleItems,\n      (item) => item.id,\n      (item) => item.html\n    )}\n                              </div>\n                          ` : html`\n                              ${repeat(\n      trackItems,\n      (item) => item.id,\n      (item) => item.html\n    )}\n                          `}\n                </div>\n            </div>\n        `;\n  }\n  handleDoubleClick(event) {\n    this.handleController.handleDoubleClick(event);\n  }\n  handlePointerdown(event) {\n    this.handleController.handlePointerdown(event);\n  }\n  handlePointermove(event) {\n    this.handleController.handlePointermove(event);\n  }\n  handlePointerup(event) {\n    this.handleController.handlePointerup(event);\n  }\n  handleNumberInput(event) {\n    var _a;\n    const { value } = event.target;\n    if (((_a = event.target) == null ? void 0 : _a.managedInput) && !isNaN(value)) {\n      this.value = value;\n      return;\n    }\n    event.stopPropagation();\n  }\n  handleNumberChange(event) {\n    var _a;\n    const { value } = event.target;\n    if (isNaN(value)) {\n      event.target.value = this.value;\n      event.stopPropagation();\n    } else {\n      this.value = value;\n      if (!((_a = event.target) == null ? void 0 : _a.managedInput)) {\n        this.dispatchInputEvent();\n      }\n    }\n    this.indeterminate = false;\n  }\n  trackSegmentStyles(start, end) {\n    const size = end - start;\n    const styles = {\n      width: `${size * 100}%`,\n      \"--spectrum-slider-track-background-size\": `${1 / size * 100}%`,\n      \"--spectrum-slider-track-segment-position\": `${start * 100}%`\n    };\n    return styles;\n  }\n  async getUpdateComplete() {\n    const complete = await super.getUpdateComplete();\n    if (this.editable) {\n      await this._numberFieldInput;\n      await this.numberField.updateComplete;\n    }\n    await this.handleController.handleUpdatesComplete();\n    return complete;\n  }\n  willUpdate(changed) {\n    if (changed.has(\"value\") && changed.has(\"fillStart\")) {\n      this._cachedValue = Number(this.value);\n      if (this.getAttribute(\"fill-start\") === \"\") {\n        this.centerPoint = (Number(this.max) - Number(this.min)) / 2 + Number(this.min);\n      } else if (!Number.isNaN(Number(this.fillStart))) {\n        this.centerPoint = Number(this.fillStart);\n      }\n    }\n  }\n}\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Slider.prototype, \"editable\", 1);\n__decorateClass([\n  property({ type: Boolean, reflect: true, attribute: \"hide-stepper\" })\n], Slider.prototype, \"hideStepper\", 2);\n__decorateClass([\n  property()\n], Slider.prototype, \"type\", 2);\n__decorateClass([\n  property({ reflect: true })\n], Slider.prototype, \"dir\", 2);\n__decorateClass([\n  property({ type: String })\n], Slider.prototype, \"variant\", 1);\n__decorateClass([\n  property({ attribute: false })\n], Slider.prototype, \"getAriaValueText\", 2);\n__decorateClass([\n  property({ type: String, reflect: true, attribute: \"label-visibility\" })\n], Slider.prototype, \"labelVisibility\", 2);\n__decorateClass([\n  property({ type: Number, reflect: true })\n], Slider.prototype, \"min\", 2);\n__decorateClass([\n  property({ type: Number, reflect: true })\n], Slider.prototype, \"max\", 2);\n__decorateClass([\n  property({ type: Number })\n], Slider.prototype, \"step\", 2);\n__decorateClass([\n  property({ type: Number, attribute: \"tick-step\" })\n], Slider.prototype, \"tickStep\", 2);\n__decorateClass([\n  property({ type: Boolean, attribute: \"tick-labels\" })\n], Slider.prototype, \"tickLabels\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Slider.prototype, \"disabled\", 2);\n__decorateClass([\n  property({ type: Number, reflect: true, attribute: \"fill-start\" })\n], Slider.prototype, \"fillStart\", 2);\n__decorateClass([\n  property({ type: Boolean })\n], Slider.prototype, \"quiet\", 2);\n__decorateClass([\n  property({ type: Boolean })\n], Slider.prototype, \"indeterminate\", 2);\n__decorateClass([\n  query(\"#label\")\n], Slider.prototype, \"labelEl\", 2);\n__decorateClass([\n  query(\"#number-field\")\n], Slider.prototype, \"numberField\", 2);\n__decorateClass([\n  query(\"#track\")\n], Slider.prototype, \"track\", 2);\n//# sourceMappingURL=Slider.dev.js.map\n"],"names":[],"sourceRoot":""}