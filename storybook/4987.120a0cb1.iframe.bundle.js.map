{"version":3,"file":"4987.120a0cb1.iframe.bundle.js","mappings":";;AACA;;;AAuMA;AACA;AACA;AACA;;;;;;AAOA;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAIA","sources":["webpack://@adobe/spectrum-web-components/./packages/tooltip/src/Tooltip.dev.js"],"sourcesContent":["\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport { ifDefined } from \"@spectrum-web-components/base/src/directives.js\";\nimport { DependencyManagerController } from \"@spectrum-web-components/reactive-controllers/src/DependencyManger.js\";\nimport { focusableSelector } from \"@spectrum-web-components/shared/src/focusable-selectors.js\";\nimport tooltipStyles from \"./tooltip.css.js\";\nclass TooltipOpenable extends HTMLElement {\n  constructor() {\n    super();\n    this._open = false;\n    this._placement = \"top\";\n    this.addEventListener(\"sp-opened\", this.redispatchEvent);\n    this.addEventListener(\"sp-closed\", this.redispatchEvent);\n  }\n  redispatchEvent(event) {\n    event.stopPropagation();\n    this.tooltip.dispatchEvent(\n      new CustomEvent(event.type, {\n        bubbles: event.bubbles,\n        composed: event.composed,\n        detail: event.detail\n      })\n    );\n  }\n  get tooltip() {\n    return this.getRootNode().host;\n  }\n  static get observedAttributes() {\n    return [\"open\", \"placement\"];\n  }\n  attributeChangedCallback(name, _oldValue, newValue) {\n    switch (name) {\n      case \"open\":\n        this.open = newValue !== null;\n        break;\n      case \"placement\":\n        this.placement = newValue;\n        break;\n    }\n  }\n  set open(open) {\n    this._open = open;\n    const { tooltip } = this;\n    if (!tooltip) {\n      return;\n    }\n    tooltip.open = open;\n  }\n  /* c8 ignore next 3 */\n  get open() {\n    return this._open;\n  }\n  /**\n   * @type {\"top\" | \"top-start\" | \"top-end\" | \"right\" | \"right-start\" | \"right-end\" | \"bottom\" | \"bottom-start\" | \"bottom-end\" | \"left\" | \"left-start\" | \"left-end\"}\n   * @attr\n   */\n  set placement(placement) {\n    this._placement = placement;\n    const { tooltip } = this;\n    if (!tooltip) {\n      return;\n    }\n    tooltip.placement = placement;\n  }\n  /* c8 ignore next 3 */\n  get placement() {\n    return this._placement;\n  }\n  get tipElement() {\n    return this.tooltip.tipElement;\n  }\n}\nif (!customElements.get(\"sp-tooltip-openable\")) {\n  customElements.define(\"sp-tooltip-openable\", TooltipOpenable);\n}\nexport class Tooltip extends SpectrumElement {\n  constructor() {\n    super(...arguments);\n    this.delayed = false;\n    this.dependencyManager = new DependencyManagerController(this);\n    this.disabled = false;\n    this.selfManaged = false;\n    this.offset = 0;\n    this.open = false;\n    /* Ensure that a '' value for `variant` removes the attribute instead of a blank value */\n    this._variant = \"\";\n    this.handleOpenOverlay = () => {\n      this.open = true;\n    };\n    this.handleCloseOverlay = () => {\n      this.open = false;\n    };\n  }\n  static get styles() {\n    return [tooltipStyles];\n  }\n  get variant() {\n    return this._variant;\n  }\n  set variant(variant) {\n    if (variant === this.variant) {\n      return;\n    }\n    if ([\"info\", \"positive\", \"negative\"].includes(variant)) {\n      this.setAttribute(\"variant\", variant);\n      this._variant = variant;\n      return;\n    }\n    this.removeAttribute(\"variant\");\n    this._variant = \"\";\n  }\n  forwardTransitionEvent(event) {\n    this.dispatchEvent(\n      new TransitionEvent(event.type, {\n        bubbles: true,\n        composed: true,\n        propertyName: event.propertyName\n      })\n    );\n  }\n  /**\n   * Finds the trigger element for a self-managed tooltip by traversing up the composed DOM tree.\n   *\n   * Self-managed tooltips automatically bind to their first focusable ancestor element.\n   * This method walks up through shadow DOM boundaries to find a suitable trigger element.\n   *\n   * A trigger element must match the focusableSelector, which includes:\n   * - Interactive elements like buttons, inputs, links, etc.\n   * - Elements with tabindex (except -1)\n   * - Elements with focusable=\"true\"\n   *\n   * Common scenarios where no trigger element is found:\n   * 1. Tooltip is placed directly in document body without a focusable parent\n   * 2. Tooltip is nested in non-interactive elements (divs, spans) without focusable ancestors\n   * 3. All ancestor elements have tabindex=\"-1\" or are otherwise non-focusable\n   *\n   * Expected usage: <sp-action-button><sp-tooltip self-managed>...</sp-tooltip></sp-action-button>\n   *\n   * @returns The first focusable ancestor element, or null if none found\n   */\n  get triggerElement() {\n    var _a;\n    let start = this.assignedSlot || this;\n    let root = start.getRootNode();\n    if (root === document) {\n      if (true) {\n        window.__swc.warn(\n          this,\n          `[INITIAL_TRAVERSAL] Self-managed <${this.localName}> is at document root without a parent element. Self-managed tooltips must be nested inside focusable elements like <sp-action-button>, <sp-button>, or elements with tabindex.`,\n          \"https://opensource.adobe.com/spectrum-web-components/components/tooltip#self-managed-overlays\",\n          {\n            level: \"high\"\n          }\n        );\n      }\n      return null;\n    }\n    let triggerElement = start.parentElement || root.host || root;\n    while (!((_a = triggerElement == null ? void 0 : triggerElement.matches) == null ? void 0 : _a.call(triggerElement, focusableSelector))) {\n      start = triggerElement.assignedSlot || triggerElement;\n      root = start.getRootNode();\n      if (root === document) {\n        if (true) {\n          window.__swc.warn(\n            this,\n            `[TRAVERSAL_EXHAUSTED] Self-managed <${this.localName}> could not find a focusable trigger element. All ancestor elements are non-focusable. Ensure the tooltip is nested inside an interactive element like <sp-action-button>, <sp-button>, or add tabindex=\"0\" to a parent element.`,\n            \"https://opensource.adobe.com/spectrum-web-components/components/tooltip#self-managed-overlays\",\n            {\n              level: \"high\"\n            }\n          );\n        }\n        return null;\n      }\n      triggerElement = start.parentElement || root.host || /* c8 ignore next 1 */\n      root;\n    }\n    return triggerElement;\n  }\n  render() {\n    const tooltip = html`\n            <sp-tooltip-openable\n                id=\"tooltip\"\n                placement=${ifDefined(this.placement)}\n                @transitionrun=${this.forwardTransitionEvent}\n                @transitionend=${this.forwardTransitionEvent}\n                @transitioncancel=${this.forwardTransitionEvent}\n            >\n                <slot name=\"icon\"></slot>\n                <span id=\"label\"><slot></slot></span>\n                <span id=\"tip\" aria-hidden=\"true\"></span>\n            </sp-tooltip-openable>\n        `;\n    if (this.selfManaged) {\n      this.dependencyManager.add(\"sp-overlay\");\n      import(\"@spectrum-web-components/overlay/sp-overlay.js\");\n      return html`\n                <sp-overlay\n                    ?open=${this.open && !this.disabled && this.dependencyManager.loaded}\n                    ?delayed=${this.delayed}\n                    ?disabled=${this.disabled}\n                    offset=${this.offset}\n                    .placement=${this.placement}\n                    type=\"hint\"\n                    .tipPadding=${this.tipPadding}\n                    .triggerInteraction=${\"hover\"}\n                    @sp-opened=${this.handleOpenOverlay}\n                    @sp-closed=${this.handleCloseOverlay}\n                >\n                    ${tooltip}\n                </sp-overlay>\n            `;\n    } else {\n      return tooltip;\n    }\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    this.updateComplete.then(() => {\n      if (!this.selfManaged) {\n        return;\n      }\n      const overlayElement = this.overlayElement;\n      if (overlayElement) {\n        const triggerElement = this.triggerElement;\n        overlayElement.triggerElement = triggerElement;\n      }\n    });\n  }\n}\n__decorateClass([\n  property({ type: Boolean })\n], Tooltip.prototype, \"delayed\", 2);\n__decorateClass([\n  property({ type: Boolean })\n], Tooltip.prototype, \"disabled\", 2);\n__decorateClass([\n  property({ type: Boolean, attribute: \"self-managed\" })\n], Tooltip.prototype, \"selfManaged\", 2);\n__decorateClass([\n  property({ type: Number })\n], Tooltip.prototype, \"offset\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Tooltip.prototype, \"open\", 2);\n__decorateClass([\n  query(\"sp-overlay\")\n], Tooltip.prototype, \"overlayElement\", 2);\n__decorateClass([\n  property({ reflect: true })\n], Tooltip.prototype, \"placement\", 2);\n__decorateClass([\n  query(\"#tip\")\n], Tooltip.prototype, \"tipElement\", 2);\n__decorateClass([\n  property({ type: Number })\n], Tooltip.prototype, \"tipPadding\", 2);\n__decorateClass([\n  property({ type: String })\n], Tooltip.prototype, \"variant\", 1);\n//# sourceMappingURL=Tooltip.dev.js.map\n"],"names":[],"sourceRoot":""}