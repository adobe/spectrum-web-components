{"version":3,"file":"3597.efd31734.iframe.bundle.js","mappings":";;;AAGA;;;AAGA;AACA;AACA;;;;;ACRA;;ACEA;AACA;AACA;;;AAGA;;;;;ACPA;;;ACGA;;;AAGA;AACA;AACA;;;;;;;ACNA;AACA;AACA;;;AAGA;;;;;;;;;AC8DA;;AAGA;;AAEA;;AAGA;;AAEA;;AAGA;;AAEA;;AAIA;AA+bA;AACA;;;AAGA;AACA;AACA;;;;;;;AA2BA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;AAOA;AACA;;AAEA;AACA;AACA;;AAEA;;;;AAKA","sources":["webpack://@adobe/spectrum-web-components/./packages/icons-ui/src/icons-s2/Chevron200.js","webpack://@adobe/spectrum-web-components/./packages/icons-ui/src/elements/IconChevron200.js","webpack://@adobe/spectrum-web-components/./packages/icons-ui/src/icons-s2/Chevron50.js","webpack://@adobe/spectrum-web-components/./packages/icons-ui/src/elements/IconChevron50.js","webpack://@adobe/spectrum-web-components/./packages/icons-ui/src/icons/Chevron200.js","webpack://@adobe/spectrum-web-components/./packages/icons-ui/src/icons/Chevron50.js","webpack://@adobe/spectrum-web-components/./packages/number-field/src/NumberField.dev.js"],"sourcesContent":["\"use strict\";import{tag as l}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const Chevron200Icon=({width:e=24,height:t=24,hidden:r=!1,title:a=\"Chevron200\"}={})=>l`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 12 12\"\n    aria-hidden=${r?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${a}\"\n    width=\"${e}\"\n    height=\"${t}\"\n  >\n    <path\n      d=\"M9.034 5.356 4.343.663a.911.911 0 0 0-1.29 1.289L7.102 6l-4.047 4.047a.911.911 0 1 0 1.289 1.29l4.691-4.692a.91.91 0 0 0 0-1.29z\"\n    />\n  </svg>`;\n//# sourceMappingURL=Chevron200.js.map\n","\"use strict\";import{html as e}from\"@spectrum-web-components/base\";import{IconBase as t}from\"@spectrum-web-components/icon\";import{setCustomTemplateLiteralTag as r}from\"../custom-tag.js\";import{Chevron200Icon as o}from\"../icons-s2/Chevron200.js\";import{Chevron200Icon as l}from\"../icons/Chevron200.js\";export class IconChevron200 extends t{render(){return r(e),this.spectrumVersion===2?o({hidden:!this.label,title:this.label}):l({hidden:!this.label,title:this.label})}}\n//# sourceMappingURL=IconChevron200.js.map\n","\"use strict\";import{tag as l}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const Chevron50Icon=({width:e=24,height:t=24,hidden:r=!1,title:a=\"Chevron50\"}={})=>l`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${e}\"\n    height=\"${t}\"\n    aria-hidden=${r?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${a}\"\n  >\n    <path\n      d=\"M1.985 5.961a.695.695 0 0 1-.7-.704.7.7 0 0 1 .209-.493L3.279 3 1.51 1.251A.7.7 0 0 1 1.3.757.696.696 0 0 1 2.492.255l2.275 2.247a.7.7 0 0 1 0 .996L2.477 5.76a.7.7 0 0 1-.492.201\"\n    />\n  </svg>`;\n//# sourceMappingURL=Chevron50.js.map\n","\"use strict\";import{html as e}from\"@spectrum-web-components/base\";import{IconBase as t}from\"@spectrum-web-components/icon\";import{setCustomTemplateLiteralTag as r}from\"../custom-tag.js\";import{Chevron50Icon as o}from\"../icons-s2/Chevron50.js\";import{Chevron50Icon as l}from\"../icons/Chevron50.js\";export class IconChevron50 extends t{render(){return r(e),this.spectrumVersion===2?o({hidden:!this.label,title:this.label}):l({hidden:!this.label,title:this.label})}}\n//# sourceMappingURL=IconChevron50.js.map\n","\"use strict\";import{tag as l}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const Chevron200Icon=({width:e=24,height:t=24,hidden:r=!1,title:a=\"Chevron200\"}={})=>l`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    viewBox=\"0 0 12 12\"\n    aria-hidden=${r?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${a}\"\n    width=\"${e}\"\n    height=\"${t}\"\n  >\n    <path\n      d=\"M9.034 5.356 4.343.663a.911.911 0 0 0-1.29 1.289L7.102 6l-4.047 4.047a.911.911 0 1 0 1.289 1.29l4.691-4.692a.91.91 0 0 0 0-1.29z\"\n    />\n  </svg>`;\n//# sourceMappingURL=Chevron200.js.map\n","\"use strict\";import{tag as l}from\"../custom-tag.js\";export{setCustomTemplateLiteralTag}from\"../custom-tag.js\";export const Chevron50Icon=({width:e=24,height:t=24,hidden:r=!1,title:a=\"Chevron50\"}={})=>l`<svg\n    xmlns=\"http://www.w3.org/2000/svg\"\n    width=\"${e}\"\n    height=\"${t}\"\n    aria-hidden=${r?\"true\":\"false\"}\n    role=\"img\"\n    fill=\"currentColor\"\n    aria-label=\"${a}\"\n  >\n    <path\n      d=\"M1.985 5.961a.695.695 0 0 1-.7-.704.7.7 0 0 1 .209-.493L3.279 3 1.51 1.251A.7.7 0 0 1 1.3.757.696.696 0 0 1 2.492.255l2.275 2.247a.7.7 0 0 1 0 .996L2.477 5.76a.7.7 0 0 1-.492.201\"\n    />\n  </svg>`;\n//# sourceMappingURL=Chevron50.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport { NumberFormatter, NumberParser } from \"@internationalized/number\";\nimport {\n  html,\n  nothing\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport { streamingListener } from \"@spectrum-web-components/base/src/streaming-listener.js\";\nimport {\n  LanguageResolutionController,\n  languageResolverUpdatedSymbol\n} from \"@spectrum-web-components/reactive-controllers/src/LanguageResolution.js\";\nimport chevronStyles from \"@spectrum-web-components/icon/src/spectrum-icon-chevron.css.js\";\nimport \"@spectrum-web-components/icons-ui/icons/sp-icon-chevron100.js\";\nimport \"@spectrum-web-components/icons-ui/icons/sp-icon-chevron200.js\";\nimport \"@spectrum-web-components/icons-ui/icons/sp-icon-chevron50.js\";\nimport \"@spectrum-web-components/icons-ui/icons/sp-icon-chevron75.js\";\nimport \"@spectrum-web-components/infield-button/sp-infield-button.js\";\nimport { TextfieldBase } from \"@spectrum-web-components/textfield\";\nimport styles from \"./number-field.css.js\";\nimport { isAndroid, isIOS, isIPhone } from \"@spectrum-web-components/shared\";\nexport const FRAMES_PER_CHANGE = 5;\nexport const CHANGE_DEBOUNCE_MS = 100;\nexport const indeterminatePlaceholder = \"-\";\nexport const remapMultiByteCharacters = {\n  \"\\uFF11\": \"1\",\n  \"\\uFF12\": \"2\",\n  \"\\uFF13\": \"3\",\n  \"\\uFF14\": \"4\",\n  \"\\uFF15\": \"5\",\n  \"\\uFF16\": \"6\",\n  \"\\uFF17\": \"7\",\n  \"\\uFF18\": \"8\",\n  \"\\uFF19\": \"9\",\n  \"\\uFF10\": \"0\",\n  \"\\u3001\": \",\",\n  \"\\uFF0C\": \",\",\n  \"\\u3002\": \".\",\n  \"\\uFF0E\": \".\",\n  \"\\uFF05\": \"%\",\n  \"\\uFF0B\": \"+\",\n  \\u30FC: \"-\",\n  \\u4E00: \"1\",\n  \\u4E8C: \"2\",\n  \\u4E09: \"3\",\n  \\u56DB: \"4\",\n  \\u4E94: \"5\",\n  \\u516D: \"6\",\n  \\u4E03: \"7\",\n  \\u516B: \"8\",\n  \\u4E5D: \"9\",\n  \\u96F6: \"0\"\n};\nconst chevronIcon = {\n  s: (dir) => html`\n        <sp-icon-chevron50\n            class=\"stepper-icon spectrum-UIIcon-Chevron${dir}50\"\n        ></sp-icon-chevron50>\n    `,\n  m: (dir) => html`\n        <sp-icon-chevron75\n            class=\"stepper-icon spectrum-UIIcon-Chevron${dir}75\"\n        ></sp-icon-chevron75>\n    `,\n  l: (dir) => html`\n        <sp-icon-chevron100\n            class=\"stepper-icon spectrum-UIIcon-Chevron${dir}100\"\n        ></sp-icon-chevron100>\n    `,\n  xl: (dir) => html`\n        <sp-icon-chevron200\n            class=\"stepper-icon spectrum-UIIcon-Chevron${dir}200\"\n        ></sp-icon-chevron200>\n    `\n};\nexport class NumberField extends TextfieldBase {\n  constructor() {\n    super(...arguments);\n    this.focused = false;\n    this._forcedUnit = \"\";\n    this.formatOptions = {};\n    this.hideStepper = false;\n    this.indeterminate = false;\n    this.keyboardFocused = false;\n    this.managedInput = false;\n    this.stepModifier = 10;\n    this._value = NaN;\n    this._trackingValue = \"\";\n    this.decimalsChars = /* @__PURE__ */ new Set([\".\", \",\"]);\n    this.valueBeforeFocus = \"\";\n    this.isIntentDecimal = false;\n    this.changeCount = 0;\n    this.languageResolver = new LanguageResolutionController(this);\n    this.wasIndeterminate = false;\n    this.hasRecentlyReceivedPointerDown = false;\n    this.applyFocusElementLabel = (value) => {\n      this.appliedLabel = value;\n    };\n    this.isComposing = false;\n  }\n  static get styles() {\n    return [...super.styles, styles, chevronStyles];\n  }\n  set value(rawValue) {\n    const value = this.validateInput(rawValue);\n    if (value === this.value) {\n      return;\n    }\n    this.lastCommitedValue = value;\n    const oldValue = this._value;\n    this._value = value;\n    this.requestUpdate(\"value\", oldValue);\n  }\n  get value() {\n    return this._value;\n  }\n  get inputValue() {\n    return this.indeterminate ? this.formattedValue : this.inputElement.value;\n  }\n  setValue(newValue = this.value) {\n    const previousValue = this.lastCommitedValue;\n    this.value = newValue;\n    if (typeof previousValue === \"undefined\" || previousValue === this.value) {\n      return;\n    }\n    this.lastCommitedValue = this.value;\n    this.dispatchEvent(\n      new Event(\"change\", { bubbles: true, composed: true })\n    );\n  }\n  /**\n   * Retreive the value of the element parsed to a Number.\n   */\n  get valueAsString() {\n    return this._value.toString();\n  }\n  set valueAsString(value) {\n    this.value = this.numberParser.parse(value);\n  }\n  get formattedValue() {\n    if (isNaN(this.value)) return \"\";\n    return this.numberFormatter.format(this.value) + (this.focused ? \"\" : this._forcedUnit);\n  }\n  convertValueToNumber(inputValue) {\n    let normalizedValue = inputValue.split(\"\").map((char) => remapMultiByteCharacters[char] || char).join(\"\");\n    const separators = this.valueBeforeFocus.split(\"\").filter((char) => this.decimalsChars.has(char));\n    const uniqueSeparators = new Set(separators);\n    if (isIOS() && this.inputElement.inputMode === \"decimal\" && normalizedValue !== this.valueBeforeFocus) {\n      const parts = this.numberFormatter.formatToParts(1000.1);\n      const replacementDecimal = parts.find(\n        (part) => part.type === \"decimal\"\n      ).value;\n      for (const separator of uniqueSeparators) {\n        const isDecimalSeparator = separator === replacementDecimal;\n        if (!isDecimalSeparator && !this.isIntentDecimal) {\n          normalizedValue = normalizedValue.replace(\n            new RegExp(separator, \"g\"),\n            \"\"\n          );\n        }\n      }\n      let hasReplacedDecimal = false;\n      const valueChars = normalizedValue.split(\"\");\n      for (let index = valueChars.length - 1; index >= 0; index--) {\n        const char = valueChars[index];\n        if (this.decimalsChars.has(char)) {\n          if (!hasReplacedDecimal) {\n            valueChars[index] = replacementDecimal;\n            hasReplacedDecimal = true;\n          } else valueChars[index] = \"\";\n        }\n      }\n      normalizedValue = valueChars.join(\"\");\n    }\n    return this.numberParser.parse(normalizedValue);\n  }\n  get _step() {\n    var _a;\n    if (typeof this.step !== \"undefined\") {\n      return this.step;\n    }\n    if (((_a = this.formatOptions) == null ? void 0 : _a.style) === \"percent\") {\n      return 0.01;\n    }\n    return 1;\n  }\n  handlePointerdown(event) {\n    if (event.button !== 0) {\n      event.preventDefault();\n      return;\n    }\n    this.managedInput = true;\n    this.buttons.setPointerCapture(event.pointerId);\n    const stepUpRect = this.buttons.children[0].getBoundingClientRect();\n    const stepDownRect = this.buttons.children[1].getBoundingClientRect();\n    this.findChange = (event2) => {\n      if (event2.clientX >= stepUpRect.x && event2.clientY >= stepUpRect.y && event2.clientX <= stepUpRect.x + stepUpRect.width && event2.clientY <= stepUpRect.y + stepUpRect.height) {\n        this.change = (event3) => this.increment(event3.shiftKey ? this.stepModifier : 1);\n      } else if (event2.clientX >= stepDownRect.x && event2.clientY >= stepDownRect.y && event2.clientX <= stepDownRect.x + stepDownRect.width && event2.clientY <= stepDownRect.y + stepDownRect.height) {\n        this.change = (event3) => this.decrement(event3.shiftKey ? this.stepModifier : 1);\n      }\n    };\n    this.findChange(event);\n    this.startChange(event);\n  }\n  startChange(event) {\n    this.changeCount = 0;\n    this.doChange(event);\n    this.safty = setTimeout(() => {\n      this.doNextChange(event);\n    }, 400);\n  }\n  doChange(event) {\n    this.change(event);\n  }\n  handlePointermove(event) {\n    this.findChange(event);\n  }\n  handlePointerup(event) {\n    this.buttons.releasePointerCapture(event.pointerId);\n    cancelAnimationFrame(this.nextChange);\n    clearTimeout(this.safty);\n    this.managedInput = false;\n    this.setValue();\n  }\n  doNextChange(event) {\n    this.changeCount += 1;\n    if (this.changeCount % FRAMES_PER_CHANGE === 0) {\n      this.doChange(event);\n    }\n    return requestAnimationFrame(() => {\n      this.nextChange = this.doNextChange(event);\n    });\n  }\n  stepBy(count) {\n    if (this.disabled || this.readonly) {\n      return;\n    }\n    const min = typeof this.min !== \"undefined\" ? this.min : 0;\n    let value = this.value;\n    value += count * this._step;\n    if (isNaN(this.value)) {\n      value = min;\n    }\n    value = this.valueWithLimits(value);\n    this.requestUpdate();\n    this._value = this.validateInput(value);\n    this.inputElement.value = this.numberFormatter.format(value);\n    const inputEvent = new Event(\"input\", {\n      bubbles: true,\n      composed: true\n    });\n    this.inputElement.readOnly = true;\n    this.inputElement.dispatchEvent(inputEvent);\n    this.indeterminate = false;\n    this.focus();\n    this.inputElement.readOnly = false;\n  }\n  increment(factor = 1) {\n    this.stepBy(1 * factor);\n  }\n  decrement(factor = 1) {\n    this.stepBy(-1 * factor);\n  }\n  handleKeydown(event) {\n    if (this.isComposing) return;\n    switch (event.code) {\n      case \"ArrowUp\":\n        event.preventDefault();\n        this.increment(event.shiftKey ? this.stepModifier : 1);\n        this.setValue();\n        break;\n      case \"ArrowDown\":\n        event.preventDefault();\n        this.decrement(event.shiftKey ? this.stepModifier : 1);\n        this.setValue();\n        break;\n    }\n  }\n  onScroll(event) {\n    event.preventDefault();\n    this.managedInput = true;\n    const direction = event.shiftKey ? event.deltaX / Math.abs(event.deltaX) : event.deltaY / Math.abs(event.deltaY);\n    if (direction !== 0 && !isNaN(direction)) {\n      this.stepBy(direction * (event.shiftKey ? this.stepModifier : 1));\n      clearTimeout(this.queuedChangeEvent);\n      this.queuedChangeEvent = setTimeout(() => {\n        this.setValue();\n      }, CHANGE_DEBOUNCE_MS);\n    }\n    this.managedInput = false;\n  }\n  onFocus() {\n    super.onFocus();\n    this._trackingValue = this.inputValue;\n    this.keyboardFocused = !this.readonly && true;\n    this.addEventListener(\"wheel\", this.onScroll, { passive: false });\n    this.valueBeforeFocus = this.inputElement.value;\n  }\n  onBlur(_event) {\n    super.onBlur(_event);\n    this.keyboardFocused = !this.readonly && false;\n    this.removeEventListener(\"wheel\", this.onScroll);\n    this.isIntentDecimal = false;\n  }\n  handleFocusin() {\n    this.focused = !this.readonly && true;\n    this.keyboardFocused = !this.readonly && true;\n  }\n  handleFocusout() {\n    this.focused = !this.readonly && false;\n    this.keyboardFocused = !this.readonly && false;\n  }\n  handleChange() {\n    const value = this.convertValueToNumber(this.inputValue);\n    if (this.wasIndeterminate) {\n      this.wasIndeterminate = false;\n      this.indeterminateValue = void 0;\n      if (isNaN(value)) {\n        this.indeterminate = true;\n        return;\n      }\n    }\n    this.setValue(value);\n    this.inputElement.value = this.formattedValue;\n  }\n  handleCompositionStart() {\n    this.isComposing = true;\n  }\n  handleCompositionEnd() {\n    this.isComposing = false;\n    requestAnimationFrame(() => {\n      this.inputElement.dispatchEvent(\n        new Event(\"input\", {\n          composed: true,\n          bubbles: true\n        })\n      );\n    });\n  }\n  handleInputElementPointerdown() {\n    this.hasRecentlyReceivedPointerDown = true;\n    this.updateComplete.then(() => {\n      requestAnimationFrame(() => {\n        this.hasRecentlyReceivedPointerDown = false;\n      });\n    });\n  }\n  handleInput(event) {\n    var _a;\n    if (this.isComposing) {\n      if (event.data) {\n        const partialValue = this.convertValueToNumber(event.data);\n        if (Number.isNaN(partialValue)) {\n          this.inputElement.value = this.indeterminate ? indeterminatePlaceholder : this._trackingValue;\n          this.isComposing = false;\n        }\n      }\n      event.stopPropagation();\n      return;\n    }\n    if (this.indeterminate) {\n      this.wasIndeterminate = true;\n      this.indeterminateValue = this.value;\n      this.inputElement.value = this.inputElement.value.replace(\n        indeterminatePlaceholder,\n        \"\"\n      );\n    }\n    if (event.data && this.decimalsChars.has(event.data))\n      this.isIntentDecimal = true;\n    const { value: originalValue, selectionStart } = this.inputElement;\n    const value = originalValue.split(\"\").map((char) => remapMultiByteCharacters[char] || char).join(\"\");\n    if (this.numberParser.isValidPartialNumber(value)) {\n      this.lastCommitedValue = (_a = this.lastCommitedValue) != null ? _a : this.value;\n      const valueAsNumber = this.convertValueToNumber(value);\n      if (!value && this.indeterminateValue) {\n        this.indeterminate = true;\n        this._value = this.indeterminateValue;\n      } else {\n        this.indeterminate = false;\n        this._value = this.validateInput(valueAsNumber);\n      }\n      this._trackingValue = value;\n      this.inputElement.value = value;\n      this.inputElement.setSelectionRange(selectionStart, selectionStart);\n      return;\n    } else {\n      this.inputElement.value = this.indeterminate ? indeterminatePlaceholder : this._trackingValue;\n      event.stopPropagation();\n    }\n    const currentLength = value.length;\n    const previousLength = this._trackingValue.length;\n    const nextSelectStart = (selectionStart || currentLength) - (currentLength - previousLength);\n    this.inputElement.setSelectionRange(nextSelectStart, nextSelectStart);\n  }\n  valueWithLimits(nextValue) {\n    let value = nextValue;\n    if (typeof this.min !== \"undefined\") {\n      value = Math.max(this.min, value);\n    }\n    if (typeof this.max !== \"undefined\") {\n      value = Math.min(this.max, value);\n    }\n    return value;\n  }\n  validateInput(value) {\n    value = this.valueWithLimits(value);\n    const signMultiplier = value < 0 ? -1 : 1;\n    value *= signMultiplier;\n    if (this.step) {\n      const min = typeof this.min !== \"undefined\" ? this.min : 0;\n      const moduloStep = parseFloat(\n        this.valueFormatter.format((value - min) % this.step)\n      );\n      const fallsOnStep = moduloStep === 0;\n      if (!fallsOnStep) {\n        const overUnder = Math.round(moduloStep / this.step);\n        if (overUnder === 1) {\n          value += this.step - moduloStep;\n        } else {\n          value -= moduloStep;\n        }\n      }\n      if (typeof this.max !== \"undefined\") {\n        while (value > this.max) {\n          value -= this.step;\n        }\n      }\n      value = parseFloat(this.valueFormatter.format(value));\n    }\n    value *= signMultiplier;\n    return value;\n  }\n  get displayValue() {\n    const indeterminateValue = this.focused ? \"\" : indeterminatePlaceholder;\n    return this.indeterminate ? indeterminateValue : this.formattedValue;\n  }\n  clearNumberFormatterCache() {\n    this._numberFormatter = void 0;\n    this._numberParser = void 0;\n  }\n  get numberFormatter() {\n    if (!this._numberFormatter || !this._numberFormatterFocused) {\n      const {\n        style,\n        unit,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        unitDisplay,\n        ...formatOptionsNoUnit\n      } = this.formatOptions;\n      if (style !== \"unit\") {\n        formatOptionsNoUnit.style = style;\n      }\n      this._numberFormatterFocused = new NumberFormatter(\n        this.languageResolver.language,\n        formatOptionsNoUnit\n      );\n      try {\n        this._numberFormatter = new NumberFormatter(\n          this.languageResolver.language,\n          this.formatOptions\n        );\n        this._forcedUnit = \"\";\n        this._numberFormatter.format(1);\n      } catch (error) {\n        if (style === \"unit\") {\n          this._forcedUnit = unit;\n        }\n        this._numberFormatter = this._numberFormatterFocused;\n      }\n    }\n    return this.focused ? this._numberFormatterFocused : this._numberFormatter;\n  }\n  clearValueFormatterCache() {\n    this._valueFormatter = void 0;\n  }\n  get valueFormatter() {\n    if (!this._valueFormatter) {\n      const digitsAfterDecimal = this.step ? this.step != Math.floor(this.step) ? this.step.toString().split(\".\")[1].length : 0 : 0;\n      this._valueFormatter = new NumberFormatter(\"en\", {\n        useGrouping: false,\n        maximumFractionDigits: digitsAfterDecimal\n      });\n    }\n    return this._valueFormatter;\n  }\n  get numberParser() {\n    if (!this._numberParser || !this._numberParserFocused) {\n      const {\n        style,\n        unit,\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        unitDisplay,\n        ...formatOptionsNoUnit\n      } = this.formatOptions;\n      if (style !== \"unit\") {\n        formatOptionsNoUnit.style = style;\n      }\n      this._numberParserFocused = new NumberParser(\n        this.languageResolver.language,\n        formatOptionsNoUnit\n      );\n      try {\n        this._numberParser = new NumberParser(\n          this.languageResolver.language,\n          this.formatOptions\n        );\n        this._forcedUnit = \"\";\n        this._numberParser.parse(\"0\");\n      } catch (error) {\n        if (style === \"unit\") {\n          this._forcedUnit = unit;\n        }\n        this._numberParser = this._numberParserFocused;\n      }\n    }\n    return this.focused ? this._numberParserFocused : this._numberParser;\n  }\n  renderField() {\n    this.autocomplete = \"off\";\n    return html`\n            ${super.renderField()}\n            ${this.hideStepper ? nothing : html`\n                      <span\n                          class=\"buttons\"\n                          @focusin=${this.handleFocusin}\n                          @focusout=${this.handleFocusout}\n                          ${streamingListener({\n      start: [\"pointerdown\", this.handlePointerdown],\n      streamInside: [\n        [\n          \"pointermove\",\n          \"pointerenter\",\n          \"pointerleave\",\n          \"pointerover\",\n          \"pointerout\"\n        ],\n        this.handlePointermove\n      ],\n      end: [\n        [\n          \"pointerup\",\n          \"pointercancel\",\n          \"pointerleave\"\n        ],\n        this.handlePointerup\n      ]\n    })}\n                      >\n                          <sp-infield-button\n                              inline=\"end\"\n                              block=\"start\"\n                              class=\"button step-up\"\n                              aria-hidden=\"true\"\n                              label=${\"Increase \" + this.appliedLabel}\n                              size=${this.size}\n                              tabindex=\"-1\"\n                              ?focused=${this.focused}\n                              ?disabled=${this.disabled || this.readonly || typeof this.max !== \"undefined\" && this.value === this.max}\n                              ?quiet=${this.quiet}\n                          >\n                              ${chevronIcon[this.size](\"Up\")}\n                          </sp-infield-button>\n                          <sp-infield-button\n                              inline=\"end\"\n                              block=\"end\"\n                              class=\"button step-down\"\n                              aria-hidden=\"true\"\n                              label=${\"Decrease \" + this.appliedLabel}\n                              size=${this.size}\n                              tabindex=\"-1\"\n                              ?focused=${this.focused}\n                              ?disabled=${this.disabled || this.readonly || typeof this.min !== \"undefined\" && this.value === this.min}\n                              ?quiet=${this.quiet}\n                          >\n                              ${chevronIcon[this.size](\"Down\")}\n                          </sp-infield-button>\n                      </span>\n                  `}\n        `;\n  }\n  update(changes) {\n    if (changes.has(\"formatOptions\") || changes.has(\"resolvedLanguage\")) {\n      this.clearNumberFormatterCache();\n    }\n    if (changes.has(\"value\") || changes.has(\"max\") || changes.has(\"min\") || changes.has(\"step\")) {\n      const value = this.numberParser.parse(\n        this.formattedValue.replace(this._forcedUnit, \"\")\n      );\n      this.value = value;\n      this.clearValueFormatterCache();\n    }\n    super.update(changes);\n  }\n  willUpdate(changes) {\n    this.multiline = false;\n    if (changes.has(languageResolverUpdatedSymbol)) {\n      this.clearNumberFormatterCache();\n    }\n  }\n  firstUpdated(changes) {\n    super.firstUpdated(changes);\n    this.addEventListener(\"keydown\", this.handleKeydown);\n    this.addEventListener(\"compositionstart\", this.handleCompositionStart);\n    this.addEventListener(\"compositionend\", this.handleCompositionEnd);\n  }\n  updated(changes) {\n    if (!this.inputElement || !this.isConnected) {\n      return;\n    }\n    if (changes.has(\"min\") || changes.has(\"formatOptions\")) {\n      const hasOnlyPositives = typeof this.min !== \"undefined\" && this.min >= 0;\n      const { maximumFractionDigits } = this.numberFormatter.resolvedOptions();\n      const hasDecimals = maximumFractionDigits && maximumFractionDigits > 0;\n      let inputMode = \"numeric\";\n      if (isIPhone() && !hasOnlyPositives) inputMode = \"text\";\n      else if (isIOS() && hasDecimals) inputMode = \"decimal\";\n      else if (isAndroid() && hasDecimals && hasOnlyPositives)\n        inputMode = \"decimal\";\n      this.inputElement.inputMode = inputMode;\n    }\n    if (changes.has(\"focused\") && this.focused && !this.hasRecentlyReceivedPointerDown && !!this.formatOptions.unit) {\n      this.setSelectionRange(0, this.displayValue.length);\n    }\n  }\n}\n__decorateClass([\n  query(\".buttons\")\n], NumberField.prototype, \"buttons\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], NumberField.prototype, \"focused\", 2);\n__decorateClass([\n  property({ type: Object, attribute: \"format-options\" })\n], NumberField.prototype, \"formatOptions\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true, attribute: \"hide-stepper\" })\n], NumberField.prototype, \"hideStepper\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], NumberField.prototype, \"indeterminate\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true, attribute: \"keyboard-focused\" })\n], NumberField.prototype, \"keyboardFocused\", 2);\n__decorateClass([\n  property({ type: Number })\n], NumberField.prototype, \"max\", 2);\n__decorateClass([\n  property({ type: Number })\n], NumberField.prototype, \"min\", 2);\n__decorateClass([\n  property({ type: Number })\n], NumberField.prototype, \"step\", 2);\n__decorateClass([\n  property({ type: Number, reflect: true, attribute: \"step-modifier\" })\n], NumberField.prototype, \"stepModifier\", 2);\n__decorateClass([\n  property({ type: Number })\n], NumberField.prototype, \"value\", 1);\n//# sourceMappingURL=NumberField.dev.js.map\n"],"names":[],"sourceRoot":""}