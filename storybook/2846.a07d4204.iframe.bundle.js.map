{"version":3,"file":"2846.a07d4204.iframe.bundle.js","mappings":";;AACA;AAwSA;AAEA","sources":["webpack://@adobe/spectrum-web-components/./packages/action-group/src/ActionGroup.dev.js"],"sourcesContent":["\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  SizedMixin,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport { ActionButton } from \"@spectrum-web-components/action-button\";\nimport { RovingTabindexController } from \"@spectrum-web-components/reactive-controllers/src/RovingTabindex.js\";\nimport { MutationController } from \"@lit-labs/observers/mutation-controller.js\";\nimport styles from \"./action-group.css.js\";\nconst EMPTY_SELECTION = [];\nexport class ActionGroup extends SizedMixin(SpectrumElement, {\n  validSizes: [\"xs\", \"s\", \"m\", \"l\", \"xl\"],\n  noDefaultSize: true\n}) {\n  constructor() {\n    super();\n    this._buttons = [];\n    this._buttonSelector = \"sp-action-button, sp-action-menu\";\n    this.rovingTabindexController = new RovingTabindexController(\n      this,\n      {\n        focusInIndex: (elements) => {\n          let firstEnabledIndex = -1;\n          const firstSelectedIndex = elements.findIndex((el, index) => {\n            if (!elements[firstEnabledIndex] && !el.disabled) {\n              firstEnabledIndex = index;\n            }\n            return el.selected && !el.disabled;\n          });\n          return elements[firstSelectedIndex] ? firstSelectedIndex : firstEnabledIndex;\n        },\n        elements: () => this.buttons,\n        hostDelegatesFocus: true,\n        isFocusableElement: (el) => !el.disabled\n      }\n    );\n    this.compact = false;\n    this.emphasized = false;\n    this.justified = false;\n    this.label = \"\";\n    this.quiet = false;\n    this.vertical = false;\n    this._selected = EMPTY_SELECTION;\n    this.hasManaged = false;\n    this.manageButtons = () => {\n      if (!this.slotElement) {\n        return;\n      }\n      const assignedElements = this.slotElement.assignedElements({\n        flatten: true\n      });\n      const buttons = assignedElements.reduce((acc, el) => {\n        if (el.matches(this._buttonSelector)) {\n          acc.push(el);\n        } else {\n          const buttonDescendents = Array.from(\n            el.querySelectorAll(`:scope > ${this._buttonSelector}`)\n          );\n          acc.push(...buttonDescendents);\n        }\n        return acc;\n      }, []);\n      this.buttons = buttons;\n      if (this.selects || !this.hasManaged) {\n        const currentlySelectedButtons = [];\n        this.buttons.forEach((button) => {\n          if (button.selected) {\n            currentlySelectedButtons.push(button.value);\n          }\n        });\n        this.setSelected(this.selected.concat(currentlySelectedButtons));\n      }\n      this.manageChildren();\n      this.manageSelects();\n      this.hasManaged = true;\n    };\n    new MutationController(this, {\n      config: {\n        childList: true,\n        subtree: true\n      },\n      callback: () => {\n        this.manageButtons();\n      },\n      skipInitial: true\n    });\n  }\n  static get styles() {\n    return [styles];\n  }\n  set buttons(buttons) {\n    if (buttons === this.buttons) return;\n    this._buttons = buttons;\n    this.rovingTabindexController.clearElementCache();\n  }\n  get buttons() {\n    return this._buttons;\n  }\n  set selected(selected) {\n    this.requestUpdate(\"selected\", this._selected);\n    this._selected = selected;\n    this.updateComplete.then(() => {\n      this.applySelects();\n      this.manageChildren();\n    });\n  }\n  get selected() {\n    return this._selected;\n  }\n  dispatchChange(old) {\n    const applyDefault = this.dispatchEvent(\n      new Event(\"change\", {\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      })\n    );\n    if (!applyDefault) {\n      this.setSelected(old);\n      this.buttons.map((button) => {\n        button.selected = this.selected.includes(button.value);\n      });\n    }\n  }\n  setSelected(selected, announce) {\n    if (selected === this.selected) return;\n    const old = this.selected;\n    this.requestUpdate(\"selected\", old);\n    this._selected = selected;\n    if (!announce) return;\n    this.dispatchChange(old);\n  }\n  focus(options) {\n    this.rovingTabindexController.focus(options);\n  }\n  deselectSelectedButtons() {\n    this.buttons.forEach((button) => {\n      if (!button.selected) return;\n      button.selected = false;\n      button.tabIndex = -1;\n      button.setAttribute(\n        this.selects ? \"aria-checked\" : (\n          /* c8 ignore */\n          \"aria-pressed\"\n        ),\n        \"false\"\n      );\n    });\n  }\n  handleActionButtonChange(event) {\n    event.stopPropagation();\n    event.preventDefault();\n  }\n  handleClick(event) {\n    const target = event.target;\n    if (typeof target.value === \"undefined\") {\n      return;\n    }\n    switch (this.selects) {\n      case \"single\": {\n        this.deselectSelectedButtons();\n        target.selected = true;\n        target.tabIndex = 0;\n        target.setAttribute(\"aria-checked\", \"true\");\n        this.setSelected([target.value], true);\n        break;\n      }\n      case \"multiple\": {\n        const selected = [...this.selected];\n        target.selected = !target.selected;\n        target.setAttribute(\n          \"aria-checked\",\n          target.selected ? \"true\" : \"false\"\n        );\n        if (target.selected) {\n          selected.push(target.value);\n        } else {\n          selected.splice(this.selected.indexOf(target.value), 1);\n        }\n        this.setSelected(selected, true);\n        this.buttons.forEach((button) => {\n          button.tabIndex = -1;\n        });\n        target.tabIndex = 0;\n        break;\n      }\n      default:\n        break;\n    }\n  }\n  async applySelects() {\n    await this.manageSelects(true);\n  }\n  async manageSelects(applied) {\n    if (!this.buttons.length) {\n      return;\n    }\n    const options = this.buttons;\n    switch (this.selects) {\n      case \"single\": {\n        this.setAttribute(\"role\", \"radiogroup\");\n        const selections = [];\n        const updates = options.map(async (option) => {\n          await option.updateComplete;\n          if (option instanceof ActionButton)\n            option.setAttribute(\"role\", \"radio\");\n          option.setAttribute(\n            \"aria-checked\",\n            option.selected ? \"true\" : \"false\"\n          );\n          if (option.selected) {\n            selections.push(option);\n          }\n        });\n        if (applied) break;\n        await Promise.all(updates);\n        const selected = selections.map((button) => {\n          return button.value;\n        });\n        this.setSelected(selected || EMPTY_SELECTION);\n        break;\n      }\n      case \"multiple\": {\n        if (this.getAttribute(\"role\") === \"radiogroup\") {\n          this.removeAttribute(\"role\");\n        }\n        const selection = [];\n        const selections = [];\n        const updates = options.map(async (option) => {\n          await option.updateComplete;\n          if (option instanceof ActionButton)\n            option.setAttribute(\"role\", \"checkbox\");\n          option.setAttribute(\n            \"aria-checked\",\n            option.selected ? \"true\" : \"false\"\n          );\n          if (option.selected) {\n            selection.push(option.value);\n            selections.push(option);\n          }\n        });\n        if (applied) break;\n        await Promise.all(updates);\n        const selected = !!selection.length ? selection : EMPTY_SELECTION;\n        this.setSelected(selected);\n        break;\n      }\n      default:\n        if (this.selected.length) {\n          const selections = [];\n          const updates = options.map(async (option) => {\n            await option.updateComplete;\n            if (option instanceof ActionButton)\n              option.setAttribute(\"role\", \"button\");\n            if (option.selected) {\n              option.setAttribute(\"aria-pressed\", \"true\");\n              selections.push(option);\n            } else {\n              option.removeAttribute(\"aria-pressed\");\n            }\n          });\n          if (applied) break;\n          await Promise.all(updates);\n          this.setSelected(\n            selections.map((button) => {\n              return button.value;\n            })\n          );\n        } else {\n          this.buttons.forEach((option) => {\n            if (option instanceof ActionButton)\n              option.setAttribute(\"role\", \"button\");\n          });\n          break;\n        }\n    }\n    if (!this.hasAttribute(\"role\")) {\n      this.setAttribute(\"role\", \"toolbar\");\n    }\n  }\n  render() {\n    return html`\n            <slot role=\"presentation\" @slotchange=${this.manageButtons}></slot>\n        `;\n  }\n  firstUpdated(changes) {\n    super.firstUpdated(changes);\n    this.addEventListener(\"click\", this.handleClick);\n  }\n  updated(changes) {\n    super.updated(changes);\n    if (changes.has(\"selects\")) {\n      this.manageSelects();\n      this.manageChildren();\n      if (!!this.selects) {\n        this.shadowRoot.addEventListener(\n          \"change\",\n          this.handleActionButtonChange\n        );\n      } else {\n        this.shadowRoot.removeEventListener(\n          \"change\",\n          this.handleActionButtonChange\n        );\n      }\n    }\n    if (changes.has(\"quiet\") || changes.has(\"emphasized\") || changes.has(\"size\") || changes.has(\"staticColor\")) {\n      this.manageChildren(changes);\n    }\n    if (changes.has(\"label\") && (this.label || typeof changes.get(\"label\") !== \"undefined\")) {\n      if (this.label.length) {\n        this.setAttribute(\"aria-label\", this.label);\n      } else {\n        this.removeAttribute(\"aria-label\");\n      }\n    }\n  }\n  manageChildren(changes) {\n    this.buttons.forEach((button) => {\n      if (this.quiet || (changes == null ? void 0 : changes.get(\"quiet\"))) {\n        button.quiet = this.quiet;\n      }\n      if (this.emphasized || (changes == null ? void 0 : changes.get(\"emphasized\"))) {\n        button.emphasized = this.emphasized;\n      }\n      if (this.staticColor || (changes == null ? void 0 : changes.get(\"staticColor\"))) {\n        button.staticColor = this.staticColor;\n      }\n      if (this.selects || !this.hasManaged) {\n        button.selected = this.selected.includes(button.value);\n      }\n      if (this.size && (this.size !== \"m\" || typeof (changes == null ? void 0 : changes.get(\"size\")) !== \"undefined\")) {\n        button.size = this.size;\n      }\n    });\n  }\n}\nActionGroup.shadowRootOptions = {\n  ...SpectrumElement.shadowRootOptions,\n  delegatesFocus: true\n};\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ActionGroup.prototype, \"compact\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ActionGroup.prototype, \"emphasized\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ActionGroup.prototype, \"justified\", 2);\n__decorateClass([\n  property({ type: String })\n], ActionGroup.prototype, \"label\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ActionGroup.prototype, \"quiet\", 2);\n__decorateClass([\n  property({ type: String })\n], ActionGroup.prototype, \"selects\", 2);\n__decorateClass([\n  property({ reflect: true, attribute: \"static-color\" })\n], ActionGroup.prototype, \"staticColor\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ActionGroup.prototype, \"vertical\", 2);\n__decorateClass([\n  property({ type: Array })\n], ActionGroup.prototype, \"selected\", 1);\n__decorateClass([\n  query(\"slot\")\n], ActionGroup.prototype, \"slotElement\", 2);\n//# sourceMappingURL=ActionGroup.dev.js.map\n"],"names":[],"sourceRoot":""}