{"version":3,"file":"8857.8434c7a8.iframe.bundle.js","mappings":";;AACA;AAgQA;AACA;;;;;;AAMA;;AAEA;AACA;;;;;;AAMA;;;;AAIA;;;AAGA;AACA;;AAGA;;;;;;;AAWA;AAGA;;AAEA;AAGA;AAGA;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;AAKA;;AAEA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AAMA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;AAGA;;;;;AAKA;;AAEA;;;AAGA;;;AAGA;;;AAGA;AAGA;AACA;AACA;;AAEA;;AAOA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAIA;;;AAGA;;;;;AAKA;;;;;AAKA;;AAGA;;;ACvXA;;;;AAIA;;;;;;AAMA;;;;;AAMA;;AChEA;;;;;;;;;AAwCA;;AAIA;AAEA","sources":["webpack://@spectrum-web-components/1st-gen/./packages/combobox/src/Combobox.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/picker-button/src/PickerButton.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/popover/src/Popover.dev.js"],"sourcesContent":["\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  nothing\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query,\n  state\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport {\n  ifDefined,\n  live,\n  repeat\n} from \"@spectrum-web-components/base/src/directives.js\";\nimport \"@spectrum-web-components/icons-ui/icons/sp-icon-chevron100.js\";\nimport \"@spectrum-web-components/menu/sp-menu-item.js\";\nimport \"@spectrum-web-components/menu/sp-menu.js\";\nimport \"@spectrum-web-components/overlay/sp-overlay.js\";\nimport \"@spectrum-web-components/picker-button/sp-picker-button.js\";\nimport \"@spectrum-web-components/progress-circle/sp-progress-circle.js\";\nimport \"@spectrum-web-components/popover/sp-popover.js\";\nimport { Textfield } from \"@spectrum-web-components/textfield\";\nimport chevronStyles from \"@spectrum-web-components/icon/src/spectrum-icon-chevron.css.js\";\nimport styles from \"./combobox.css.js\";\nexport class Combobox extends Textfield {\n  constructor() {\n    super(...arguments);\n    this.autocomplete = \"none\";\n    this.availableOptions = [];\n    this.open = false;\n    this.pending = false;\n    this.pendingLabel = \"Pending\";\n    this.overlayOpen = false;\n    this.itemValue = \"\";\n    this.optionEls = [];\n    this.fieldWidth = 0;\n    this.applyFocusElementLabel = (value) => {\n      this.appliedLabel = value;\n    };\n    this._returnItems = () => {\n      return;\n    };\n  }\n  static get styles() {\n    return [...super.styles, styles, chevronStyles];\n  }\n  focus() {\n    this.focusElement.focus();\n  }\n  click() {\n    this.focus();\n    this.focusElement.click();\n  }\n  scrollToActiveDescendant() {\n    if (!this.activeDescendant) {\n      return;\n    }\n    const activeEl = this.shadowRoot.getElementById(\n      this.activeDescendant.value\n    );\n    if (activeEl) {\n      activeEl.scrollIntoView({ block: \"nearest\" });\n    }\n  }\n  handleComboboxKeydown(event) {\n    if (this.readonly || this.pending) {\n      return;\n    }\n    if (event.altKey && event.code === \"ArrowDown\") {\n      this.open = true;\n    } else if (event.code === \"ArrowDown\") {\n      event.preventDefault();\n      this.open = true;\n      this.activateNextDescendant();\n      this.scrollToActiveDescendant();\n    } else if (event.code === \"ArrowUp\") {\n      event.preventDefault();\n      this.open = true;\n      this.activatePreviousDescendant();\n      this.scrollToActiveDescendant();\n    } else if (event.code === \"Escape\") {\n      if (!this.open) {\n        this.value = \"\";\n      }\n      this.open = false;\n    } else if (event.code === \"Enter\") {\n      this.selectDescendant();\n      this.open = false;\n    } else if (event.code === \"Home\") {\n      this.focusElement.setSelectionRange(0, 0);\n      this.activeDescendant = void 0;\n    } else if (event.code === \"End\") {\n      const { length } = this.value;\n      this.focusElement.setSelectionRange(length, length);\n      this.activeDescendant = void 0;\n    } else if (event.code === \"ArrowLeft\") {\n      this.activeDescendant = void 0;\n    } else if (event.code === \"ArrowRight\") {\n      this.activeDescendant = void 0;\n    }\n  }\n  /**\n   * Convert the flattened array of assigned elements of `slot[name='option']` to\n   * an array of `ComboboxOptions` for use in rendering options in the shadow DOM.s\n   **/\n  handleSlotchange() {\n    this.setOptionsFromSlottedItems();\n    this.itemObserver.disconnect();\n    this.optionEls.map((item) => {\n      this.itemObserver.observe(item, {\n        attributes: true,\n        attributeFilter: [\"id\"],\n        childList: true\n      });\n    });\n  }\n  handleTooltipSlotchange(event) {\n    this.tooltipEl = event.target.assignedElements()[0];\n  }\n  setOptionsFromSlottedItems() {\n    const elements = this.optionSlot.assignedElements({\n      flatten: true\n    });\n    this.optionEls = elements;\n  }\n  activateNextDescendant() {\n    const activeIndex = !this.activeDescendant ? -1 : this.availableOptions.indexOf(this.activeDescendant);\n    let nextActiveIndex = activeIndex;\n    do {\n      nextActiveIndex = (this.availableOptions.length + nextActiveIndex + 1) % this.availableOptions.length;\n      if (nextActiveIndex === activeIndex) break;\n    } while (this.availableOptions[nextActiveIndex].disabled);\n    if (!this.availableOptions[nextActiveIndex].disabled) {\n      this.activeDescendant = this.availableOptions[nextActiveIndex];\n    }\n    this.optionEls.forEach(\n      (el) => {\n        var _a;\n        return el.setAttribute(\n          \"aria-selected\",\n          el.value === ((_a = this.activeDescendant) == null ? void 0 : _a.value) ? \"true\" : \"false\"\n        );\n      }\n    );\n  }\n  activatePreviousDescendant() {\n    const activeIndex = !this.activeDescendant ? 0 : this.availableOptions.indexOf(this.activeDescendant);\n    let previousActiveIndex = activeIndex;\n    do {\n      previousActiveIndex = (this.availableOptions.length + previousActiveIndex - 1) % this.availableOptions.length;\n      if (previousActiveIndex === activeIndex) break;\n    } while (this.availableOptions[previousActiveIndex].disabled);\n    if (!this.availableOptions[previousActiveIndex].disabled) {\n      this.activeDescendant = this.availableOptions[previousActiveIndex];\n    }\n    this.optionEls.forEach(\n      (el) => {\n        var _a;\n        return el.setAttribute(\n          \"aria-selected\",\n          el.value === ((_a = this.activeDescendant) == null ? void 0 : _a.value) ? \"true\" : \"false\"\n        );\n      }\n    );\n  }\n  selectDescendant() {\n    if (!this.activeDescendant) {\n      return;\n    }\n    const activeEl = this.shadowRoot.getElementById(\n      this.activeDescendant.value\n    );\n    if (activeEl) {\n      activeEl.click();\n    }\n  }\n  filterAvailableOptions() {\n    if (this.autocomplete === \"none\" || this.pending) {\n      return;\n    }\n    const valueLowerCase = this.value.toLowerCase();\n    this.availableOptions = (this.options || this.optionEls).filter(\n      (descendant) => {\n        const itemTextLowerCase = descendant.itemText.toLowerCase();\n        return itemTextLowerCase.startsWith(valueLowerCase);\n      }\n    );\n  }\n  handleInput(event) {\n    super.handleInput(event);\n    if (!this.pending) {\n      this.activeDescendant = void 0;\n      this.open = true;\n    }\n  }\n  handleMenuChange(event) {\n    const { target } = event;\n    const selected = (this.options || this.optionEls).find(\n      (item) => item.value === (target == null ? void 0 : target.value)\n    );\n    this.value = (selected == null ? void 0 : selected.itemText) || \"\";\n    event.preventDefault();\n    this.open = false;\n    this._returnItems();\n    this.focus();\n  }\n  handleClosed() {\n    this.open = false;\n    this.overlayOpen = false;\n  }\n  handleOpened() {\n  }\n  toggleOpen() {\n    if (this.readonly || this.pending) {\n      this.open = false;\n      return;\n    }\n    this.open = !this.open;\n    this.inputElement.focus();\n  }\n  shouldUpdate(changed) {\n    var _a, _b;\n    if (changed.has(\"open\")) {\n      if (!this.open) {\n        this.activeDescendant = void 0;\n      } else {\n        this.overlayOpen = true;\n      }\n    }\n    if (changed.has(\"value\")) {\n      this.filterAvailableOptions();\n      this.itemValue = (_b = (_a = this.availableOptions.find(\n        (option) => option.itemText === this.value\n      )) == null ? void 0 : _a.value) != null ? _b : \"\";\n    }\n    return super.shouldUpdate(changed);\n  }\n  onBlur(event) {\n    if (event.relatedTarget && (this.contains(event.relatedTarget) || this.shadowRoot.contains(event.relatedTarget))) {\n      return;\n    }\n    super.onBlur(event);\n  }\n  renderVisuallyHiddenLabels() {\n    const appliedLabel = this.label || this.appliedLabel;\n    return html`\n            ${this.pending ? html`\n                      ${this.renderLoader()}\n                      <span\n                          aria-hidden=\"true\"\n                          class=\"visually-hidden\"\n                          id=\"pending-label\"\n                      >\n                          ${this.pendingLabel}\n                      </span>\n                  ` : nothing}\n            ${this.value ? html`\n                      <span\n                          aria-hidden=\"true\"\n                          class=\"visually-hidden\"\n                          id=\"applied-label\"\n                      >\n                          ${appliedLabel}\n                      </span>\n                      <slot name=\"label\" id=\"label\">\n                          <span class=\"visually-hidden\" aria-hidden=\"true\">\n                              ${this.value}\n                          </span>\n                      </slot>\n                  ` : html`\n                      <span hidden id=\"applied-label\">${appliedLabel}</span>\n                  `}\n        `;\n  }\n  renderLoader() {\n    import(\"@spectrum-web-components/progress-circle/sp-progress-circle.js\");\n    return html`\n            <sp-progress-circle\n                size=\"s\"\n                indeterminate\n                role=\"presentation\"\n                class=\"progress-circle\"\n            ></sp-progress-circle>\n        `;\n  }\n  renderField() {\n    return html`\n            ${this.renderStateIcons()}\n            <input\n                aria-activedescendant=${ifDefined(\n      this.activeDescendant ? `${this.activeDescendant.value}` : void 0\n    )}\n                aria-autocomplete=${ifDefined(\n      this.autocomplete\n    )}\n                aria-controls=${ifDefined(\n      this.open ? \"listbox-menu\" : void 0\n    )}\n                aria-describedby=\"${this.helpTextId} tooltip\"\n                aria-expanded=\"${this.open ? \"true\" : \"false\"}\"\n                aria-label=${ifDefined(this.label || this.appliedLabel)}\n                aria-labelledby=\"label applied-label pending-label\"\n                aria-invalid=${ifDefined(this.invalid || void 0)}\n                autocomplete=\"off\"\n                @click=${this.toggleOpen}\n                @keydown=${this.handleComboboxKeydown}\n                id=\"input\"\n                class=\"input\"\n                role=\"combobox\"\n                type=\"text\"\n                .value=${live(this.displayValue)}\n                tabindex=\"0\"\n                @sp-closed=${this.handleClosed}\n                @sp-opened=${this.handleOpened}\n                maxlength=${ifDefined(\n      this.maxlength > -1 ? this.maxlength : void 0\n    )}\n                minlength=${ifDefined(\n      this.minlength > -1 ? this.minlength : void 0\n    )}\n                pattern=${ifDefined(this.pattern)}\n                @change=${this.handleChange}\n                @input=${this.handleInput}\n                @focus=${this.onFocus}\n                @blur=${this.onBlur}\n                ?disabled=${this.disabled}\n                ?required=${this.required}\n                ?readonly=${this.readonly}\n            />\n        `;\n  }\n  render() {\n    if (this.tooltipEl) {\n      this.tooltipEl.disabled = this.open;\n    }\n    return html`\n            ${super.render()}\n            <sp-picker-button\n                aria-controls=\"listbox-menu\"\n                aria-describedby=\"${this.helpTextId} tooltip\"\n                aria-expanded=${this.open ? \"true\" : \"false\"}\n                aria-label=${ifDefined(this.label || this.appliedLabel)}\n                aria-labelledby=\"applied-label label\"\n                @click=${this.toggleOpen}\n                tabindex=\"-1\"\n                class=\"button ${this.focused ? \"focus-visible is-keyboardFocused\" : \"\"}\"\n                ?disabled=${this.disabled}\n                ?focused=${this.focused}\n                ?quiet=${this.quiet}\n                size=${this.size}\n            ></sp-picker-button>\n            <sp-overlay\n                ?open=${this.open}\n                .triggerElement=${this.input}\n                offset=\"0\"\n                placement=\"bottom-start\"\n                .receivesFocus=${\"false\"}\n                role=\"presentation\"\n            >\n                <sp-popover\n                    id=\"listbox\"\n                    ?open=${this.open}\n                    role=\"presentation\"\n                    ?hidden=${this.availableOptions.length === 0}\n                >\n                    <sp-menu\n                        @change=${this.handleMenuChange}\n                        tabindex=\"-1\"\n                        aria-labelledby=\"label applied-label\"\n                        aria-label=${ifDefined(this.label || this.appliedLabel)}\n                        id=\"listbox-menu\"\n                        role=\"listbox\"\n                        selects=${ifDefined(\n      this.autocomplete === \"none\" ? \"single\" : void 0\n    )}\n                        .selected=${this.autocomplete === \"none\" && this.itemValue ? [this.itemValue] : []}\n                        style=\"min-width: ${this.fieldWidth}px;\"\n                        size=${this.size}\n                    >\n                        ${this.overlayOpen ? repeat(\n      this.availableOptions,\n      (option) => option.value,\n      (option) => {\n        var _a, _b;\n        return html`\n                                          <sp-menu-item\n                                              id=\"${option.value}\"\n                                              ?focused=${((_a = this.activeDescendant) == null ? void 0 : _a.value) === option.value}\n                                              aria-selected=${((_b = this.activeDescendant) == null ? void 0 : _b.value) === option.value ? \"true\" : \"false\"}\n                                              .value=${option.value}\n                                              .selected=${option.value === this.itemValue}\n                                              ?disabled=${option.disabled}\n                                          >\n                                              ${option.itemText}\n                                          </sp-menu-item>\n                                      `;\n      }\n    ) : html``}\n                        <slot\n                            hidden\n                            @slotchange=${this.handleSlotchange}\n                        ></slot>\n                    </sp-menu>\n                </sp-popover>\n            </sp-overlay>\n            ${this.renderVisuallyHiddenLabels()}\n            <slot\n                aria-hidden=\"true\"\n                name=\"tooltip\"\n                id=\"tooltip\"\n                @slotchange=${this.handleTooltipSlotchange}\n            ></slot>\n        `;\n  }\n  firstUpdated(changed) {\n    super.firstUpdated(changed);\n    this.addEventListener(\"focusout\", (event) => {\n      const isMenuItem = event.relatedTarget && this.contains(event.relatedTarget);\n      if (event.target === this && !isMenuItem) {\n        this.focused = false;\n      }\n    });\n    this.resizeObserver = new ResizeObserver((entries) => {\n      this.fieldWidth = entries[0].borderBoxSize[0].inlineSize;\n    });\n    this.resizeObserver.observe(this);\n  }\n  async manageListOverlay() {\n    if (this.open) {\n      this.focused = true;\n      this.focus();\n    }\n  }\n  updated(changed) {\n    var _a;\n    if (changed.has(\"open\") && !this.pending) {\n      this.manageListOverlay();\n    }\n    if (!this.focused && this.open) {\n      this.open = false;\n    }\n    if (changed.has(\"pending\") && this.pending) {\n      this.open = false;\n    }\n    if (this.activeDescendant !== this._previousActiveDescendant) {\n      if (this._previousActiveDescendant && typeof this._previousActiveDescendant.focused !== \"undefined\") {\n        this._previousActiveDescendant.focused = false;\n      }\n      if (this.activeDescendant && typeof this.activeDescendant.focused !== \"undefined\") {\n        this.activeDescendant.focused = true;\n      }\n      this._previousActiveDescendant = this.activeDescendant;\n    }\n    const optionsChanged = changed.has(\"options\");\n    const optionElsChanged = this.optionEls !== this._previousOptionEls;\n    if (optionsChanged || optionElsChanged) {\n      if ((_a = this.options) == null ? void 0 : _a.every((option) => option.disabled)) {\n        this.disabled = true;\n      }\n      this.availableOptions = this.options || this.optionEls;\n      if (optionElsChanged) {\n        this._previousOptionEls = this.optionEls;\n      }\n    }\n  }\n  async getUpdateComplete() {\n    const complete = await super.getUpdateComplete();\n    const list = this.shadowRoot.querySelector(\n      \"#listbox\"\n    );\n    if (list) {\n      const descendants = [...list.children];\n      await Promise.all(\n        descendants.map((descendant) => descendant.updateComplete)\n      );\n    }\n    return complete;\n  }\n  connectedCallback() {\n    super.connectedCallback();\n    if (!this.itemObserver) {\n      this.itemObserver = new MutationObserver(\n        this.setOptionsFromSlottedItems.bind(this)\n      );\n    }\n  }\n  disconnectedCallback() {\n    var _a;\n    this.itemObserver.disconnect();\n    this.open = false;\n    (_a = this.resizeObserver) == null ? void 0 : _a.disconnect();\n    this.resizeObserver = void 0;\n    super.disconnectedCallback();\n  }\n}\n__decorateClass([\n  state()\n], Combobox.prototype, \"activeDescendant\", 2);\n__decorateClass([\n  property({ type: String })\n], Combobox.prototype, \"autocomplete\", 2);\n__decorateClass([\n  state()\n], Combobox.prototype, \"availableOptions\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Combobox.prototype, \"open\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Combobox.prototype, \"pending\", 2);\n__decorateClass([\n  property({ type: String, attribute: \"pending-label\" })\n], Combobox.prototype, \"pendingLabel\", 2);\n__decorateClass([\n  query(\"slot:not([name])\")\n], Combobox.prototype, \"optionSlot\", 2);\n__decorateClass([\n  state()\n], Combobox.prototype, \"overlayOpen\", 2);\n__decorateClass([\n  query(\"#input\")\n], Combobox.prototype, \"input\", 2);\n__decorateClass([\n  property({ type: Array })\n], Combobox.prototype, \"options\", 2);\n__decorateClass([\n  state()\n], Combobox.prototype, \"optionEls\", 2);\n__decorateClass([\n  state()\n], Combobox.prototype, \"fieldWidth\", 2);\n//# sourceMappingURL=Combobox.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  SizedMixin\n} from \"@spectrum-web-components/base\";\nimport { classMap } from \"@spectrum-web-components/base/src/directives.js\";\nimport { property } from \"@spectrum-web-components/base/src/decorators.js\";\nimport { ButtonBase } from \"@spectrum-web-components/button/src/ButtonBase.js\";\nimport \"@spectrum-web-components/icons-ui/icons/sp-icon-chevron100.js\";\nimport { ObserveSlotPresence } from \"@spectrum-web-components/shared/src/observe-slot-presence.js\";\nimport styles from \"./picker-button.css.js\";\nimport chevronStyles from \"@spectrum-web-components/icon/src/spectrum-icon-chevron.css.js\";\nconst chevronClass = {\n  s: \"spectrum-UIIcon-ChevronDown75\",\n  m: \"spectrum-UIIcon-ChevronDown100\",\n  l: \"spectrum-UIIcon-ChevronDown200\",\n  xl: \"spectrum-UIIcon-ChevronDown300\"\n};\nexport class PickerButton extends SizedMixin(\n  ObserveSlotPresence(ButtonBase, '[slot=\"label\"]')\n) {\n  constructor() {\n    super(...arguments);\n    this.invalid = false;\n    this.position = \"right\";\n  }\n  static get styles() {\n    return [styles, chevronStyles];\n  }\n  get hasText() {\n    return this.slotContentIsPresent;\n  }\n  render() {\n    const rootClasses = {\n      root: true,\n      uiicononly: !this.hasText,\n      textuiicon: this.hasText\n    };\n    return html`\n            <div class=${classMap(rootClasses)}>\n                <div class=\"spectrum-PickerButton-fill\">\n                    <span\n                        class=\"spectrum-PickerButton-label is-placeholder\"\n                        ?hidden=${!this.hasText}\n                    >\n                        <slot name=\"label\"></slot>\n                    </span>\n                    <slot name=\"icon\">\n                        <sp-icon-chevron100\n                            class=\"spectrum-PickerButton-icon spectrum-Icon ${chevronClass[this.size]}\"\n                        ></sp-icon-chevron100>\n                    </slot>\n                </div>\n            </div>\n        `;\n  }\n}\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], PickerButton.prototype, \"invalid\", 2);\n__decorateClass([\n  property({ reflect: true })\n], PickerButton.prototype, \"position\", 2);\n//# sourceMappingURL=PickerButton.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  nothing,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport popoverStyles from \"./popover.css.js\";\nexport class Popover extends SpectrumElement {\n  constructor() {\n    super(...arguments);\n    this.open = false;\n    this.tip = false;\n  }\n  static get styles() {\n    return [popoverStyles];\n  }\n  renderTip() {\n    return html`\n            <div id=\"tip\" aria-hidden=\"true\">\n                <svg class=\"tip block\" viewBox=\"0 -0.5 16 9\">\n                    <path class=\"triangle\" d=\"M-1,-1 8,8 17,-1\"></path>\n                </svg>\n                <svg class=\"tip inline\" viewBox=\"0 -0.5 9 16\">\n                    <path class=\"triangle\" d=\"M-1,-1 8,8 -1,17\"></path>\n                </svg>\n            </div>\n        `;\n  }\n  render() {\n    return html`\n            <slot></slot>\n            ${this.tip ? this.renderTip() : nothing}\n        `;\n  }\n}\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Popover.prototype, \"open\", 2);\n__decorateClass([\n  property({ reflect: true })\n], Popover.prototype, \"placement\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Popover.prototype, \"tip\", 2);\n__decorateClass([\n  query(\"#tip\")\n], Popover.prototype, \"tipElement\", 2);\n//# sourceMappingURL=Popover.dev.js.map\n"],"names":[],"sourceRoot":""}