{"version":3,"file":"7468.33aeeff1.iframe.bundle.js","mappings":";;AACA;AA4pBA;AAEA;;;;AA6BA;AAGA;AAGA;AAGA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;AAYA;;AAGA","sources":["webpack://@adobe/spectrum-web-components/./packages/overlay/src/Overlay.dev.js"],"sourcesContent":["\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query,\n  queryAssignedElements,\n  state\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport {\n  ElementResolutionController,\n  elementResolverUpdatedSymbol\n} from \"@spectrum-web-components/reactive-controllers/src/ElementResolution.js\";\nimport {\n  ifDefined,\n  styleMap\n} from \"@spectrum-web-components/base/src/directives.js\";\nimport { randomID } from \"@spectrum-web-components/shared/src/random-id.js\";\nimport { AbstractOverlay, nextFrame } from \"./AbstractOverlay.dev.js\";\nimport { OverlayPopover } from \"./OverlayPopover.dev.js\";\nimport { OverlayNoPopover } from \"./OverlayNoPopover.dev.js\";\nimport { overlayStack } from \"./OverlayStack.dev.js\";\nimport { VirtualTrigger } from \"./VirtualTrigger.dev.js\";\nimport { PlacementController } from \"./PlacementController.dev.js\";\nexport { LONGPRESS_INSTRUCTIONS } from \"./LongpressController.dev.js\";\nimport { strategies } from \"./strategies.dev.js\";\nimport {\n  removeSlottableRequest,\n  SlottableRequestEvent\n} from \"./slottable-request-event.dev.js\";\nimport styles from \"./overlay.css.js\";\nconst browserSupportsPopover = \"showPopover\" in document.createElement(\"div\");\nlet ComputedOverlayBase = OverlayPopover(AbstractOverlay);\nif (!browserSupportsPopover) {\n  ComputedOverlayBase = OverlayNoPopover(AbstractOverlay);\n}\nconst _Overlay = class _Overlay extends ComputedOverlayBase {\n  constructor() {\n    super(...arguments);\n    this._delayed = false;\n    this._disabled = false;\n    this.offset = 0;\n    this._open = false;\n    /**\n     * The state in which the last `request-slottable` event was dispatched.\n     *\n     * This property ensures that overlays do not dispatch the same state twice in a row.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.lastRequestSlottableState = false;\n    this.receivesFocus = \"auto\";\n    this.allowOutsideClick = false;\n    this._state = \"closed\";\n    this.triggerElement = null;\n    this.type = \"auto\";\n    /**\n     * Tracks whether the overlay was previously open.\n     * This is used to restore the open state when re-enabling the overlay.\n     *\n     * @type {boolean}\n     * @default false\n     */\n    this.wasOpen = false;\n    /**\n     * Focus trap to keep focus within the dialog\n     * @private\n     */\n    this._focusTrap = null;\n    /**\n     * Handles the focus out event to close the overlay if the focus moves outside of it.\n     *\n     * This method ensures that the overlay is closed when the focus moves to an element\n     * outside of the overlay, unless the focus is moved to a related element.\n     *\n     * @private\n     * @param {FocusEvent} event - The focus out event.\n     */\n    this.closeOnFocusOut = (event) => {\n      if (!event.relatedTarget) {\n        return;\n      }\n      const relationEvent = new Event(\"overlay-relation-query\", {\n        bubbles: true,\n        composed: true\n      });\n      event.relatedTarget.addEventListener(\n        relationEvent.type,\n        (event2) => {\n          const path = event2.composedPath();\n          const isWithinOverlay = path.some((el) => el === this);\n          if (!isWithinOverlay) {\n            this.open = false;\n          }\n        }\n      );\n      event.relatedTarget.dispatchEvent(relationEvent);\n    };\n    this.closeOnCancelEvent = () => {\n      this.open = false;\n    };\n  }\n  get delayed() {\n    var _a;\n    return ((_a = this.elements.at(-1)) == null ? void 0 : _a.hasAttribute(\"delayed\")) || this._delayed;\n  }\n  set delayed(delayed) {\n    this._delayed = delayed;\n  }\n  get disabled() {\n    return this._disabled;\n  }\n  set disabled(disabled) {\n    var _a;\n    this._disabled = disabled;\n    if (disabled) {\n      (_a = this.strategy) == null ? void 0 : _a.abort();\n      this.wasOpen = this.open;\n      this.open = false;\n    } else {\n      this.bindEvents();\n      this.open = this.open || this.wasOpen;\n      this.wasOpen = false;\n    }\n  }\n  /**\n   * Determines if the overlay has a non-virtual trigger element.\n   *\n   * @returns {boolean} `true` if the trigger element is not a virtual trigger, otherwise `false`.\n   */\n  get hasNonVirtualTrigger() {\n    return !!this.triggerElement && !(this.triggerElement instanceof VirtualTrigger);\n  }\n  /**\n   * Provides an instance of the `PlacementController` for managing the positioning\n   * of the overlay relative to its trigger element.\n   *\n   * If the `PlacementController` instance does not already exist, it is created and\n   * assigned to the `_placementController` property.\n   *\n   * @protected\n   * @returns {PlacementController} The `PlacementController` instance.\n   */\n  get placementController() {\n    if (!this._placementController) {\n      this._placementController = new PlacementController(this);\n    }\n    return this._placementController;\n  }\n  get open() {\n    return this._open;\n  }\n  set open(open) {\n    var _a;\n    if (open && this.disabled) return;\n    if (open === this.open) return;\n    if (((_a = this.strategy) == null ? void 0 : _a.activelyOpening) && !open) return;\n    this._open = open;\n    if (this.open) {\n      _Overlay.openCount += 1;\n    }\n    this.requestUpdate(\"open\", !this.open);\n    if (this.open) {\n      this.requestSlottable();\n    }\n  }\n  get state() {\n    return this._state;\n  }\n  set state(state2) {\n    var _a;\n    if (state2 === this.state) return;\n    const oldState = this.state;\n    this._state = state2;\n    if (this.state === \"opened\" || this.state === \"closed\") {\n      (_a = this.strategy) == null ? void 0 : _a.shouldCompleteOpen();\n    }\n    this.requestUpdate(\"state\", oldState);\n  }\n  /**\n   * Provides an instance of the `ElementResolutionController` for managing the element\n   * that the overlay should be associated with. If the instance does not already exist,\n   * it is created and assigned to the `_elementResolver` property.\n   *\n   * @protected\n   * @returns {ElementResolutionController} The `ElementResolutionController` instance.\n   */\n  get elementResolver() {\n    if (!this._elementResolver) {\n      this._elementResolver = new ElementResolutionController(this);\n    }\n    return this._elementResolver;\n  }\n  /**\n   * Determines the value for the popover attribute based on the overlay type.\n   *\n   * @private\n   * @returns {'auto' | 'manual' | undefined} The popover value or undefined if not applicable.\n   */\n  get popoverValue() {\n    const hasPopoverAttribute = \"popover\" in this;\n    if (!hasPopoverAttribute) {\n      return void 0;\n    }\n    switch (this.type) {\n      case \"modal\":\n        return \"auto\";\n      case \"page\":\n        return \"manual\";\n      case \"hint\":\n        return \"manual\";\n      default:\n        return this.type;\n    }\n  }\n  /**\n   * Determines if the overlay requires positioning based on its type and state.\n   *\n   * @protected\n   * @returns {boolean} True if the overlay requires positioning, otherwise false.\n   */\n  get requiresPositioning() {\n    if (this.type === \"page\" || !this.open) return false;\n    if (!this.triggerElement || !this.placement && this.type !== \"hint\")\n      return false;\n    return true;\n  }\n  /**\n   * Manages the positioning of the overlay relative to its trigger element.\n   *\n   * This method calculates the necessary parameters for positioning the overlay,\n   * such as offset, placement, and tip padding, and then delegates the actual\n   * positioning to the `PlacementController`.\n   *\n   * @protected\n   * @override\n   */\n  managePosition() {\n    if (!this.requiresPositioning || !this.open) return;\n    const offset = this.offset || 0;\n    const trigger = this.triggerElement;\n    const placement = this.placement || \"right\";\n    const tipPadding = this.tipPadding;\n    this.placementController.placeOverlay(this.dialogEl, {\n      offset,\n      placement,\n      tipPadding,\n      trigger,\n      type: this.type\n    });\n  }\n  /**\n   * Manages the process of opening the popover.\n   *\n   * This method handles the necessary steps to open the popover, including managing delays,\n   * ensuring the popover is in the DOM, making transitions, and applying focus.\n   * @protected\n   * @override\n   * @returns {Promise<void>} A promise that resolves when the popover has been fully opened.\n   */\n  async managePopoverOpen() {\n    super.managePopoverOpen();\n    const targetOpenState = this.open;\n    if (this.open !== targetOpenState) {\n      return;\n    }\n    await this.manageDelay(targetOpenState);\n    if (this.open !== targetOpenState) {\n      return;\n    }\n    if (this.triggerInteraction === \"longpress\") {\n      await nextFrame();\n    }\n    await this.ensureOnDOM(targetOpenState);\n    if (this.open !== targetOpenState) {\n      return;\n    }\n    const focusEl = await this.makeTransition(targetOpenState);\n    if (this.open !== targetOpenState) {\n      return;\n    }\n    if (targetOpenState) {\n      const focusTrap = await import(\"focus-trap\");\n      this._focusTrap = focusTrap.createFocusTrap(this.dialogEl, {\n        initialFocus: focusEl || void 0,\n        tabbableOptions: {\n          getShadowRoot: true\n        },\n        fallbackFocus: () => {\n          this.dialogEl.setAttribute(\"tabIndex\", \"-1\");\n          return this.dialogEl;\n        },\n        // disable escape key capture to close the overlay, the focus-trap library captures it otherwise\n        escapeDeactivates: false,\n        allowOutsideClick: this.allowOutsideClick\n      });\n      if (this.type === \"modal\" || this.type === \"page\") {\n        this._focusTrap.activate();\n      }\n    }\n    await this.applyFocus(targetOpenState, focusEl);\n  }\n  /**\n   * Applies focus to the appropriate element after the popover has been opened.\n   *\n   * This method handles the focus management for the overlay, ensuring that the correct\n   * element receives focus based on the overlay's type and state.\n   *\n   * @protected\n   * @override\n   * @param {boolean} targetOpenState - The target open state of the overlay.\n   * @param {HTMLElement | null} focusEl - The element to focus after opening the popover.\n   * @returns {Promise<void>} A promise that resolves when the focus has been applied.\n   */\n  async applyFocus(targetOpenState, focusEl) {\n    if (this.receivesFocus === \"false\" || this.type === \"hint\") {\n      return;\n    }\n    await nextFrame();\n    await nextFrame();\n    if (targetOpenState === this.open && !this.open) {\n      if (this.hasNonVirtualTrigger && this.contains(this.getRootNode().activeElement)) {\n        this.triggerElement.focus();\n      }\n      return;\n    }\n    focusEl == null ? void 0 : focusEl.focus();\n  }\n  /**\n   * Returns focus to the trigger element if the overlay is closed.\n   *\n   * This method ensures that focus is returned to the trigger element when the overlay is closed,\n   * unless the overlay is of type \"hint\" or the focus is already outside the overlay.\n   *\n   * @protected\n   * @override\n   */\n  returnFocus() {\n    var _a;\n    if (this.open || this.type === \"hint\") return;\n    const getAncestors = () => {\n      var _a2, _b;\n      const ancestors = [];\n      let currentNode = document.activeElement;\n      while ((_a2 = currentNode == null ? void 0 : currentNode.shadowRoot) == null ? void 0 : _a2.activeElement) {\n        currentNode = currentNode.shadowRoot.activeElement;\n      }\n      while (currentNode) {\n        const ancestor = currentNode.assignedSlot || currentNode.parentElement || ((_b = currentNode.getRootNode()) == null ? void 0 : _b.host);\n        if (ancestor) {\n          ancestors.push(ancestor);\n        }\n        currentNode = ancestor;\n      }\n      return ancestors;\n    };\n    if (this.receivesFocus !== \"false\" && !!((_a = this.triggerElement) == null ? void 0 : _a.focus) && (this.contains(this.getRootNode().activeElement) || getAncestors().includes(this) || // eslint-disable-next-line @spectrum-web-components/document-active-element\n    document.activeElement === document.body)) {\n      this.triggerElement.focus();\n    }\n  }\n  /**\n   * Manages the process of opening or closing the overlay.\n   *\n   * This method handles the necessary steps to open or close the overlay, including updating the state,\n   * managing the overlay stack, and handling focus events.\n   *\n   * @protected\n   * @param {boolean} oldOpen - The previous open state of the overlay.\n   * @returns {Promise<void>} A promise that resolves when the overlay has been fully managed.\n   */\n  async manageOpen(oldOpen) {\n    var _a;\n    if (!this.isConnected && this.open) return;\n    if (!this.hasUpdated) {\n      await this.updateComplete;\n    }\n    if (this.open) {\n      overlayStack.add(this);\n      if (this.willPreventClose) {\n        document.addEventListener(\n          \"pointerup\",\n          () => {\n            this.dialogEl.classList.toggle(\n              \"not-immediately-closable\",\n              false\n            );\n            this.willPreventClose = false;\n          },\n          { once: true }\n        );\n        this.dialogEl.classList.toggle(\n          \"not-immediately-closable\",\n          true\n        );\n      }\n    } else {\n      if (oldOpen) {\n        (_a = this._focusTrap) == null ? void 0 : _a.deactivate();\n        this._focusTrap = null;\n        this.dispose();\n      }\n      overlayStack.remove(this);\n    }\n    if (this.open && this.state !== \"opened\") {\n      this.state = \"opening\";\n    } else if (!this.open && this.state !== \"closed\") {\n      this.state = \"closing\";\n    }\n    this.managePopoverOpen();\n    const listenerRoot = this.getRootNode();\n    if (this.type === \"auto\") {\n      if (this.open) {\n        listenerRoot.addEventListener(\n          \"focusout\",\n          this.closeOnFocusOut,\n          { capture: true }\n        );\n      } else {\n        listenerRoot.removeEventListener(\n          \"focusout\",\n          this.closeOnFocusOut,\n          { capture: true }\n        );\n      }\n    }\n    if (this.type === \"modal\" || this.type === \"page\") {\n      if (this.open) {\n        listenerRoot.addEventListener(\n          \"cancel\",\n          this.closeOnCancelEvent,\n          {\n            capture: true\n          }\n        );\n      } else {\n        listenerRoot.removeEventListener(\n          \"cancel\",\n          this.closeOnCancelEvent,\n          {\n            capture: true\n          }\n        );\n      }\n    }\n  }\n  /**\n   * Binds event handling strategies to the overlay based on the specified trigger interaction.\n   *\n   * This method sets up the appropriate event handling strategy for the overlay, ensuring that\n   * it responds correctly to user interactions such as clicks, hovers, or long presses.\n   *\n   * @protected\n   */\n  bindEvents() {\n    var _a;\n    (_a = this.strategy) == null ? void 0 : _a.abort();\n    this.strategy = void 0;\n    if (!this.hasNonVirtualTrigger) return;\n    if (!this.triggerInteraction) return;\n    this.strategy = new strategies[this.triggerInteraction](\n      this.triggerElement,\n      {\n        overlay: this\n      }\n    );\n  }\n  /**\n   * Handles the `beforetoggle` event to manage the overlay's state.\n   *\n   * This method checks the new state of the event and calls `handleBrowserClose`\n   * if the new state is not 'open'.\n   *\n   * @protected\n   * @param {Event & { newState: string }} event - The `beforetoggle` event with the new state.\n   */\n  handleBeforetoggle(event) {\n    if (event.newState !== \"open\") {\n      this.handleBrowserClose(event);\n    }\n  }\n  /**\n   * Handles the browser's close event to manage the overlay's state.\n   *\n   * This method stops the propagation of the event and closes the overlay if it is not\n   * actively opening. If the overlay is actively opening, it calls `manuallyKeepOpen`.\n   *\n   * @protected\n   * @param {Event} event - The browser's close event.\n   */\n  handleBrowserClose(event) {\n    var _a;\n    event.stopPropagation();\n    if (!((_a = this.strategy) == null ? void 0 : _a.activelyOpening)) {\n      this.open = false;\n      return;\n    }\n    this.manuallyKeepOpen();\n  }\n  /**\n   * Manually keeps the overlay open.\n   *\n   * This method sets the overlay to open, allows placement updates, and manages the open state.\n   *\n   * @public\n   * @override\n   */\n  manuallyKeepOpen() {\n    this.open = true;\n    this.placementController.allowPlacementUpdate = true;\n    this.manageOpen(false);\n  }\n  /**\n   * Handles the `slotchange` event to manage the overlay's state.\n   *\n   * This method checks if there are any elements in the slot. If there are no elements,\n   * it releases the description from the strategy. If there are elements and the trigger\n   * is non-virtual, it prepares the description for the trigger element.\n   *\n   * @protected\n   */\n  handleSlotchange() {\n    var _a, _b;\n    if (!this.elements.length) {\n      (_a = this.strategy) == null ? void 0 : _a.releaseDescription();\n    } else if (this.hasNonVirtualTrigger) {\n      (_b = this.strategy) == null ? void 0 : _b.prepareDescription(\n        this.triggerElement\n      );\n    }\n  }\n  /**\n   * Determines whether the overlay should prevent closing.\n   *\n   * This method checks the `willPreventClose` flag and resets it to `false`.\n   * It returns the value of the `willPreventClose` flag.\n   *\n   * @public\n   * @returns {boolean} `true` if the overlay should prevent closing, otherwise `false`.\n   */\n  shouldPreventClose() {\n    const shouldPreventClose = this.willPreventClose;\n    this.willPreventClose = false;\n    return shouldPreventClose;\n  }\n  /**\n   * Requests slottable content for the overlay.\n   *\n   * This method dispatches a `SlottableRequestEvent` to request or remove slottable content\n   * based on the current open state of the overlay. It ensures that the same state is not\n   * dispatched twice in a row.\n   *\n   * @protected\n   * @override\n   */\n  requestSlottable() {\n    if (this.lastRequestSlottableState === this.open) {\n      return;\n    }\n    if (!this.open) {\n      document.body.offsetHeight;\n    }\n    this.dispatchEvent(\n      new SlottableRequestEvent(\n        \"overlay-content\",\n        this.open ? {} : removeSlottableRequest\n      )\n    );\n    this.lastRequestSlottableState = this.open;\n  }\n  /**\n   * Lifecycle method called before the component updates.\n   *\n   * This method handles various tasks before the component updates, such as setting an ID,\n   * managing the open state, resolving the trigger element, and binding events.\n   *\n   * @override\n   * @param {PropertyValues} changes - The properties that have changed.\n   */\n  willUpdate(changes) {\n    var _a;\n    if (!this.hasAttribute(\"id\")) {\n      this.setAttribute(\n        \"id\",\n        `${this.tagName.toLowerCase()}-${randomID()}`\n      );\n    }\n    if (changes.has(\"allowOutsideClick\") && this.allowOutsideClick) {\n      if (true) {\n        window.__swc.warn(\n          this,\n          `The \"allow-outside-click\" attribute on <${this.localName}> has been deprecated and will be removed in a future release. We do not recommend using this attribute for accessibility reasons. It allows clicks outside the overlay to close it, which can cause unexpected behavior and accessibility issues.`,\n          \"https://opensource.adobe.com/spectrum-web-components/components/overlay/\",\n          { level: \"deprecation\" }\n        );\n      } else {\n        console.warn(\n          `[${this.localName}] The \"allow-outside-click\" attribute has been deprecated and will be removed in a future release. We do not recommend using this attribute for accessibility reasons. It allows clicks outside the overlay to close it, which can cause unexpected behavior and accessibility issues.`\n        );\n      }\n    }\n    if (changes.has(\"open\") && (this.hasUpdated || this.open)) {\n      this.manageOpen(changes.get(\"open\"));\n    }\n    if (changes.has(\"trigger\")) {\n      const [id, interaction] = ((_a = this.trigger) == null ? void 0 : _a.split(\"@\")) || [];\n      this.elementResolver.selector = id ? `#${id}` : \"\";\n      this.triggerInteraction = interaction;\n    }\n    let oldTrigger = false;\n    if (changes.has(elementResolverUpdatedSymbol)) {\n      oldTrigger = this.triggerElement;\n      this.triggerElement = this.elementResolver.element;\n    }\n    if (changes.has(\"triggerElement\")) {\n      oldTrigger = changes.get(\"triggerElement\");\n    }\n    if (oldTrigger !== false) {\n      this.bindEvents();\n    }\n  }\n  /**\n   * Lifecycle method called after the component updates.\n   *\n   * This method handles various tasks after the component updates, such as updating the placement\n   * attribute, resetting the overlay position, and clearing the overlay position based on the state.\n   *\n   * @override\n   * @param {PropertyValues} changes - The properties that have changed.\n   */\n  updated(changes) {\n    super.updated(changes);\n    if (changes.has(\"placement\")) {\n      if (this.placement) {\n        this.dialogEl.setAttribute(\"actual-placement\", this.placement);\n      } else {\n        this.dialogEl.removeAttribute(\"actual-placement\");\n      }\n      if (this.open && typeof changes.get(\"placement\") !== \"undefined\") {\n        this.placementController.resetOverlayPosition();\n      }\n    }\n    if (changes.has(\"state\") && this.state === \"closed\" && typeof changes.get(\"state\") !== \"undefined\") {\n      this.placementController.clearOverlayPosition();\n    }\n  }\n  /**\n   * Renders the content of the overlay.\n   *\n   * This method returns a template result containing a slot element. The slot element\n   * listens for the `slotchange` event to manage the overlay's state.\n   *\n   * @protected\n   * @returns {TemplateResult} The template result containing the slot element.\n   */\n  renderContent() {\n    return html`\n            <slot @slotchange=${this.handleSlotchange}></slot>\n        `;\n  }\n  /**\n   * Generates a style map for the dialog element.\n   *\n   * This method returns an object containing CSS custom properties for the dialog element.\n   * The `--swc-overlay-open-count` custom property is set to the current open count of overlays.\n   *\n   * @private\n   * @returns {StyleInfo} The style map for the dialog element.\n   */\n  get dialogStyleMap() {\n    return {\n      \"--swc-overlay-open-count\": _Overlay.openCount.toString()\n    };\n  }\n  /**\n   * Renders the popover element for the overlay.\n   *\n   * This method returns a template result containing a div element styled as a popover.\n   * The popover element includes various attributes and event listeners to manage the overlay's state and behavior.\n   *\n   * @protected\n   * @returns {TemplateResult} The template result containing the popover element.\n   */\n  renderPopover() {\n    return html`\n            <div\n                class=\"dialog\"\n                part=\"dialog\"\n                role=${ifDefined(\n      this.type === \"modal\" || this.type === \"page\" ? \"dialog\" : void 0\n    )}\n                aria-modal=${ifDefined(\n      this.type === \"modal\" || this.type === \"page\" ? \"true\" : void 0\n    )}\n                placement=${ifDefined(\n      this.requiresPositioning ? this.placement || \"right\" : void 0\n    )}\n                popover=${ifDefined(this.popoverValue)}\n                style=${styleMap(this.dialogStyleMap)}\n                @beforetoggle=${this.handleBeforetoggle}\n                @close=${this.handleBrowserClose}\n                ?is-visible=${this.state !== \"closed\"}\n            >\n                ${this.renderContent()}\n            </div>\n        `;\n  }\n  /**\n   * Renders the overlay component.\n   *\n   * This method returns a template result containing either a dialog or popover element\n   * based on the overlay type. It also includes a slot for longpress descriptors.\n   *\n   * @override\n   * @returns {TemplateResult} The template result containing the overlay content.\n   */\n  render() {\n    return html`\n            ${this.renderPopover()}\n            <slot name=\"longpress-describedby-descriptor\"></slot>\n        `;\n  }\n  /**\n   * Lifecycle method called when the component is added to the DOM.\n   *\n   * This method sets up event listeners and binds events if the component has already updated.\n   *\n   * @override\n   */\n  connectedCallback() {\n    super.connectedCallback();\n    this.addEventListener(\"close\", () => {\n      this.open = false;\n    });\n    if (this.hasUpdated) {\n      this.bindEvents();\n    }\n  }\n  /**\n   * Lifecycle method called when the component is removed from the DOM.\n   *\n   * This method releases the description from the strategy and updates the 'open' property.\n   *\n   * @override\n   */\n  disconnectedCallback() {\n    var _a;\n    (_a = this.strategy) == null ? void 0 : _a.releaseDescription();\n    this.open = false;\n    super.disconnectedCallback();\n  }\n};\n_Overlay.styles = [styles];\n/**\n * Tracks the number of overlays that have been opened.\n *\n * This static property is used to manage the stacking context of multiple overlays.\n *\n * @type {number}\n * @default 1\n */\n_Overlay.openCount = 1;\n__decorateClass([\n  property({ type: Boolean })\n], _Overlay.prototype, \"delayed\", 1);\n__decorateClass([\n  query(\".dialog\")\n], _Overlay.prototype, \"dialogEl\", 2);\n__decorateClass([\n  property({ type: Boolean })\n], _Overlay.prototype, \"disabled\", 1);\n__decorateClass([\n  queryAssignedElements({\n    flatten: true,\n    selector: ':not([slot=\"longpress-describedby-descriptor\"], slot)'\n  })\n], _Overlay.prototype, \"elements\", 2);\n__decorateClass([\n  property({ type: Number })\n], _Overlay.prototype, \"offset\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], _Overlay.prototype, \"open\", 1);\n__decorateClass([\n  property()\n], _Overlay.prototype, \"placement\", 2);\n__decorateClass([\n  property({ attribute: \"receives-focus\" })\n], _Overlay.prototype, \"receivesFocus\", 2);\n__decorateClass([\n  property({ type: Boolean, attribute: \"allow-outside-click\" })\n], _Overlay.prototype, \"allowOutsideClick\", 2);\n__decorateClass([\n  query(\"slot\")\n], _Overlay.prototype, \"slotEl\", 2);\n__decorateClass([\n  state()\n], _Overlay.prototype, \"state\", 1);\n__decorateClass([\n  property({ type: Number, attribute: \"tip-padding\" })\n], _Overlay.prototype, \"tipPadding\", 2);\n__decorateClass([\n  property()\n], _Overlay.prototype, \"trigger\", 2);\n__decorateClass([\n  property({ attribute: false })\n], _Overlay.prototype, \"triggerElement\", 2);\n__decorateClass([\n  property({ attribute: false })\n], _Overlay.prototype, \"triggerInteraction\", 2);\n__decorateClass([\n  property()\n], _Overlay.prototype, \"type\", 2);\nexport let Overlay = _Overlay;\n//# sourceMappingURL=Overlay.dev.js.map\n"],"names":[],"sourceRoot":""}