{"version":3,"file":"6216.44859603.iframe.bundle.js","mappings":";;AA8EA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AAGA;;AAIA;AACA;;;AAGA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;;;AAKA;;AAEA;;AAEA;AACA;;;;;AAKA;;AAEA;;AAEA;AACA;;;;AAIA;;AAEA;;AAEA;;AAGA;;;;AC3IA;AAmGA;AAEA;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAGA;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAIA;;;;AAcA;;AAEA;AAMA;;;;;;;;;;AC/JA;;;;;;;;;;;;;;;AAkBA;;;;;;;;;;;;;AAwBA;AAwEA;AAEA;;;;;;;;;;AAsCA;;;AAqCA;AACA;;;;;;;;;AASA;;;;;;;AAOA;;;;;;AAMA;;;;AAIA;;AAEA;AACA;;;AAGA;;;;;;AAOA;;;;;;;;;;;;;;;;AA+BA;;;;;;;AAsBA;;;;;AAOA;;;;;AAMA;;AClVA;;;;;;;;;AAwCA;;AAIA;AAEA","sources":["webpack://@adobe/spectrum-web-components/./packages/dialog/src/DialogWrapper.dev.js","webpack://@adobe/spectrum-web-components/./packages/overlay/src/OverlayTrigger.dev.js","webpack://@adobe/spectrum-web-components/./packages/overlay/stories/overlay-story-components.js","webpack://@adobe/spectrum-web-components/./packages/popover/src/Popover.dev.js"],"sourcesContent":["\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  nothing\n} from \"@spectrum-web-components/base\";\nimport { property } from \"@spectrum-web-components/base/src/decorators.js\";\nimport { ifDefined } from \"@spectrum-web-components/base/src/directives.js\";\nimport \"@spectrum-web-components/button/sp-button.js\";\nimport \"@spectrum-web-components/underlay/sp-underlay.js\";\nimport \"@spectrum-web-components/dialog/sp-dialog.js\";\nimport { DialogBase } from \"./DialogBase.dev.js\";\nexport class DialogWrapper extends DialogBase {\n  constructor() {\n    super(...arguments);\n    this.error = false;\n    this.cancelLabel = \"\";\n    this.confirmLabel = \"\";\n    this.dismissLabel = \"Close\";\n    this.footer = \"\";\n    this.hero = \"\";\n    this.heroLabel = \"\";\n    this.noDivider = false;\n    this.secondaryLabel = \"\";\n    this.headline = \"\";\n  }\n  static get styles() {\n    return [...super.styles];\n  }\n  get dialog() {\n    return this.shadowRoot.querySelector(\"sp-dialog\");\n  }\n  clickSecondary() {\n    this.dispatchEvent(\n      new Event(\"secondary\", {\n        bubbles: true\n      })\n    );\n  }\n  clickCancel() {\n    this.dispatchEvent(\n      new Event(\"cancel\", {\n        bubbles: true\n      })\n    );\n  }\n  clickConfirm() {\n    this.dispatchEvent(\n      new Event(\"confirm\", {\n        bubbles: true\n      })\n    );\n  }\n  renderDialog() {\n    const hideDivider = this.noDivider || !this.headline || this.headlineVisibility === \"none\";\n    if (true) {\n      if (!this.headline) {\n        window.__swc.warn(\n          this,\n          `<${this.localName}> elements will not be accessible to screen readers without a \"headline\" attribute or property.`,\n          \"https://opensource.adobe.com/spectrum-web-components/components/dialog-wrapper/#accessibility\",\n          {\n            type: \"accessibility\"\n          }\n        );\n      }\n    }\n    return html`\n            <sp-dialog\n                ?dismissable=${this.dismissable}\n                dismiss-label=${this.dismissLabel}\n                ?no-divider=${hideDivider}\n                ?error=${this.error}\n                mode=${ifDefined(this.mode)}\n                size=${ifDefined(this.size)}\n            >\n                ${this.hero ? html`\n                          <img\n                              src=\"${this.hero}\"\n                              slot=\"hero\"\n                              aria-hidden=${ifDefined(\n      this.heroLabel ? void 0 : \"true\"\n    )}\n                              alt=${ifDefined(\n      this.heroLabel ? this.heroLabel : void 0\n    )}\n                          />\n                      ` : nothing}\n                ${this.headline ? html`\n                          <h2\n                              slot=\"heading\"\n                              ?hidden=${this.headlineVisibility === \"none\"}\n                          >\n                              ${this.headline}\n                          </h2>\n                      ` : nothing}\n                <slot></slot>\n                ${this.footer ? html`\n                          <div slot=\"footer\">${this.footer}</div>\n                      ` : nothing}\n                ${this.cancelLabel ? html`\n                          <sp-button\n                              variant=\"secondary\"\n                              treatment=\"outline\"\n                              slot=\"button\"\n                              @click=${this.clickCancel}\n                          >\n                              ${this.cancelLabel}\n                          </sp-button>\n                      ` : nothing}\n                ${this.secondaryLabel ? html`\n                          <sp-button\n                              variant=\"primary\"\n                              treatment=\"outline\"\n                              slot=\"button\"\n                              @click=${this.clickSecondary}\n                          >\n                              ${this.secondaryLabel}\n                          </sp-button>\n                      ` : nothing}\n                ${this.confirmLabel ? html`\n                          <sp-button\n                              variant=\"accent\"\n                              slot=\"button\"\n                              @click=${this.clickConfirm}\n                          >\n                              ${this.confirmLabel}\n                          </sp-button>\n                      ` : nothing}\n            </sp-dialog>\n        `;\n  }\n}\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], DialogWrapper.prototype, \"error\", 2);\n__decorateClass([\n  property({ attribute: \"cancel-label\" })\n], DialogWrapper.prototype, \"cancelLabel\", 2);\n__decorateClass([\n  property({ attribute: \"confirm-label\" })\n], DialogWrapper.prototype, \"confirmLabel\", 2);\n__decorateClass([\n  property({ attribute: \"dismiss-label\" })\n], DialogWrapper.prototype, \"dismissLabel\", 2);\n__decorateClass([\n  property()\n], DialogWrapper.prototype, \"footer\", 2);\n__decorateClass([\n  property()\n], DialogWrapper.prototype, \"hero\", 2);\n__decorateClass([\n  property({ attribute: \"hero-label\" })\n], DialogWrapper.prototype, \"heroLabel\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true, attribute: \"no-divider\" })\n], DialogWrapper.prototype, \"noDivider\", 2);\n__decorateClass([\n  property({ type: String, reflect: true })\n], DialogWrapper.prototype, \"size\", 2);\n__decorateClass([\n  property({ attribute: \"secondary-label\" })\n], DialogWrapper.prototype, \"secondaryLabel\", 2);\n__decorateClass([\n  property()\n], DialogWrapper.prototype, \"headline\", 2);\n__decorateClass([\n  property({ type: String, attribute: \"headline-visibility\" })\n], DialogWrapper.prototype, \"headlineVisibility\", 2);\n//# sourceMappingURL=DialogWrapper.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query,\n  state\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport \"@spectrum-web-components/overlay/sp-overlay.js\";\nimport overlayTriggerStyles from \"./overlay-trigger.css.js\";\nexport class OverlayTrigger extends SpectrumElement {\n  constructor() {\n    super(...arguments);\n    this.offset = 6;\n    this.disabled = false;\n    this.receivesFocus = \"auto\";\n    this.clickContent = [];\n    this.longpressContent = [];\n    this.hoverContent = [];\n    this.targetContent = [];\n  }\n  static get styles() {\n    return [overlayTriggerStyles];\n  }\n  getAssignedElementsFromSlot(slot) {\n    return slot.assignedElements({ flatten: true });\n  }\n  handleTriggerContent(event) {\n    this.targetContent = this.getAssignedElementsFromSlot(event.target);\n  }\n  handleSlotContent(event) {\n    switch (event.target.name) {\n      case \"click-content\":\n        this.clickContent = this.getAssignedElementsFromSlot(\n          event.target\n        );\n        break;\n      case \"longpress-content\":\n        this.longpressContent = this.getAssignedElementsFromSlot(\n          event.target\n        );\n        break;\n      case \"hover-content\":\n        this.hoverContent = this.getAssignedElementsFromSlot(\n          event.target\n        );\n        break;\n    }\n  }\n  handleBeforetoggle(event) {\n    const { target } = event;\n    let type;\n    if (target === this.clickOverlayElement) {\n      type = \"click\";\n    } else if (target === this.longpressOverlayElement) {\n      type = \"longpress\";\n    } else if (target === this.hoverOverlayElement) {\n      type = \"hover\";\n    } else {\n      return;\n    }\n    if (event.newState === \"open\") {\n      this.open = type;\n    } else if (this.open === type) {\n      this.open = void 0;\n    }\n  }\n  update(changes) {\n    var _a, _b, _c, _d, _e, _f;\n    if (changes.has(\"clickContent\")) {\n      this.clickPlacement = ((_a = this.clickContent[0]) == null ? void 0 : _a.getAttribute(\"placement\")) || ((_b = this.clickContent[0]) == null ? void 0 : _b.getAttribute(\n        \"direction\"\n      )) || void 0;\n    }\n    if (changes.has(\"hoverContent\")) {\n      this.hoverPlacement = ((_c = this.hoverContent[0]) == null ? void 0 : _c.getAttribute(\"placement\")) || ((_d = this.hoverContent[0]) == null ? void 0 : _d.getAttribute(\n        \"direction\"\n      )) || void 0;\n    }\n    if (changes.has(\"longpressContent\")) {\n      this.longpressPlacement = ((_e = this.longpressContent[0]) == null ? void 0 : _e.getAttribute(\"placement\")) || ((_f = this.longpressContent[0]) == null ? void 0 : _f.getAttribute(\n        \"direction\"\n      )) || void 0;\n    }\n    super.update(changes);\n  }\n  renderSlot(name) {\n    return html`\n            <slot name=${name} @slotchange=${this.handleSlotContent}></slot>\n        `;\n  }\n  renderClickOverlay() {\n    var _a;\n    const slot = this.renderSlot(\"click-content\");\n    const clickOverlay = html`\n            <sp-overlay\n                id=\"click-overlay\"\n                ?disabled=${this.disabled || !this.clickContent.length}\n                ?open=${this.open === \"click\" && !!this.clickContent.length}\n                .offset=${this.offset}\n                .placement=${this.clickPlacement || this.placement}\n                .triggerElement=${this.targetContent[0]}\n                .triggerInteraction=${\"click\"}\n                .type=${this.type !== \"modal\" ? \"auto\" : \"modal\"}\n                @beforetoggle=${this.handleBeforetoggle}\n                .receivesFocus=${this.receivesFocus}\n            >\n                ${slot}\n            </sp-overlay>\n        `;\n    if ((_a = this.triggeredBy) == null ? void 0 : _a.includes(\"click\")) {\n      return clickOverlay;\n    }\n    if (!this.clickContent.length) {\n      return slot;\n    } else {\n      return clickOverlay;\n    }\n  }\n  renderHoverOverlay() {\n    var _a;\n    const slot = this.renderSlot(\"hover-content\");\n    const hoverOverlay = html`\n            <sp-overlay\n                id=\"hover-overlay\"\n                ?open=${this.open === \"hover\" && !!this.hoverContent.length}\n                ?disabled=${this.disabled || !this.hoverContent.length || !!this.open && this.open !== \"hover\"}\n                .offset=${this.offset}\n                .placement=${this.hoverPlacement || this.placement}\n                .triggerElement=${this.targetContent[0]}\n                .triggerInteraction=${\"hover\"}\n                .type=${\"hint\"}\n                @beforetoggle=${this.handleBeforetoggle}\n                .receivesFocus=${this.receivesFocus}\n            >\n                ${slot}\n            </sp-overlay>\n        `;\n    if ((_a = this.triggeredBy) == null ? void 0 : _a.includes(\"hover\")) {\n      return hoverOverlay;\n    }\n    if (!this.hoverContent.length) {\n      return slot;\n    } else {\n      return hoverOverlay;\n    }\n  }\n  renderLongpressOverlay() {\n    var _a;\n    const slot = this.renderSlot(\"longpress-content\");\n    const longpressOverlay = html`\n            <sp-overlay\n                id=\"longpress-overlay\"\n                ?disabled=${this.disabled || !this.longpressContent.length}\n                ?open=${this.open === \"longpress\" && !!this.longpressContent.length}\n                .offset=${this.offset}\n                .placement=${this.longpressPlacement || this.placement}\n                .triggerElement=${this.targetContent[0]}\n                .triggerInteraction=${\"longpress\"}\n                .type=${\"auto\"}\n                @beforetoggle=${this.handleBeforetoggle}\n                .receivesFocus=${this.receivesFocus}\n            >\n                ${slot}\n            </sp-overlay>\n            <slot name=\"longpress-describedby-descriptor\"></slot>\n        `;\n    if ((_a = this.triggeredBy) == null ? void 0 : _a.includes(\"longpress\")) {\n      return longpressOverlay;\n    }\n    if (!this.longpressContent.length) {\n      return slot;\n    } else {\n      return longpressOverlay;\n    }\n  }\n  render() {\n    return html`\n            <slot\n                id=\"trigger\"\n                name=\"trigger\"\n                @slotchange=${this.handleTriggerContent}\n            ></slot>\n            ${[\n      this.renderClickOverlay(),\n      this.renderHoverOverlay(),\n      this.renderLongpressOverlay()\n    ]}\n        `;\n  }\n  updated(changedProperties) {\n    super.updated(changedProperties);\n    if (!this.triggeredBy) {\n      const issues = [\n        \"You have not specified the `triggeredBy` property. For optimal performance, consider explicitly declaring which overlay types you plan to use.\",\n        'Example: triggered-by=\"click hover\"',\n        \"This helps avoid unnecessary DOM operations and potential race conditions.\"\n      ];\n      window.__swc.warn(\n        this,\n        \"Performance optimization available for <overlay-trigger>:\",\n        \"https://opensource.adobe.com/spectrum-web-components/components/overlay-trigger/#performance-optimization\",\n        { issues }\n      );\n    }\n    if (this.disabled && changedProperties.has(\"disabled\")) {\n      this.open = void 0;\n      return;\n    }\n  }\n  async getUpdateComplete() {\n    const complete = await super.getUpdateComplete();\n    return complete;\n  }\n}\n__decorateClass([\n  property({ attribute: \"triggered-by\" })\n], OverlayTrigger.prototype, \"triggeredBy\", 2);\n__decorateClass([\n  property({ reflect: true })\n], OverlayTrigger.prototype, \"placement\", 2);\n__decorateClass([\n  property()\n], OverlayTrigger.prototype, \"type\", 2);\n__decorateClass([\n  property({ type: Number })\n], OverlayTrigger.prototype, \"offset\", 2);\n__decorateClass([\n  property({ reflect: true })\n], OverlayTrigger.prototype, \"open\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], OverlayTrigger.prototype, \"disabled\", 2);\n__decorateClass([\n  property({ attribute: \"receives-focus\" })\n], OverlayTrigger.prototype, \"receivesFocus\", 2);\n__decorateClass([\n  state()\n], OverlayTrigger.prototype, \"clickContent\", 2);\n__decorateClass([\n  state()\n], OverlayTrigger.prototype, \"longpressContent\", 2);\n__decorateClass([\n  state()\n], OverlayTrigger.prototype, \"hoverContent\", 2);\n__decorateClass([\n  state()\n], OverlayTrigger.prototype, \"targetContent\", 2);\n__decorateClass([\n  query(\"#click-overlay\", true)\n], OverlayTrigger.prototype, \"clickOverlayElement\", 2);\n__decorateClass([\n  query(\"#longpress-overlay\", true)\n], OverlayTrigger.prototype, \"longpressOverlayElement\", 2);\n__decorateClass([\n  query(\"#hover-overlay\", true)\n], OverlayTrigger.prototype, \"hoverOverlayElement\", 2);\n//# sourceMappingURL=OverlayTrigger.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  css,\n  html,\n  LitElement\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport {\n  Overlay\n} from \"@spectrum-web-components/overlay\";\nimport \"@spectrum-web-components/button/sp-button.js\";\nimport \"@spectrum-web-components/popover/sp-popover.js\";\nimport \"@spectrum-web-components/radio/sp-radio.js\";\nimport \"@spectrum-web-components/radio/sp-radio-group.js\";\nimport \"@spectrum-web-components/overlay/overlay-trigger.js\";\nconst MAX_DEPTH = 7;\nclass OverlayTargetIcon extends LitElement {\n  static get styles() {\n    return css`\n            :host {\n                position: absolute;\n                display: block;\n                color: var(--spectrum-magenta-900);\n                width: 64px;\n                height: 64px;\n                top: 0;\n                left: 0;\n            }\n        `;\n  }\n  render() {\n    return html`\n            <svg\n                aria-hidden=\"true\"\n                focusable=\"false\"\n                data-prefix=\"fas\"\n                data-icon=\"bullseye\"\n                class=\"svg-inline--fa fa-bullseye fa-w-16\"\n                xmlns=\"http://www.w3.org/2000/svg\"\n                viewBox=\"0 0 496 512\"\n            >\n                <path\n                    fill=\"currentColor\"\n                    d=\"M248 8C111.03 8 0 119.03 0 256s111.03 248 248 248 248-111.03 248-248S384.97 8 248 8zm0 432c-101.69 0-184-82.29-184-184 0-101.69 82.29-184 184-184 101.69 0 184 82.29 184 184 0 101.69-82.29 184-184 184zm0-312c-70.69 0-128 57.31-128 128s57.31 128 128 128 128-57.31 128-128-57.31-128-128-128zm0 192c-35.29 0-64-28.71-64-64s28.71-64 64-64 64 28.71 64 64-28.71 64-64 64z\"\n                ></path>\n            </svg>\n        `;\n  }\n}\ncustomElements.define(\"overlay-target-icon\", OverlayTargetIcon);\nclass OverlayDrag extends LitElement {\n  constructor() {\n    super(...arguments);\n    this.top = 100;\n    this.left = 100;\n  }\n  static get styles() {\n    return css`\n            :host {\n                display: block;\n                width: 100%;\n                height: 100%;\n                position: relative;\n            }\n\n            ::slotted(*) {\n                display: block;\n                width: 100%;\n                height: 100%;\n            }\n        `;\n  }\n  onSlotChange(event) {\n    const slot = event.target;\n    this.targetElement = void 0;\n    const nodes = slot.assignedNodes();\n    const slotElement = nodes.find(\n      (node) => node instanceof HTMLElement\n    );\n    if (!slotElement) return;\n    this.targetElement = slotElement.querySelector(\n      '[slot=\"trigger\"]'\n    );\n    if (!this.targetElement) return;\n    this.targetElement.addEventListener(\n      \"pointerdown\",\n      (event2) => this.onMouseDown(event2)\n    );\n    this.resetTargetPosition();\n  }\n  onMouseDown(event) {\n    const target = event.target;\n    const parent = target.parentElement;\n    if (!parent) return;\n    target.setPointerCapture(event.pointerId);\n    const max = {\n      x: parent.offsetWidth - target.offsetWidth,\n      y: parent.offsetHeight - target.offsetHeight\n    };\n    const dragStart = {\n      x: event.clientX,\n      y: event.clientY\n    };\n    const originalPos = {\n      x: this.left,\n      y: this.top\n    };\n    const onMouseMove = (event2) => {\n      const dragDelta = {\n        x: event2.clientX - dragStart.x,\n        y: event2.clientY - dragStart.y\n      };\n      const newPosition = {\n        x: dragDelta.x + originalPos.x,\n        y: dragDelta.y + originalPos.y\n      };\n      this.left = Math.min(Math.max(newPosition.x, 0), max.x);\n      this.top = Math.min(Math.max(newPosition.y, 0), max.y);\n      Overlay.update();\n    };\n    const onMouseUp = (event2) => {\n      target.setPointerCapture(event2.pointerId);\n      document.removeEventListener(\"pointermove\", onMouseMove);\n      document.removeEventListener(\"pointerup\", onMouseUp);\n    };\n    document.addEventListener(\"pointermove\", onMouseMove);\n    document.addEventListener(\"pointerup\", onMouseUp);\n  }\n  resetTargetPosition() {\n    if (!this.targetElement) return;\n    const target = this.targetElement;\n    const parent = target.parentElement;\n    if (!parent) return;\n    this.left = (parent.offsetWidth - target.offsetWidth) / 2;\n    this.top = (parent.offsetHeight - target.offsetHeight) / 2;\n  }\n  updated() {\n    if (this.targetElement) {\n      this.targetElement.style.transform = `translate(${this.left}px, ${this.top}px)`;\n    }\n  }\n  render() {\n    return html`\n            <slot @slotchange=${this.onSlotChange}></slot>\n        `;\n  }\n}\n__decorateClass([\n  property({ type: Number })\n], OverlayDrag.prototype, \"top\", 2);\n__decorateClass([\n  property({ type: Number })\n], OverlayDrag.prototype, \"left\", 2);\ncustomElements.define(\"overlay-drag\", OverlayDrag);\nclass RecursivePopover extends LitElement {\n  constructor() {\n    super();\n    this.depth = 0;\n    this.isShiftTabbing = false;\n    this.placement = \"right\";\n    this.depth = 0;\n    this.addEventListener(\"keydown\", (event) => {\n      const { code } = event;\n      if (code === \"Enter\") {\n        this.trigger.click();\n      }\n    });\n    this.addEventListener(\"focusin\", this.handleFocusin);\n  }\n  static get styles() {\n    return [\n      css`\n                :host {\n                    display: block;\n                    text-align: center;\n                }\n\n                overlay-trigger {\n                    display: inline-flex;\n                    margin-top: 11px;\n                }\n            `\n    ];\n  }\n  handleFocusin() {\n    this.focus();\n  }\n  focus() {\n    if (this.shadowRoot.activeElement !== null) {\n      return;\n    }\n    const firstFocusable = this.shadowRoot.querySelector(\n      'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n    );\n    if (firstFocusable) {\n      if (firstFocusable.updateComplete) {\n        firstFocusable.updateComplete.then(\n          () => firstFocusable.focus()\n        );\n      } else {\n        firstFocusable.focus();\n      }\n      return;\n    }\n    super.focus();\n  }\n  onRadioChange(event) {\n    const target = event.target;\n    this.placement = target.selected;\n  }\n  captureEnter(event) {\n    const { code } = event;\n    if (code === \"Enter\") {\n      event.stopPropagation();\n    }\n  }\n  render() {\n    return html`\n            <sp-radio-group\n                horizontal\n                @change=${this.onRadioChange}\n                selected=\"${this.placement}\"\n                name=\"group-example\"\n            >\n                <sp-radio value=\"top\">Top</sp-radio>\n                <sp-radio value=\"right\">Right</sp-radio>\n                <sp-radio value=\"bottom\">Bottom</sp-radio>\n                <sp-radio value=\"left\">Left</sp-radio>\n            </sp-radio-group>\n            <overlay-trigger\n                placement=\"${this.placement}\"\n                type=\"modal\"\n                triggered-by=\"click hover\"\n            >\n                <sp-button\n                    slot=\"trigger\"\n                    variant=\"accent\"\n                    @keydown=${this.captureEnter}\n                >\n                    Open Popover\n                </sp-button>\n                <sp-popover\n                    slot=\"click-content\"\n                    direction=\"${this.placement}\"\n                    tip\n                >\n                    <sp-dialog size=\"s\" no-divider>\n                        ${this.depth < MAX_DEPTH ? html`\n                                  <recursive-popover\n                                      position=\"${this.placement}\"\n                                      depth=\"${this.depth + 1}\"\n                                      tabindex=\"0\"\n                                  ></recursive-popover>\n                              ` : html`\n                                  <div>Maximum Depth</div>\n                              `}\n                    </sp-dialog>\n                </sp-popover>\n            </overlay-trigger>\n        `;\n  }\n}\n__decorateClass([\n  property({ type: String })\n], RecursivePopover.prototype, \"placement\", 2);\n__decorateClass([\n  property({ type: Number })\n], RecursivePopover.prototype, \"depth\", 2);\n__decorateClass([\n  query('[slot=\"trigger\"]')\n], RecursivePopover.prototype, \"trigger\", 2);\ncustomElements.define(\"recursive-popover\", RecursivePopover);\nexport class PopoverContent extends LitElement {\n  render() {\n    return html`\n            <overlay-trigger\n                type=\"modal\"\n                placement=\"bottom\"\n                triggered-by=\"click hover\"\n            >\n                <sp-button slot=\"trigger\">Open me</sp-button>\n                <sp-popover slot=\"click-content\" direction=\"bottom\">\n                    <sp-dialog no-divider>\n                        <p>This is all the content.</p>\n                        <p>This is all the content.</p>\n                        <p>This is all the content.</p>\n                        <p>This is all the content.</p>\n                    </sp-dialog>\n                </sp-popover>\n            </overlay-trigger>\n        `;\n  }\n}\n__decorateClass([\n  query('[slot=\"trigger\"]')\n], PopoverContent.prototype, \"button\", 2);\n__decorateClass([\n  query(\"overlay-trigger\")\n], PopoverContent.prototype, \"trigger\", 2);\ncustomElements.define(\"popover-content\", PopoverContent);\nexport default class TransientHover extends LitElement {\n  constructor() {\n    super(...arguments);\n    this.open = false;\n  }\n  render() {\n    return html`\n            <sp-button variant=\"primary\" id=\"triggerButton\">\n                Button popover\n            </sp-button>\n            <sp-overlay\n                type=\"auto\"\n                trigger=\"triggerButton@click\"\n                @sp-opened=${() => {\n      this.open = true;\n    }}\n            >\n                <sp-popover>My Popover</sp-popover>\n            </sp-overlay>\n\n            ${!this.open ? html`\n                      <sp-overlay trigger=\"triggerButton@hover\" type=\"hint\">\n                          <sp-tooltip placement=\"right\">My tooltip</sp-tooltip>\n                      </sp-overlay>\n                  ` : html``}\n        `;\n  }\n}\n__decorateClass([\n  property()\n], TransientHover.prototype, \"open\", 2);\ncustomElements.define(\"transient-hover\", TransientHover);\n//# sourceMappingURL=overlay-story-components.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  nothing,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport popoverStyles from \"./popover.css.js\";\nexport class Popover extends SpectrumElement {\n  constructor() {\n    super(...arguments);\n    this.open = false;\n    this.tip = false;\n  }\n  static get styles() {\n    return [popoverStyles];\n  }\n  renderTip() {\n    return html`\n            <div id=\"tip\" aria-hidden=\"true\">\n                <svg class=\"tip block\" viewBox=\"0 -0.5 16 9\">\n                    <path class=\"triangle\" d=\"M-1,-1 8,8 17,-1\"></path>\n                </svg>\n                <svg class=\"tip inline\" viewBox=\"0 -0.5 9 16\">\n                    <path class=\"triangle\" d=\"M-1,-1 8,8 -1,17\"></path>\n                </svg>\n            </div>\n        `;\n  }\n  render() {\n    return html`\n            <slot></slot>\n            ${this.tip ? this.renderTip() : nothing}\n        `;\n  }\n}\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Popover.prototype, \"open\", 2);\n__decorateClass([\n  property({ reflect: true })\n], Popover.prototype, \"placement\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Popover.prototype, \"tip\", 2);\n__decorateClass([\n  query(\"#tip\")\n], Popover.prototype, \"tipElement\", 2);\n//# sourceMappingURL=Popover.dev.js.map\n"],"names":[],"sourceRoot":""}