import { S as SpectrumElement } from './define-element-e64f5ea4.js';

function T(o,i,l=[]){for(let e=0;e<i.length;++e){const n=i[e],r=o[e],t=r.parentElement||r.getRootNode();l[e]&&l[e](n),t&&t!==r&&t.replaceChild(n,r),delete o[e];}return i}const reparentChildren=(o,i,{position:l,prepareCallback:e}={position:"beforeend"})=>{let{length:n}=o;if(n===0)return ()=>o;let r=1,t=0;(l==="afterbegin"||l==="afterend")&&(r=-1,t=n-1);const a=new Array(n),c=new Array(n),p=document.createComment("placeholder for reparented element");do{const d=o[t];e&&(c[t]=e(d)),a[t]=p.cloneNode();const m=d.parentElement||d.getRootNode();m&&m!==d&&m.replaceChild(a[t],d),i.insertAdjacentElement(l,d),t+=r;}while(--n>0);return function(){return T(a,o,c)}};

class OverlayTimer{constructor(e={}){this.warmUpDelay=1e3;this.coolDownDelay=1e3;this.isWarm=!1;this.timeout=0;Object.assign(this,e);}async openTimer(e){if(this.cancelCooldownTimer(),!this.component||e!==this.component)return this.component&&(this.close(this.component),this.cancelCooldownTimer()),this.component=e,this.isWarm?!1:(this.promise=new Promise(o=>{this.resolve=o,this.timeout=window.setTimeout(()=>{this.resolve&&(this.resolve(!1),this.isWarm=!0);},this.warmUpDelay);}),this.promise);if(this.promise)return this.promise;throw new Error("Inconsistent state")}close(e){this.component&&this.component===e&&(this.resetCooldownTimer(),this.timeout>0&&(clearTimeout(this.timeout),this.timeout=0),this.resolve&&(this.resolve(!0),delete this.resolve),delete this.promise,delete this.component);}resetCooldownTimer(){this.isWarm&&(this.cooldownTimeout&&window.clearTimeout(this.cooldownTimeout),this.cooldownTimeout=window.setTimeout(()=>{this.isWarm=!1,delete this.cooldownTimeout;},this.coolDownDelay));}cancelCooldownTimer(){this.cooldownTimeout&&window.clearTimeout(this.cooldownTimeout),delete this.cooldownTimeout;}}

const overlayTimer=new OverlayTimer,noop=()=>{};class BeforetoggleClosedEvent extends Event{constructor(){super("beforetoggle",{bubbles:!1,composed:!1});this.currentState="open";this.newState="closed";}}class BeforetoggleOpenEvent extends Event{constructor(){super("beforetoggle",{bubbles:!1,composed:!1});this.currentState="closed";this.newState="open";}}const guaranteedAllTransitionend=(o,d,t)=>{const a=new AbortController,n=new Map,c=()=>{a.abort(),t();};let u,s;const e=requestAnimationFrame(()=>{u=requestAnimationFrame(()=>{s=requestAnimationFrame(()=>{c();});});}),m=r=>{r.target===o&&(n.set(r.propertyName,n.get(r.propertyName)-1),n.get(r.propertyName)||n.delete(r.propertyName),n.size===0&&c());},y=r=>{r.target===o&&(n.has(r.propertyName)||n.set(r.propertyName,0),n.set(r.propertyName,n.get(r.propertyName)+1),cancelAnimationFrame(e),cancelAnimationFrame(u),cancelAnimationFrame(s));};o.addEventListener("transitionrun",y,{signal:a.signal}),o.addEventListener("transitionend",m,{signal:a.signal}),o.addEventListener("transitioncancel",m,{signal:a.signal}),d();};function nextFrame(){return new Promise(o=>requestAnimationFrame(()=>o()))}function forcePaint(){document.body.offsetHeight;}class AbstractOverlay extends SpectrumElement{constructor(){super(...arguments);this.dispose=noop;this.offset=6;this.willPreventClose=!1;}async applyFocus(t,a){}async ensureOnDOM(t){}async makeTransition(t){return null}async manageDelay(t){}async manageDialogOpen(){}async managePopoverOpen(){}managePosition(){}get open(){return !1}set open(t){}get state(){return "closed"}set state(t){}manuallyKeepOpen(){}static update(){const t=new CustomEvent("sp-update-overlays",{bubbles:!0,composed:!0,cancelable:!0});document.dispatchEvent(t);}static async open(t,a,n,c){var g,b,f,O;await import('./sp-overlay-2f9e6847.js').then(function (n) { return n.s; });const u=arguments.length===2,s=n||t,e=new this;let m=!1;e.dispose=()=>{e.addEventListener("sp-closed",()=>{m||(y(),m=!0),requestAnimationFrame(()=>{e.remove();});}),e.open=!1,e.dispose=noop;};const y=reparentChildren([s],e,{position:"beforeend",prepareCallback:l=>{const v=l.slot;return l.removeAttribute("slot"),()=>{l.slot=v;}}});if(!u&&s&&c){const l=t,v=a,p=c;return e.delayed=p.delayed||s.hasAttribute("delayed"),e.receivesFocus=(g=p.receivesFocus)!=null?g:"auto",e.triggerElement=p.virtualTrigger||l,e.type=v==="modal"?"modal":v==="hover"?"hint":"auto",e.offset=(b=p.offset)!=null?b:6,e.placement=p.placement,e.willPreventClose=!!p.notImmediatelyClosable,l.insertAdjacentElement("afterend",e),await e.updateComplete,e.open=!0,e.dispose}const i=a;return e.append(s),e.delayed=i.delayed||s.hasAttribute("delayed"),e.receivesFocus=(f=i.receivesFocus)!=null?f:"auto",e.triggerElement=i.trigger||null,e.type=i.type||"modal",e.offset=(O=i.offset)!=null?O:6,e.placement=i.placement,e.willPreventClose=!!i.notImmediatelyClosable,e.updateComplete.then(()=>{e.open=!0;}),e}}

class VirtualTrigger{constructor(t,i){this.x=0;this.y=0;this.x=t,this.y=i;}updateBoundingClientRect(t,i){this.x=t,this.y=i,AbstractOverlay.update();}getBoundingClientRect(){return {width:0,height:0,top:this.y,right:this.x,y:this.y,x:this.x,bottom:this.y,left:this.x,toJSON(){}}}}

export { AbstractOverlay as A, BeforetoggleOpenEvent as B, VirtualTrigger as V, BeforetoggleClosedEvent as a, noop as b, forcePaint as f, guaranteedAllTransitionend as g, nextFrame as n, overlayTimer as o };
