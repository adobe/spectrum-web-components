import { S as SpectrumElement } from './define-element-C4UuMSqY.js';

function T(o,i,l=[]){for(let e=0;e<i.length;++e){const n=i[e],r=o[e],t=r.parentElement||r.getRootNode();l[e]&&l[e](n),t&&t!==r&&t.replaceChild(n,r),delete o[e];}return i}const reparentChildren=(o,i,{position:l,prepareCallback:e}={position:"beforeend"})=>{let{length:n}=o;if(n===0)return ()=>o;let r=1,t=0;(l==="afterbegin"||l==="afterend")&&(r=-1,t=n-1);const a=new Array(n),c=new Array(n),p=document.createComment("placeholder for reparented element");do{const d=o[t];e&&(c[t]=e(d)),a[t]=p.cloneNode();const m=d.parentElement||d.getRootNode();m&&m!==d&&m.replaceChild(a[t],d),i.insertAdjacentElement(l,d),t+=r;}while(--n>0);return function(){return T(a,o,c)}};

class OverlayTimer{constructor(e={}){this.warmUpDelay=1e3;this.coolDownDelay=1e3;this.isWarm=!1;this.timeout=0;Object.assign(this,e);}async openTimer(e){if(this.cancelCooldownTimer(),!this.component||e!==this.component)return this.component&&(this.close(this.component),this.cancelCooldownTimer()),this.component=e,this.isWarm?!1:(this.promise=new Promise(o=>{this.resolve=o,this.timeout=window.setTimeout(()=>{this.resolve&&(this.resolve(!1),this.isWarm=!0);},this.warmUpDelay);}),this.promise);if(this.promise)return this.promise;throw new Error("Inconsistent state")}close(e){this.component&&this.component===e&&(this.resetCooldownTimer(),this.timeout>0&&(clearTimeout(this.timeout),this.timeout=0),this.resolve&&(this.resolve(!0),delete this.resolve),delete this.promise,delete this.component);}resetCooldownTimer(){this.isWarm&&(this.cooldownTimeout&&window.clearTimeout(this.cooldownTimeout),this.cooldownTimeout=window.setTimeout(()=>{this.isWarm=!1,delete this.cooldownTimeout;},this.coolDownDelay));}cancelCooldownTimer(){this.cooldownTimeout&&window.clearTimeout(this.cooldownTimeout),delete this.cooldownTimeout;}}

const overlayTimer=new OverlayTimer,noop=()=>{},guaranteedAllTransitionend=(i,v,e)=>{const r=new AbortController,n=new Map,a=()=>{r.abort(),e();};let m,l;const t=requestAnimationFrame(()=>{m=requestAnimationFrame(()=>{l=requestAnimationFrame(()=>{a();});});}),p=o=>{o.target===i&&(n.set(o.propertyName,n.get(o.propertyName)-1),n.get(o.propertyName)||n.delete(o.propertyName),n.size===0&&a());},d=o=>{o.target===i&&(n.has(o.propertyName)||n.set(o.propertyName,0),n.set(o.propertyName,n.get(o.propertyName)+1),cancelAnimationFrame(t),cancelAnimationFrame(m),cancelAnimationFrame(l));};i.addEventListener("transitionrun",d,{signal:r.signal}),i.addEventListener("transitionend",p,{signal:r.signal}),i.addEventListener("transitioncancel",p,{signal:r.signal}),v();};function nextFrame(){return new Promise(i=>requestAnimationFrame(()=>i()))}class AbstractOverlay extends SpectrumElement{constructor(){super(...arguments);this.dispose=noop;this.offset=0;this.willPreventClose=!1;}async applyFocus(e,r){}get delayed(){return !1}set delayed(e){}get disabled(){return !1}set disabled(e){}get elementResolver(){return this._elementResolver}set elementResolver(e){this._elementResolver=e;}async ensureOnDOM(e){}async makeTransition(e){return null}async manageDelay(e){}async manageDialogOpen(){}async managePopoverOpen(){}managePosition(){}get open(){return !1}set open(e){}get placementController(){return this._placementController}set placementController(e){this._placementController=e;}requestSlottable(){}returnFocus(){}get state(){return "closed"}set state(e){}manuallyKeepOpen(){}static update(){const e=new CustomEvent("sp-update-overlays",{bubbles:!0,composed:!0,cancelable:!0});document.dispatchEvent(e);}static async open(e,r,n,a){await import('./sp-overlay-BhZpjyEA.js');const m=arguments.length===2,l=n||e,t=new this;let p=!1;t.dispose=()=>{t.addEventListener("sp-closed",()=>{p||(d(),p=!0),requestAnimationFrame(()=>{t.remove();});}),t.open=!1,t.dispose=noop;};const d=reparentChildren([l],t,{position:"beforeend",prepareCallback:s=>{const c=s.slot;return s.removeAttribute("slot"),()=>{s.slot=c;}}});if(!m&&l&&a){const s=e,c=r,u=a;return AbstractOverlay.applyOptions(t,{...u,delayed:u.delayed||l.hasAttribute("delayed"),trigger:u.virtualTrigger||s,type:c==="modal"?"modal":c==="hover"?"hint":"auto"}),s.insertAdjacentElement("afterend",t),await t.updateComplete,t.open=!0,t.dispose}const y=r;return t.append(l),AbstractOverlay.applyOptions(t,{...y,delayed:y.delayed||l.hasAttribute("delayed")}),t.updateComplete.then(()=>{t.open=!0;}),t}static applyOptions(e,r){var n,a;e.delayed=!!r.delayed,e.receivesFocus=(n=r.receivesFocus)!=null?n:"auto",e.triggerElement=r.trigger||null,e.type=r.type||"modal",e.offset=(a=r.offset)!=null?a:0,e.placement=r.placement,e.willPreventClose=!!r.notImmediatelyClosable;}disconnectedCallback(){super.disconnectedCallback();}}

class VirtualTrigger{constructor(t,i){this.x=0;this.y=0;this.x=t,this.y=i;}updateBoundingClientRect(t,i){this.x=t,this.y=i,AbstractOverlay.update();}getBoundingClientRect(){return {width:0,height:0,top:this.y,right:this.x,y:this.y,x:this.x,bottom:this.y,left:this.x,toJSON(){}}}}

export { AbstractOverlay as A, VirtualTrigger as V, noop as a, guaranteedAllTransitionend as g, nextFrame as n, overlayTimer as o };
