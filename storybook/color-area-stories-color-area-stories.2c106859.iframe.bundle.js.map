{"version":3,"file":"color-area-stories-color-area-stories.2c106859.iframe.bundle.js","mappings":";;AACA;;AAqWA;;AAEA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;AAYA;;;;;;;AAOA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;;;;;;;;AAQA;AACA;;AAEA;;;;AAIA;;AAEA;AACA;AACA;;;;AAKA;;;AChZA;AAMA;;;AAOA;;AAGA;;;;AAMA;;;;AAKA;;;;AAUA;;;;AAgBA;;AAKA;;AAKA;;;;AAOA;AAyDA;;AAMA","sources":["webpack://@adobe/spectrum-web-components/./packages/color-area/src/ColorArea.dev.js","webpack://@adobe/spectrum-web-components/./packages/color-area/stories/color-area.stories.js"],"sourcesContent":["\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport { ifDefined } from \"@spectrum-web-components/base/src/directives.js\";\nimport {\n  property,\n  query\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport { streamingListener } from \"@spectrum-web-components/base/src/streaming-listener.js\";\nimport \"@spectrum-web-components/color-handle/sp-color-handle.js\";\nimport {\n  ColorController\n} from \"@spectrum-web-components/reactive-controllers/src/ColorController.js\";\nimport { LanguageResolutionController } from \"@spectrum-web-components/reactive-controllers/src/LanguageResolution.js\";\nimport {\n  isAndroid,\n  isIOS\n} from \"@spectrum-web-components/shared/src/platform.js\";\nimport styles from \"./color-area.css.js\";\nexport class ColorArea extends SpectrumElement {\n  constructor() {\n    super(...arguments);\n    this.disabled = false;\n    this.focused = false;\n    this.labelX = \"saturation\";\n    this.labelY = \"luminosity\";\n    this.languageResolver = new LanguageResolutionController(this);\n    /**\n     * A controller for managing color interactions within the ColorArea component.\n     *\n     * The `ColorController` is instantiated with the `manageAs` option set to `hsv`\n     * because the ColorArea component is designed to manipulate the saturation (`s`)\n     * and value (`v`) components of the HSV color model along the x and y axes,\n     * respectively. In the HSV color model:\n     *\n     * - The `hue` (h) represents the color type and is typically controlled by a separate input.\n     * - The `saturation` (s) represents the intensity of the color, ranging from 0% (gray) to 100% (full color).\n     * - The `value` (v) represents the brightness of the color, ranging from 0% (black) to 100% (full brightness).\n     *\n     * In the ColorArea component:\n     *\n     * - The x-axis controls the saturation (`s`), allowing users to adjust the intensity of the color.\n     * - The y-axis controls the value (`v`), allowing users to adjust the brightness of the color.\n     *\n     * By managing the color as `hsv`, the ColorController can efficiently handle the changes in saturation and value\n     * as the user interacts with the ColorArea component.\n     *\n     * @private\n     * @type {ColorController}\n     * @memberof ColorArea\n     *\n     * @property {ColorArea} this - The instance of the ColorArea component.\n     * @property {Object} options - Configuration options for the ColorController.\n     * @property {string} options.manageAs - Specifies the color model to manage, in this case 'hsv'.\n     */\n    this.colorController = new ColorController(this, { manageAs: \"hsv\" });\n    this.activeAxis = \"x\";\n    this.step = 0.01;\n    this.altered = 0;\n    this.activeKeys = /* @__PURE__ */ new Set();\n    this._valueChanged = false;\n    this._pointerDown = false;\n  }\n  static get styles() {\n    return [styles];\n  }\n  get hue() {\n    return this.colorController.hue;\n  }\n  set hue(value) {\n    this.colorController.hue = value;\n  }\n  get value() {\n    return this.colorController.colorValue;\n  }\n  get color() {\n    return this.colorController.colorValue;\n  }\n  set color(color) {\n    this.colorController.color = color;\n  }\n  get x() {\n    return this.colorController.color.hsv.s / 100;\n  }\n  set x(x) {\n    if (x === this.x) {\n      return;\n    }\n    const oldValue = this.x;\n    if (this.inputX) {\n      this.inputX.value = x.toString();\n      this.colorController.color.set(\n        \"s\",\n        this.inputX.valueAsNumber * 100\n      );\n    } else {\n      this.colorController.color.set(\"s\", x * 100);\n    }\n    this.requestUpdate(\"x\", oldValue);\n  }\n  get y() {\n    return this.colorController.color.hsv.v / 100;\n  }\n  set y(y) {\n    if (y === this.y) {\n      return;\n    }\n    const oldValue = this.y;\n    if (this.inputY) {\n      this.inputY.value = y.toString();\n      this.colorController.color.set(\n        \"v\",\n        this.inputY.valueAsNumber * 100\n      );\n    }\n    this.requestUpdate(\"y\", oldValue);\n  }\n  focus(focusOptions = {}) {\n    super.focus(focusOptions);\n    this.forwardFocus();\n  }\n  forwardFocus() {\n    this.focused = this.hasVisibleFocusInTree();\n    if (this.activeAxis === \"x\") {\n      this.inputX.focus();\n    } else {\n      this.inputY.focus();\n    }\n  }\n  handleFocus() {\n    this.focused = true;\n    this._valueChanged = false;\n  }\n  handleBlur() {\n    if (this._pointerDown) {\n      return;\n    }\n    this.altered = 0;\n    this.focused = false;\n    this._valueChanged = false;\n  }\n  handleKeydown(event) {\n    const { code } = event;\n    this.focused = true;\n    this.altered = [event.shiftKey, event.ctrlKey, event.altKey].filter(\n      (key) => !!key\n    ).length;\n    const isArrowKey = code.search(\"Arrow\") === 0 || code.search(\"Page\") === 0 || code.search(\"Home\") === 0 || code.search(\"End\") === 0;\n    if (isArrowKey) {\n      event.preventDefault();\n      this.activeKeys.add(code);\n      this.handleKeypress();\n    }\n  }\n  handleKeypress() {\n    let deltaX = 0;\n    let deltaY = 0;\n    const step = Math.max(this.step, this.altered * 5 * this.step);\n    this.activeKeys.forEach((code) => {\n      switch (code) {\n        case \"ArrowUp\":\n          deltaY = step;\n          break;\n        case \"ArrowDown\":\n          deltaY = step * -1;\n          break;\n        case \"ArrowLeft\":\n          deltaX = this.step * (this.isLTR ? -1 : 1);\n          break;\n        case \"ArrowRight\":\n          deltaX = this.step * (this.isLTR ? 1 : -1);\n          break;\n        case \"PageUp\":\n          deltaY = step * 10;\n          break;\n        case \"PageDown\":\n          deltaY = step * -10;\n          break;\n        case \"Home\":\n          deltaX = step * (this.isLTR ? -10 : 10);\n          break;\n        case \"End\":\n          deltaX = step * (this.isLTR ? 10 : -10);\n          break;\n        default:\n          break;\n      }\n    });\n    if (deltaX != 0) {\n      this.activeAxis = \"x\";\n      this.inputX.focus();\n    } else if (deltaY != 0) {\n      this.activeAxis = \"y\";\n      this.inputY.focus();\n    }\n    this.x = Math.min(1, Math.max(this.x + deltaX, 0));\n    this.y = Math.min(1, Math.max(this.y + deltaY, 0));\n    this.colorController.savePreviousColor();\n    if (deltaX != 0 || deltaY != 0) {\n      this._valueChanged = true;\n      this.dispatchEvent(\n        new Event(\"input\", {\n          bubbles: true,\n          composed: true\n        })\n      );\n      const applyDefault = this.dispatchEvent(\n        new Event(\"change\", {\n          bubbles: true,\n          composed: true,\n          cancelable: true\n        })\n      );\n      if (!applyDefault) {\n        this.colorController.restorePreviousColor();\n      }\n    }\n  }\n  handleKeyup(event) {\n    event.preventDefault();\n    const { code } = event;\n    this.activeKeys.delete(code);\n  }\n  handleInput(event) {\n    const { valueAsNumber, name } = event.target;\n    this[name] = valueAsNumber;\n  }\n  handleChange(event) {\n    this.handleInput(event);\n    this.dispatchEvent(\n      new Event(\"change\", {\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      })\n    );\n  }\n  handlePointerdown(event) {\n    if (event.button !== 0) {\n      event.preventDefault();\n      return;\n    }\n    this._pointerDown = true;\n    this.colorController.savePreviousColor();\n    this.boundingClientRect = this.getBoundingClientRect();\n    event.target.setPointerCapture(event.pointerId);\n    if (event.pointerType === \"mouse\") {\n      this.focused = true;\n    }\n  }\n  handlePointermove(event) {\n    const [x, y] = this.calculateHandlePosition(event);\n    this._valueChanged = false;\n    this.x = x;\n    this.y = y;\n    this.dispatchEvent(\n      new Event(\"input\", {\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      })\n    );\n  }\n  handlePointerup(event) {\n    event.preventDefault();\n    this._pointerDown = false;\n    event.target.releasePointerCapture(event.pointerId);\n    const applyDefault = this.dispatchEvent(\n      new Event(\"change\", {\n        bubbles: true,\n        composed: true,\n        cancelable: true\n      })\n    );\n    this.inputX.focus();\n    if (event.pointerType === \"mouse\") {\n      this.focused = false;\n    }\n    if (!applyDefault) {\n      this.colorController.restorePreviousColor();\n    }\n  }\n  /**\n   * Returns the value under the cursor\n   * @param: PointerEvent on slider\n   * @return: Slider value that correlates to the position under the pointer\n   */\n  calculateHandlePosition(event) {\n    if (!this.boundingClientRect) {\n      return [this.x, this.y];\n    }\n    const rect = this.boundingClientRect;\n    const minOffsetX = rect.left;\n    const minOffsetY = rect.top;\n    const offsetX = event.clientX;\n    const offsetY = event.clientY;\n    const width = rect.width;\n    const height = rect.height;\n    const percentX = Math.max(\n      0,\n      Math.min(1, (offsetX - minOffsetX) / width)\n    );\n    const percentY = Math.max(\n      0,\n      Math.min(1, (offsetY - minOffsetY) / height)\n    );\n    return [this.isLTR ? percentX : 1 - percentX, 1 - percentY];\n  }\n  handleAreaPointerdown(event) {\n    if (event.button !== 0) {\n      return;\n    }\n    event.stopPropagation();\n    event.preventDefault();\n    this.handle.dispatchEvent(new PointerEvent(\"pointerdown\", event));\n    this.handlePointermove(event);\n  }\n  render() {\n    const { width = 0, height = 0 } = this.boundingClientRect || {};\n    const isMobile = isAndroid() || isIOS();\n    const defaultAriaLabel = \"Color Picker\";\n    const ariaLabel = defaultAriaLabel;\n    const ariaRoleDescription = ifDefined(\n      isMobile ? void 0 : \"2d slider\"\n    );\n    const ariaLabelX = this.labelX;\n    const ariaLabelY = this.labelY;\n    const ariaValueX = new Intl.NumberFormat(\n      this.languageResolver.language,\n      {\n        style: \"percent\",\n        unitDisplay: \"narrow\"\n      }\n    ).format(this.x);\n    const ariaValueY = new Intl.NumberFormat(\n      this.languageResolver.language,\n      {\n        style: \"percent\",\n        unitDisplay: \"narrow\"\n      }\n    ).format(this.y);\n    const style = {\n      background: `linear-gradient(to top, black 0%, hsla(${this.hue}, 100%, 0.01%, 0) 100%),linear-gradient(to right, white 0%, hsla(${this.hue}, 100%, 0.01%, 0) 100%), hsl(${this.hue}, 100%, 50%);`\n    };\n    return html`\n            <div\n                @pointerdown=${this.handleAreaPointerdown}\n                class=\"gradient\"\n                style=\"background: ${style.background};\"\n            >\n                <slot name=\"gradient\"></slot>\n            </div>\n\n            <sp-color-handle\n                tabindex=${ifDefined(this.focused ? void 0 : \"0\")}\n                @focus=${this.forwardFocus}\n                ?focused=${this.focused}\n                class=\"handle\"\n                color=${this.colorController.getHslString()}\n                ?disabled=${this.disabled}\n                style=${`transform: translate(${(this.isLTR ? this.x : 1 - this.x) * width}px, ${height - this.y * height}px);`}\n                ${streamingListener({\n      start: [\"pointerdown\", this.handlePointerdown],\n      streamInside: [\"pointermove\", this.handlePointermove],\n      end: [\n        [\"pointerup\", \"pointercancel\", \"pointerleave\"],\n        this.handlePointerup\n      ]\n    })}\n            ></sp-color-handle>\n\n            <fieldset\n                class=\"fieldset\"\n                aria-label=${ifDefined(isMobile ? ariaLabel : void 0)}\n            >\n                <div role=\"presentation\">\n                    <input\n                        type=\"range\"\n                        class=\"slider\"\n                        name=\"x\"\n                        aria-label=${isMobile ? ariaLabelX : `${ariaLabelX} ${ariaLabel}`}\n                        aria-roledescription=${ariaRoleDescription}\n                        aria-orientation=\"horizontal\"\n                        aria-valuetext=${isMobile ? ariaValueX : `${ariaValueX}, ${ariaLabelX}${this._valueChanged ? \"\" : `, ${ariaValueY}, ${ariaLabelY}`}`}\n                        min=\"0\"\n                        max=\"1\"\n                        step=${this.step}\n                        tabindex=\"-1\"\n                        .value=${String(this.x)}\n                        @input=${this.handleInput}\n                        @change=${this.handleChange}\n                    />\n                </div>\n                <div role=\"presentation\">\n                    <input\n                        type=\"range\"\n                        class=\"slider\"\n                        name=\"y\"\n                        aria-label=${isMobile ? ariaLabelY : `${ariaLabelY} ${ariaLabel}`}\n                        aria-roledescription=${ariaRoleDescription}\n                        aria-orientation=\"vertical\"\n                        aria-valuetext=${isMobile ? ariaValueY : `${ariaValueY}, ${ariaLabelY}${this._valueChanged ? \"\" : `, ${ariaValueX}, ${ariaLabelX}`}`}\n                        orient=\"vertical\"\n                        min=\"0\"\n                        max=\"1\"\n                        step=${this.step}\n                        tabindex=\"-1\"\n                        .value=${String(this.y)}\n                        @input=${this.handleInput}\n                        @change=${this.handleChange}\n                    />\n                </div>\n            </fieldset>\n        `;\n  }\n  firstUpdated(changed) {\n    super.firstUpdated(changed);\n    this.boundingClientRect = this.getBoundingClientRect();\n    this.addEventListener(\"focus\", this.handleFocus);\n    this.addEventListener(\"blur\", this.handleBlur);\n    this.addEventListener(\"keyup\", this.handleKeyup);\n    this.addEventListener(\"keydown\", this.handleKeydown);\n  }\n  /**\n   * Overrides the `updated` method to handle changes in property values.\n   *\n   * @param changed - A map of changed properties with their previous values.\n   *\n   * This method performs the following actions:\n   * - Updates the saturation (`s`) of the color if `x` has changed.\n   * - Updates the value (`v`) of the color if `y` has changed.\n   * - If the `focused` property has changed and is now true, it lazily binds\n   *   the `input[type=\"range\"]` elements in shadow roots to prevent multiple\n   *   tab stops within the Color Area for certain browser settings (e.g., Webkit).\n   */\n  updated(changed) {\n    super.updated(changed);\n    if (this.x !== this.inputX.valueAsNumber) {\n      this.colorController.color.set(\n        \"s\",\n        this.inputX.valueAsNumber * 100\n      );\n    }\n    if (this.y !== this.inputY.valueAsNumber) {\n      this.colorController.color.set(\n        \"v\",\n        (1 - this.inputY.valueAsNumber) * 100\n      );\n    }\n    if (changed.has(\"focused\") && this.focused) {\n      const parentX = this.inputX.parentElement;\n      const parentY = this.inputY.parentElement;\n      if (!parentX.shadowRoot && !parentY.shadowRoot) {\n        parentX.attachShadow({ mode: \"open\" });\n        parentY.attachShadow({ mode: \"open\" });\n        const slot = '<div tabindex=\"-1\"><slot></slot></div>';\n        parentX.shadowRoot.innerHTML = slot;\n        parentY.shadowRoot.innerHTML = slot;\n      }\n    }\n  }\n  connectedCallback() {\n    var _a;\n    super.connectedCallback();\n    if (!this.observer && window.ResizeObserver) {\n      this.observer = new window.ResizeObserver((entries) => {\n        for (const entry of entries) {\n          this.boundingClientRect = entry.contentRect;\n        }\n        this.requestUpdate();\n      });\n    }\n    (_a = this.observer) == null ? void 0 : _a.observe(this);\n  }\n  disconnectedCallback() {\n    var _a;\n    (_a = this.observer) == null ? void 0 : _a.unobserve(this);\n    super.disconnectedCallback();\n  }\n}\n__decorateClass([\n  property({ type: String, reflect: true })\n], ColorArea.prototype, \"dir\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ColorArea.prototype, \"disabled\", 2);\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], ColorArea.prototype, \"focused\", 2);\n__decorateClass([\n  property({ type: String, attribute: \"label-x\" })\n], ColorArea.prototype, \"labelX\", 2);\n__decorateClass([\n  property({ type: String, attribute: \"label-y\" })\n], ColorArea.prototype, \"labelY\", 2);\n__decorateClass([\n  query(\".handle\")\n], ColorArea.prototype, \"handle\", 2);\n__decorateClass([\n  property({ type: Number })\n], ColorArea.prototype, \"hue\", 1);\n__decorateClass([\n  property({ type: String })\n], ColorArea.prototype, \"value\", 1);\n__decorateClass([\n  property({ type: String })\n], ColorArea.prototype, \"color\", 1);\n__decorateClass([\n  property({ attribute: false })\n], ColorArea.prototype, \"activeAxis\", 2);\n__decorateClass([\n  property({ type: Number })\n], ColorArea.prototype, \"x\", 1);\n__decorateClass([\n  property({ type: Number })\n], ColorArea.prototype, \"y\", 1);\n__decorateClass([\n  property({ type: Number })\n], ColorArea.prototype, \"step\", 2);\n__decorateClass([\n  query('[name=\"x\"]')\n], ColorArea.prototype, \"inputX\", 2);\n__decorateClass([\n  query('[name=\"y\"]')\n], ColorArea.prototype, \"inputY\", 2);\n//# sourceMappingURL=ColorArea.dev.js.map\n","\"use strict\";\nimport { html } from \"@spectrum-web-components/base\";\nimport \"@spectrum-web-components/color-slider/sp-color-slider.js\";\nimport \"@spectrum-web-components/color-area/sp-color-area.js\";\nexport default {\n  title: \"Color/Area\",\n  component: \"sp-color-area\",\n  argTypes: {\n    onInput: { action: \"input\" },\n    onChange: { action: \"change\" },\n    color: {\n      name: \"color\",\n      type: { name: \"ColorTypes\", required: \"true\" },\n      description: \"The color displayed by the ColorArea.\",\n      table: {\n        type: { summary: \"ColorTypes\" },\n        defaultValue: { summary: \"\" }\n      },\n      control: \"text\"\n    }\n  }\n};\nexport const Default = ({ onChange, onInput }) => {\n  return html`\n        <sp-color-area\n            color=\"#ff0000\"\n            @input=${({ target }) => {\n    const next = target.nextElementSibling;\n    next.textContent = target.color;\n    next.style.color = target.color;\n    onInput(target.value);\n  }}\n            @change=${({ target }) => {\n    onChange(target.value);\n  }}\n        ></sp-color-area>\n        <div style=\"color: #ff0000\" aria-live=\"off\">#ff0000</div>\n    `;\n};\nexport const appliedValues = () => {\n  return html`\n        <sp-color-area\n            .color=${{ space: \"hsv\", coords: [250, 90, 80] }}\n        ></sp-color-area>\n        <sp-color-area color=\"hsv(250, 90%, 80%)\"></sp-color-area>\n        <sp-color-area hue=\"250\" x=\"0.1\" y=\"0.1\"></sp-color-area>\n    `;\n};\nexport const joint = () => {\n  return html`\n        <div>\n            <sp-color-area\n                color=\"hsv (0 100% 100%)\"\n                @input=${({ target }) => {\n    const next = target.nextElementSibling;\n    const display = next.nextElementSibling;\n    display.textContent = target.color;\n    display.style.color = target.color;\n    next.color = target.color;\n  }}\n            ></sp-color-area>\n            <sp-color-slider\n                color=\"hsv(0 100% 100%)\"\n                @input=${({\n    target: {\n      color,\n      previousElementSibling,\n      nextElementSibling\n    }\n  }) => {\n    previousElementSibling.color = color;\n    nextElementSibling.textContent = color;\n    nextElementSibling.style.color = color;\n  }}\n            ></sp-color-slider>\n            <div style=\"color: hsv(0, 100%, 100%)\">hsv(0, 100%, 100%)</div>\n        </div>\n    `;\n};\nexport const disabled = () => {\n  return html`\n        <sp-color-area disabled></sp-color-area>\n    `;\n};\nexport const sized = () => {\n  return html`\n        <sp-color-area style=\"width: 72px; height: 72px\"></sp-color-area>\n    `;\n};\nexport const canvas = () => {\n  return html`\n        <sp-color-area>\n            <canvas slot=\"gradient\"></canvas>\n        </sp-color-area>\n    `;\n};\nclass CanvasWriter extends HTMLElement {\n  constructor() {\n    super();\n    this.writeStatePromise = Promise.resolve(false);\n    this.writeStatePromise = new Promise((res) => {\n      requestAnimationFrame(() => {\n        this.writeToCanvas();\n        res(true);\n      });\n    });\n  }\n  writeToCanvas() {\n    const { previousElementSibling } = this;\n    if (previousElementSibling) {\n      const canvas2 = previousElementSibling.querySelector(\n        'canvas[slot=\"gradient\"]'\n      );\n      if (canvas2) {\n        canvas2.width = canvas2.offsetWidth;\n        canvas2.height = canvas2.offsetHeight;\n        const context = canvas2.getContext(\"2d\");\n        if (context) {\n          context.rect(0, 0, canvas2.width, canvas2.height);\n          const gradB = context.createLinearGradient(\n            0,\n            0,\n            0,\n            canvas2.height\n          );\n          gradB.addColorStop(0, \"white\");\n          gradB.addColorStop(1, \"black\");\n          const gradC = context.createLinearGradient(\n            0,\n            0,\n            canvas2.width,\n            0\n          );\n          gradC.addColorStop(0, \"hsla(0,100%,50%,0)\");\n          gradC.addColorStop(1, \"hsla(0,100%,50%,1)\");\n          context.fillStyle = gradB;\n          context.fillRect(0, 0, canvas2.width, canvas2.height);\n          context.fillStyle = gradC;\n          context.globalCompositeOperation = \"multiply\";\n          context.fillRect(0, 0, canvas2.width, canvas2.height);\n          context.globalCompositeOperation = \"source-over\";\n        }\n      }\n    }\n  }\n  get updateComplete() {\n    return this.writeStatePromise;\n  }\n}\ncustomElements.define(\"area-canvas-writer\", CanvasWriter);\ncanvas.decorators = [\n  (story) => {\n    return html`\n            ${story()}\n            <area-canvas-writer></area-canvas-writer>\n        `;\n  }\n];\n//# sourceMappingURL=color-area.stories.js.map\n;export const __namedExportsOrder = [\"Default\",\"appliedValues\",\"joint\",\"disabled\",\"sized\",\"canvas\"];"],"names":[],"sourceRoot":""}