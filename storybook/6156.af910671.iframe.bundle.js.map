{"version":3,"file":"6156.af910671.iframe.bundle.js","mappings":";;AAEA;;ACDA;;AAwEA;;AAGA;;AA6EA;AACA;AACA;;;;;AAKA;;AAEA;AACA;AACA;;AAGA;;ACtKA","sources":["webpack://@spectrum-web-components/1st-gen/./packages/modal/src/modal.css.js","webpack://@spectrum-web-components/1st-gen/./packages/tray/src/Tray.dev.js","webpack://@spectrum-web-components/1st-gen/./packages/underlay/src/Underlay.dev.js"],"sourcesContent":["\"use strict\";import{css as a}from\"@spectrum-web-components/base\";const i=a`\n    :host{--spectrum-modal-confirm-entry-animation-duration:var(--mod-modal-confirm-entry-animation-duration,var(--spectrum-animation-duration-500));--spectrum-modal-confirm-entry-animation-delay:var(--mod-overlay-animation-duration-opened,var(--mod-modal-confirm-entry-animation-delay,var(--spectrum-animation-duration-200)));--spectrum-modal-confirm-exit-animation-duration:var(--mod-overlay-animation-duration,var(--mod-modal-confirm-exit-animation-duration,var(--spectrum-animation-duration-100)));--spectrum-modal-confirm-exit-animation-delay:var(--mod-modal-confirm-exit-animation-delay,var(--spectrum-animation-duration-0));--spectrum-modal-fullscreen-margin:var(--mod-modal-fullscreen-margin,32px)}.modal{visibility:hidden;opacity:0;transform:translateY(var(--mod-modal-confirm-entry-animation-distance,var(--spectrum-dialog-confirm-entry-animation-distance)));z-index:1;max-block-size:90vh;max-block-size:var(--mod-modal-max-height,90vh);max-inline-size:90%;max-inline-size:var(--mod-modal-max-width,90%);background:var(--mod-modal-background-color,var(--spectrum-modal-background-color));border-radius:var(--mod-modal-confirm-border-radius,var(--spectrum-corner-radius-100));pointer-events:auto;transition:opacity var(--spectrum-modal-confirm-exit-animation-duration)var(--spectrum-animation-ease-in)var(--spectrum-modal-confirm-exit-animation-delay),visibility var(--spectrum-animation-duration-0)var(--spectrum-animation-linear)calc(var(--spectrum-modal-confirm-exit-animation-delay) + var(--spectrum-modal-confirm-exit-animation-duration)),transform var(--spectrum-animation-duration-0)var(--spectrum-animation-linear)calc(var(--spectrum-modal-confirm-exit-animation-delay) + var(--spectrum-modal-confirm-exit-animation-duration));outline:none;overflow:hidden}:host([open]) .modal{pointer-events:auto;visibility:visible;opacity:1;transition:transform var(--spectrum-modal-confirm-entry-animation-duration)var(--spectrum-animation-ease-out)var(--spectrum-modal-confirm-entry-animation-delay),opacity var(--spectrum-modal-confirm-entry-animation-duration)var(--spectrum-animation-ease-out)var(--spectrum-modal-confirm-entry-animation-delay);transform:translateY(0)}@media only screen and (device-height<=350px),only screen and (device-width<=400px){:host([responsive]) .modal{border-radius:0;block-size:100%;max-block-size:100%;inline-size:100%;max-inline-size:100%}}.fullscreen{max-block-size:none;max-inline-size:none;position:fixed;inset-block-start:var(--spectrum-modal-fullscreen-margin);inset-block-end:var(--spectrum-modal-fullscreen-margin);inset-inline-start:var(--spectrum-modal-fullscreen-margin);inset-inline-end:var(--spectrum-modal-fullscreen-margin)}.fullscreenTakeover{box-sizing:border-box;border:none;border-radius:0;max-block-size:none;max-inline-size:none;position:fixed;inset:0}.fullscreenTakeover,:host([open]) .fullscreenTakeover{transform:none}:host{--spectrum-modal-background-color:var(--system-modal-background-color)}:host{--spectrum-dialog-confirm-exit-animation-duration:var(--swc-test-duration);--spectrum-dialog-confirm-entry-animation-duration:var(--swc-test-duration);--spectrum-modal-confirm-entry-animation-distance:var(--spectrum-dialog-confirm-entry-animation-distance);height:100dvh}.modal{overflow:visible}\n`;export default i;\n//# sourceMappingURL=modal.css.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  nothing,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport {\n  property,\n  query,\n  state\n} from \"@spectrum-web-components/base/src/decorators.js\";\nimport \"@spectrum-web-components/underlay/sp-underlay.js\";\nimport { firstFocusableIn } from \"@spectrum-web-components/shared/src/first-focusable-in.js\";\nimport { MatchMediaController } from \"@spectrum-web-components/reactive-controllers/src/MatchMedia.js\";\nimport modalStyles from \"@spectrum-web-components/modal/src/modal.css.js\";\nimport styles from \"./tray.css.js\";\nexport class Tray extends SpectrumElement {\n  constructor() {\n    super(...arguments);\n    this.open = false;\n    this.prefersMotion = new MatchMediaController(\n      this,\n      \"(prefers-reduced-motion: no-preference)\"\n    );\n    this.transitionPromise = Promise.resolve();\n    this.resolveTransitionPromise = () => {\n    };\n    this.animating = false;\n    this.hasKeyboardDismissButton = false;\n    this.needsDismissHelper = true;\n  }\n  static get styles() {\n    return [modalStyles, styles];\n  }\n  focus() {\n    const firstFocusable = firstFocusableIn(this);\n    if (firstFocusable) {\n      firstFocusable.focus();\n    } else if (this.children.length === 1) {\n      this.tray.focus();\n    } else {\n      super.focus();\n    }\n  }\n  overlayWillCloseCallback() {\n    if (!this.open) return this.animating;\n    this.close();\n    return true;\n  }\n  close() {\n    this.open = false;\n    if (!this.prefersMotion.matches) {\n      this.dispatchClosed();\n    }\n  }\n  /**\n   * Returns a visually hidden dismiss button for mobile screen reader accessibility.\n   * This button is placed before and after tray content to allow mobile screen reader\n   * users (particularly VoiceOver on iOS) to easily dismiss the overlay.\n   */\n  get dismissHelper() {\n    return html`\n            <div class=\"visually-hidden\">\n                <button aria-label=\"Dismiss\" @click=${this.close}></button>\n            </div>\n        `;\n  }\n  /**\n   * Check if slotted content has keyboard-accessible dismiss buttons.\n   * Looks for buttons in light DOM and checks for known components with built-in dismiss.\n   */\n  checkForDismissButtons() {\n    if (!this.contentSlot) {\n      this.needsDismissHelper = true;\n      return;\n    }\n    const slottedElements = this.contentSlot.assignedElements({\n      flatten: true\n    });\n    if (slottedElements.length === 0) {\n      this.needsDismissHelper = true;\n      return;\n    }\n    const hasDismissButton = slottedElements.some((element) => {\n      if (element.tagName === \"SP-BUTTON\" || element.tagName === \"SP-CLOSE-BUTTON\" || element.tagName === \"BUTTON\") {\n        return true;\n      }\n      if (element.tagName === \"SP-DIALOG\" && element.hasAttribute(\"dismissable\")) {\n        return true;\n      }\n      if (element.tagName === \"SP-DIALOG-WRAPPER\" && element.hasAttribute(\"dismissable\")) {\n        return true;\n      }\n      const buttons = element.querySelectorAll(\n        \"sp-button, sp-close-button, button\"\n      );\n      if (buttons.length > 0) {\n        return true;\n      }\n      return false;\n    });\n    this.needsDismissHelper = !hasDismissButton;\n  }\n  handleSlotChange() {\n    this.checkForDismissButtons();\n  }\n  dispatchClosed() {\n    this.dispatchEvent(\n      new Event(\"close\", {\n        bubbles: true\n      })\n    );\n  }\n  handleUnderlayTransitionend() {\n    if (!this.open) {\n      this.resolveTransitionPromise();\n      this.dispatchClosed();\n    }\n  }\n  handleTrayTransitionend() {\n    if (this.open) {\n      this.resolveTransitionPromise();\n    }\n  }\n  firstUpdated(changes) {\n    super.firstUpdated(changes);\n    this.checkForDismissButtons();\n  }\n  update(changes) {\n    if (changes.has(\"open\") && changes.get(\"open\") !== void 0 && this.prefersMotion.matches) {\n      this.animating = true;\n      this.transitionPromise = new Promise((res) => {\n        this.resolveTransitionPromise = () => {\n          this.animating = false;\n          res();\n        };\n      });\n    }\n    super.update(changes);\n  }\n  render() {\n    return html`\n            <sp-underlay\n                ?open=${this.open}\n                @close=${this.close}\n                @transitionend=${this.handleUnderlayTransitionend}\n            ></sp-underlay>\n            <div\n                class=\"tray modal\"\n                tabindex=\"-1\"\n                @transitionend=${this.handleTrayTransitionend}\n            >\n                ${!this.hasKeyboardDismissButton && this.needsDismissHelper ? this.dismissHelper : nothing}\n                <slot @slotchange=${this.handleSlotChange}></slot>\n                ${!this.hasKeyboardDismissButton && this.needsDismissHelper ? this.dismissHelper : nothing}\n            </div>\n        `;\n  }\n  /**\n   * Bind the open/close transition into the update complete lifecycle so\n   * that the overlay system can wait for it to be \"visibly ready\" before\n   * attempting to throw focus into the content contained herein. Not\n   * waiting for this can cause small amounts of page scroll to happen\n   * while opening the Tray when focusable content is included: e.g. Menu\n   * elements whose selected Menu Item is not the first Menu Item.\n   */\n  async getUpdateComplete() {\n    const complete = await super.getUpdateComplete();\n    await this.transitionPromise;\n    return complete;\n  }\n}\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Tray.prototype, \"open\", 2);\n__decorateClass([\n  query(\".tray\")\n], Tray.prototype, \"tray\", 2);\n__decorateClass([\n  query(\"slot\")\n], Tray.prototype, \"contentSlot\", 2);\n__decorateClass([\n  property({ type: Boolean, attribute: \"has-keyboard-dismiss\" })\n], Tray.prototype, \"hasKeyboardDismissButton\", 2);\n__decorateClass([\n  state()\n], Tray.prototype, \"needsDismissHelper\", 2);\n//# sourceMappingURL=Tray.dev.js.map\n","\"use strict\";\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (kind ? decorator(target, key, result) : decorator(result)) || result;\n  if (kind && result) __defProp(target, key, result);\n  return result;\n};\nimport {\n  html,\n  SpectrumElement\n} from \"@spectrum-web-components/base\";\nimport { property } from \"@spectrum-web-components/base/src/decorators.js\";\nimport styles from \"./underlay.css.js\";\nexport class Underlay extends SpectrumElement {\n  constructor() {\n    super(...arguments);\n    this.canClick = false;\n    this.open = false;\n  }\n  static get styles() {\n    return [styles];\n  }\n  click() {\n    this.dispatchEvent(new Event(\"close\"));\n  }\n  handlePointerdown() {\n    this.canClick = true;\n  }\n  handlePointerup() {\n    if (this.canClick) {\n      this.click();\n    }\n    this.canClick = false;\n  }\n  render() {\n    return html``;\n  }\n  firstUpdated() {\n    this.addEventListener(\"pointerdown\", this.handlePointerdown);\n    this.addEventListener(\"pointerup\", this.handlePointerup);\n  }\n}\n__decorateClass([\n  property({ type: Boolean, reflect: true })\n], Underlay.prototype, \"open\", 2);\n//# sourceMappingURL=Underlay.dev.js.map\n"],"names":[],"sourceRoot":""}