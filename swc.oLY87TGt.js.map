{"version":3,"file":"swc.dCByQl9u.js","sources":["../../../node_modules/@lit-labs/virtualizer/layouts/shared/SizeCache.js","../../../node_modules/@lit-labs/virtualizer/layouts/flow.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport class SizeCache {\n    constructor(config) {\n        this._map = new Map();\n        this._roundAverageSize = false;\n        this.totalSize = 0;\n        if (config?.roundAverageSize === true) {\n            this._roundAverageSize = true;\n        }\n    }\n    set(index, value) {\n        const prev = this._map.get(index) || 0;\n        this._map.set(index, value);\n        this.totalSize += value - prev;\n    }\n    get averageSize() {\n        if (this._map.size > 0) {\n            const average = this.totalSize / this._map.size;\n            return this._roundAverageSize ? Math.round(average) : average;\n        }\n        return 0;\n    }\n    getSize(index) {\n        return this._map.get(index);\n    }\n    clear() {\n        this._map.clear();\n        this.totalSize = 0;\n    }\n}\n//# sourceMappingURL=SizeCache.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport const flow = (config) => Object.assign({\n    type: FlowLayout,\n}, config);\nfunction leadingMargin(direction) {\n    return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n    return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n    return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n    const m = [a, b].sort();\n    return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n    constructor() {\n        this._childSizeCache = new SizeCache();\n        this._marginSizeCache = new SizeCache();\n        this._metricsCache = new Map();\n    }\n    update(metrics, direction) {\n        const marginsToUpdate = new Set();\n        Object.keys(metrics).forEach((key) => {\n            const k = Number(key);\n            this._metricsCache.set(k, metrics[k]);\n            this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n            marginsToUpdate.add(k);\n            marginsToUpdate.add(k + 1);\n        });\n        for (const k of marginsToUpdate) {\n            const a = this._metricsCache.get(k)?.[leadingMargin(direction)] || 0;\n            const b = this._metricsCache.get(k - 1)?.[trailingMargin(direction)] || 0;\n            this._marginSizeCache.set(k, collapseMargins(a, b));\n        }\n    }\n    get averageChildSize() {\n        return this._childSizeCache.averageSize;\n    }\n    get totalChildSize() {\n        return this._childSizeCache.totalSize;\n    }\n    get averageMarginSize() {\n        return this._marginSizeCache.averageSize;\n    }\n    get totalMarginSize() {\n        return this._marginSizeCache.totalSize;\n    }\n    getLeadingMarginValue(index, direction) {\n        return this._metricsCache.get(index)?.[leadingMargin(direction)] || 0;\n    }\n    getChildSize(index) {\n        return this._childSizeCache.getSize(index);\n    }\n    getMarginSize(index) {\n        return this._marginSizeCache.getSize(index);\n    }\n    clear() {\n        this._childSizeCache.clear();\n        this._marginSizeCache.clear();\n        this._metricsCache.clear();\n    }\n}\nexport class FlowLayout extends BaseLayout {\n    constructor() {\n        super(...arguments);\n        /**\n         * Initial estimate of item size\n         */\n        this._itemSize = { width: 100, height: 100 };\n        /**\n         * Indices of children mapped to their (position and length) in the scrolling\n         * direction. Used to keep track of children that are in range.\n         */\n        this._physicalItems = new Map();\n        /**\n         * Used in tandem with _physicalItems to track children in range across\n         * reflows.\n         */\n        this._newPhysicalItems = new Map();\n        /**\n         * Width and height of children by their index.\n         */\n        this._metricsCache = new MetricsCache();\n        /**\n         * anchorIdx is the anchor around which we reflow. It is designed to allow\n         * jumping to any point of the scroll size. We choose it once and stick with\n         * it until stable. _first and _last are deduced around it.\n         */\n        this._anchorIdx = null;\n        /**\n         * Position in the scrolling direction of the anchor child.\n         */\n        this._anchorPos = null;\n        /**\n         * Whether all children in range were in range during the previous reflow.\n         */\n        this._stable = true;\n        this._measureChildren = true;\n        this._estimate = true;\n    }\n    // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n    // })\n    // constructor(config: Layout1dConfig) {\n    //   super(config);\n    // }\n    get measureChildren() {\n        return this._measureChildren;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n    updateItemSizes(sizes) {\n        this._metricsCache.update(sizes, this.direction);\n        // if (this._nMeasured) {\n        // this._updateItemSize();\n        this._scheduleReflow();\n        // }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    // _updateItemSize() {\n    //   // Keep integer values.\n    //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n    // }\n    _getPhysicalItem(idx) {\n        return this._newPhysicalItems.get(idx) ?? this._physicalItems.get(idx);\n    }\n    _getSize(idx) {\n        const item = this._getPhysicalItem(idx);\n        return item && this._metricsCache.getChildSize(idx);\n    }\n    _getAverageSize() {\n        return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n    }\n    _estimatePosition(idx) {\n        const c = this._metricsCache;\n        if (this._first === -1 || this._last === -1) {\n            return (c.averageMarginSize +\n                idx * (c.averageMarginSize + this._getAverageSize()));\n        }\n        else {\n            if (idx < this._first) {\n                const delta = this._first - idx;\n                const refItem = this._getPhysicalItem(this._first);\n                return (refItem.pos -\n                    (c.getMarginSize(this._first - 1) || c.averageMarginSize) -\n                    (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize));\n            }\n            else {\n                const delta = idx - this._last;\n                const refItem = this._getPhysicalItem(this._last);\n                return (refItem.pos +\n                    (c.getChildSize(this._last) || c.averageChildSize) +\n                    (c.getMarginSize(this._last) || c.averageMarginSize) +\n                    delta * (c.averageChildSize + c.averageMarginSize));\n            }\n        }\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n    _getPosition(idx) {\n        const item = this._getPhysicalItem(idx);\n        const { averageMarginSize } = this._metricsCache;\n        return idx === 0\n            ? this._metricsCache.getMarginSize(0) ?? averageMarginSize\n            : item\n                ? item.pos\n                : this._estimatePosition(idx);\n    }\n    _calculateAnchor(lower, upper) {\n        if (lower <= 0) {\n            return 0;\n        }\n        if (upper > this._scrollSize - this._viewDim1) {\n            return this.items.length - 1;\n        }\n        return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n    _getAnchor(lower, upper) {\n        if (this._physicalItems.size === 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._first < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._last < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, lastMin = lastItem.pos, lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n        if (lastMax < lower) {\n            // Window is entirely past physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin > upper) {\n            // Window is entirely before physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        // Window contains a physical item\n        // Find one, starting with the one that was previously first visible\n        let candidateIdx = this._firstVisible - 1;\n        let cMax = -Infinity;\n        while (cMax < lower) {\n            const candidate = this._getPhysicalItem(++candidateIdx);\n            cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n        }\n        return candidateIdx;\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n    _getActiveItems() {\n        if (this._viewDim1 === 0 || this.items.length === 0) {\n            this._clearItems();\n        }\n        else {\n            this._getItems();\n        }\n    }\n    /**\n     * Sets the range to empty.\n     */\n    _clearItems() {\n        this._first = -1;\n        this._last = -1;\n        this._physicalMin = 0;\n        this._physicalMax = 0;\n        const items = this._newPhysicalItems;\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n        this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n    _getItems() {\n        const items = this._newPhysicalItems;\n        this._stable = true;\n        let lower, upper;\n        // The anchorIdx is the anchor around which we reflow. It is designed to\n        // allow jumping to any point of the scroll size. We choose it once and\n        // stick with it until stable. first and last are deduced around it.\n        // If we have a pinned item, we anchor on it\n        if (this.pin !== null) {\n            const { index } = this.pin;\n            this._anchorIdx = index;\n            this._anchorPos = this._getPosition(index);\n        }\n        // Determine the lower and upper bounds of the region to be\n        // rendered, relative to the viewport\n        lower = this._scrollPosition - this._overhang; //leadingOverhang;\n        upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n        if (upper < 0 || lower > this._scrollSize) {\n            this._clearItems();\n            return;\n        }\n        // If we are scrolling to a specific index or if we are doing another\n        // pass to stabilize a previously started reflow, we will already\n        // have an anchor. If not, establish an anchor now.\n        if (this._anchorIdx === null || this._anchorPos === null) {\n            this._anchorIdx = this._getAnchor(lower, upper);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n        }\n        let anchorSize = this._getSize(this._anchorIdx);\n        if (anchorSize === undefined) {\n            this._stable = false;\n            anchorSize = this._getAverageSize();\n        }\n        const anchorLeadingMargin = this._metricsCache.getMarginSize(this._anchorIdx) ??\n            this._metricsCache.averageMarginSize;\n        const anchorTrailingMargin = this._metricsCache.getMarginSize(this._anchorIdx + 1) ??\n            this._metricsCache.averageMarginSize;\n        if (this._anchorIdx === 0) {\n            this._anchorPos = anchorLeadingMargin;\n        }\n        if (this._anchorIdx === this.items.length - 1) {\n            this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n        }\n        // Anchor might be outside bounds, so prefer correcting the error and keep\n        // that anchorIdx.\n        let anchorErr = 0;\n        if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n            anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n        }\n        if (this._anchorPos - anchorLeadingMargin > upper) {\n            anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n        }\n        if (anchorErr) {\n            this._scrollPosition -= anchorErr;\n            lower -= anchorErr;\n            upper -= anchorErr;\n            this._scrollError += anchorErr;\n        }\n        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n        this._first = this._last = this._anchorIdx;\n        this._physicalMin = this._anchorPos - anchorLeadingMargin;\n        this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n        while (this._physicalMin > lower && this._first > 0) {\n            let size = this._getSize(--this._first);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._first);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            this._physicalMin -= size;\n            const pos = this._physicalMin;\n            items.set(this._first, { pos, size });\n            this._physicalMin -= margin;\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n        }\n        while (this._physicalMax < upper && this._last < this.items.length - 1) {\n            let size = this._getSize(++this._last);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._last);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            const pos = this._physicalMax;\n            items.set(this._last, { pos, size });\n            this._physicalMax += size + margin;\n            if (!this._stable && !this._estimate) {\n                break;\n            }\n        }\n        // This handles the cases where we were relying on estimated sizes.\n        const extentErr = this._calculateError();\n        if (extentErr) {\n            this._physicalMin -= extentErr;\n            this._physicalMax -= extentErr;\n            this._anchorPos -= extentErr;\n            this._scrollPosition -= extentErr;\n            items.forEach((item) => (item.pos -= extentErr));\n            this._scrollError += extentErr;\n        }\n        if (this._stable) {\n            this._newPhysicalItems = this._physicalItems;\n            this._newPhysicalItems.clear();\n            this._physicalItems = items;\n        }\n    }\n    _calculateError() {\n        if (this._first === 0) {\n            return this._physicalMin;\n        }\n        else if (this._physicalMin <= 0) {\n            return this._physicalMin - this._first * this._delta;\n        }\n        else if (this._last === this.items.length - 1) {\n            return this._physicalMax - this._scrollSize;\n        }\n        else if (this._physicalMax >= this._scrollSize) {\n            return (this._physicalMax -\n                this._scrollSize +\n                (this.items.length - 1 - this._last) * this._delta);\n        }\n        return 0;\n    }\n    _reflow() {\n        const { _first, _last } = this;\n        super._reflow();\n        if ((this._first === -1 && this._last == -1) ||\n            (this._first === _first && this._last === _last)) {\n            this._resetReflowState();\n        }\n    }\n    _resetReflowState() {\n        this._anchorIdx = null;\n        this._anchorPos = null;\n        this._stable = true;\n    }\n    _updateScrollSize() {\n        const { averageMarginSize } = this._metricsCache;\n        this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) +\n            averageMarginSize);\n    }\n    /**\n     * Returns the average size (precise or estimated) of an item in the scrolling direction,\n     * including any surrounding space.\n     */\n    get _delta() {\n        const { averageMarginSize } = this._metricsCache;\n        return this._getAverageSize() + averageMarginSize;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n    _getItemPosition(idx) {\n        return {\n            [this._positionDim]: this._getPosition(idx),\n            [this._secondaryPositionDim]: 0,\n            [offset(this.direction)]: -(this._metricsCache.getLeadingMarginValue(idx, this.direction) ??\n                this._metricsCache.averageMarginSize),\n        };\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n    _getItemSize(idx) {\n        return {\n            [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n            [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n        };\n    }\n    _viewDim2Changed() {\n        this._metricsCache.clear();\n        this._scheduleReflow();\n    }\n}\n//# sourceMappingURL=flow.js.map"],"names":["SizeCache","constructor","config","this","_map","Map","_roundAverageSize","totalSize","roundAverageSize","set","index","value","prev","get","averageSize","size","average","Math","round","getSize","clear","leadingMargin","direction","trailingMargin","offset","collapseMargins","a","b","m","sort","min","max","MetricsCache","_childSizeCache","_marginSizeCache","_metricsCache","update","metrics","marginsToUpdate","Set","Object","keys","forEach","key","k","Number","dim1","add","averageChildSize","totalChildSize","averageMarginSize","totalMarginSize","getLeadingMarginValue","getChildSize","getMarginSize","FlowLayout","BaseLayout","arguments","_itemSize","width","height","_physicalItems","_newPhysicalItems","_anchorIdx","_anchorPos","_stable","_measureChildren","_estimate","measureChildren","updateItemSizes","sizes","_scheduleReflow","_getPhysicalItem","idx","_getSize","_getAverageSize","_sizeDim","_estimatePosition","c","_first","_last","delta","pos","_getPosition","item","_calculateAnchor","lower","upper","_scrollSize","_viewDim1","items","length","floor","_delta","_getAnchor","firstItem","lastItem","firstMin","candidateIdx","_firstVisible","cMax","Infinity","_getActiveItems","_clearItems","_getItems","_physicalMin","_physicalMax","pin","_scrollPosition","_overhang","anchorSize","undefined","anchorLeadingMargin","anchorTrailingMargin","anchorErr","_scrollError","margin","extentErr","_calculateError","_reflow","super","_resetReflowState","_updateScrollSize","_getItemPosition","_positionDim","_secondaryPositionDim","_getItemSize","_secondarySizeDim","_viewDim2Changed"],"mappings":"mDAUaA,EAKXC,WAAAA,CAAYC,GAJJC,KAAAC,KAAO,IAAIC,IACXF,KAAAG,mBAAoB,EAC5BH,KAAAI,UAAY,GAGuB,IAA7BL,GAAQM,mBACVL,KAAKG,mBAAoB,EAE7B,CAEAG,GAAAA,CAAIC,EAAwBC,GAC1B,MAAMC,EAAOT,KAAKC,KAAKS,IAAIH,IAAU,EACrCP,KAAKC,KAAKK,IAAIC,EAAOC,GACrBR,KAAKI,WAAaI,EAAQC,CAC5B,CAEA,eAAIE,GACF,GAAIX,KAAKC,KAAKW,KAAO,EAAG,CACtB,MAAMC,EAAUb,KAAKI,UAAYJ,KAAKC,KAAKW,KAC3C,YAAYT,kBAAoBW,KAAKC,MAAMF,GAAWA,EAExD,OAAO,CACT,CAEAG,OAAAA,CAAQT,GACN,OAAOP,KAAKC,KAAKS,IAAIH,EACvB,CAEAU,KAAAA,GACEjB,KAAKC,KAAKgB,QACVjB,KAAKI,UAAY,CACnB,ECIF,SAASc,EAAcC,GACrB,MAAqB,eAAdA,EAA6B,aAAe,WACrD,CAEA,SAASC,EAAeD,GACtB,MAAqB,eAAdA,EAA6B,cAAgB,cACtD,CAEA,SAASE,EAAOF,GACd,MAAqB,eAAdA,EAA6B,UAAY,SAClD,CAEA,SAASG,EAAgBC,EAAWC,GAClC,MAAMC,EAAI,CAACF,EAAGC,GAAGE,OACjB,OAAOD,EAAE,IAAM,EAAIX,KAAKa,OAAOF,GAAKA,EAAE,IAAM,EAAIX,KAAKc,OAAOH,GAAKA,EAAE,GAAKA,EAAE,EAC5E,CAEA,MAAMI,EAAN/B,WAAAA,GACUE,KAAA8B,gBAAkB,IAAIjC,EACtBG,KAAA+B,iBAAmB,IAAIlC,EACvBG,KAAAgC,cAAgB,IAAI9B,GAmD9B,CAjDE+B,MAAAA,CAAOC,EAA0Cf,GAC/C,MAAMgB,EAAkB,IAAIC,IAC5BC,OAAOC,KAAKJ,GAASK,SAASC,IAC5B,MAAMC,EAAIC,OAAOF,GACjBxC,KAAKgC,cAAc1B,IAAImC,EAAGP,EAAQO,IAClCzC,KAAK8B,gBAAgBxB,IAAImC,EAAGP,EAAQO,GAAGE,EAAKxB,KAC5CgB,EAAgBS,IAAIH,GACpBN,EAAgBS,IAAIH,EAAI,EAAE,IAE5B,IAAK,MAAMA,KAAKN,EAAiB,CAC/B,MAAMZ,EAAIvB,KAAKgC,cAActB,IAAI+B,KAAKvB,EAAcC,KAAe,EAC7DK,EAAIxB,KAAKgC,cAActB,IAAI+B,EAAI,KAAKrB,EAAeD,KAAe,EACxEnB,KAAK+B,iBAAiBzB,IAAImC,EAAGnB,EAAgBC,EAAGC,IAEpD,CAEA,oBAAIqB,GACF,OAAW7C,KAAC8B,gBAAgBnB,WAC9B,CAEA,kBAAImC,GACF,OAAO9C,KAAK8B,gBAAgB1B,SAC9B,CAEA,qBAAI2C,GACF,OAAO/C,KAAK+B,iBAAiBpB,WAC/B,CAEA,mBAAIqC,GACF,OAAOhD,KAAK+B,iBAAiB3B,SAC/B,CAEA6C,qBAAAA,CAAsB1C,EAAeY,GACnC,OAAWnB,KAACgC,cAActB,IAAIH,KAASW,EAAcC,KAAe,CACtE,CAEA+B,YAAAA,CAAa3C,GACX,OAAWP,KAAC8B,gBAAgBd,QAAQT,EACtC,CAEA4C,aAAAA,CAAc5C,GACZ,OAAWP,KAAC+B,iBAAiBf,QAAQT,EACvC,CAEAU,KAAAA,GACEjB,KAAK8B,gBAAgBb,QACrBjB,KAAK+B,iBAAiBd,QACtBjB,KAAKgC,cAAcf,OACrB,EAGI,MAAOmC,UAAmBC,EAAhCvD,WAAAA,YACEwD,WAGAtD,KAAAuD,UAAkB,CAACC,MAAO,IAAKC,OAAQ,KAMvCzD,KAAA0D,eAAiB,IAAIxD,IAMrBF,KAAA2D,kBAAoB,IAAIzD,IAKxBF,KAAAgC,cAAgB,IAAIH,EAOpB7B,KAAA4D,WAA4B,KAK5B5D,KAAA6D,WAA4B,KAK5B7D,KAAA8D,SAAU,EAEF9D,KAAA+D,kBAAmB,EAE3B/D,KAAAgE,WAAY,CAsYd,CA5XE,mBAAIC,GACF,OAAWjE,KAAC+D,gBACd,CAMAG,eAAAA,CAAgBC,GACdnE,KAAKgC,cAAcC,OAAOkC,EAAyBnE,KAAKmB,WAGxDnB,KAAKoE,iBAEP,CAWAC,gBAAAA,CAAiBC,GACf,OAAWtE,KAAC2D,kBAAkBjD,IAAI4D,IAAQtE,KAAK0D,eAAehD,IAAI4D,EACpE,CAEAC,QAAAA,CAASD,GAEP,OADatE,KAAKqE,iBAAiBC,IACpBtE,KAAKgC,cAAckB,aAAaoB,EACjD,CAEAE,eAAAA,GACE,OAAOxE,KAAKgC,cAAca,kBAAoB7C,KAAKuD,UAAUvD,KAAKyE,SACpE,CAEAC,iBAAAA,CAAkBJ,GAChB,MAAMK,EAAI3E,KAAKgC,cACf,IAAqB,IAAjBhC,KAAK4E,SAAiC,IAAhB5E,KAAK6E,MAC7B,OACEF,EAAE5B,kBACFuB,GAAOK,EAAE5B,kBAAoB/C,KAAKwE,mBAGpC,GAAIF,EAAMtE,KAAK4E,OAAQ,CACrB,MAAME,EAAQ9E,KAAK4E,OAASN,EAE5B,OADgBtE,KAAKqE,iBAAiBrE,KAAK4E,QAEhCG,KACRJ,EAAExB,cAAcnD,KAAK4E,OAAS,IAAMD,EAAE5B,oBACtC+B,EAAQH,EAAE9B,kBAAoBiC,EAAQ,GAAKH,EAAE5B,mBAE3C,CACL,MAAM+B,EAAQR,EAAMtE,KAAK6E,MAEzB,OADgB7E,KAAKqE,iBAAiBrE,KAAK6E,OAEhCE,KACRJ,EAAEzB,aAAalD,KAAK6E,QAAUF,EAAE9B,mBAChC8B,EAAExB,cAAcnD,KAAK6E,QAAUF,EAAE5B,mBAClC+B,GAASH,EAAE9B,iBAAmB8B,EAAE5B,mBAIxC,CAMAiC,YAAAA,CAAaV,GACX,MAAMW,EAAOjF,KAAKqE,iBAAiBC,IAC7BvB,kBAACA,GAAqB/C,KAAKgC,cACjC,OAAe,IAARsC,EACHtE,KAAKgC,cAAcmB,cAAc,IAAMJ,EACvCkC,EACAA,EAAKF,IACL/E,KAAK0E,kBAAkBJ,EAC7B,CAEAY,gBAAAA,CAAiBC,EAAeC,GAC9B,OAAID,GAAS,EACJ,EAELC,EAAQpF,KAAKqF,YAAcrF,KAAKsF,UAC3BtF,KAAKuF,MAAMC,OAAS,EAEtB1E,KAAKc,IACV,EACAd,KAAKa,IACH3B,KAAKuF,MAAMC,OAAS,EACpB1E,KAAK2E,OAAON,EAAQC,GAAS,EAAIpF,KAAK0F,SAG5C,CAEAC,UAAAA,CAAWR,EAAeC,GACxB,GAAiC,IAA7BpF,KAAK0D,eAAe9C,KACtB,OAAWZ,KAACkF,iBAAiBC,EAAOC,GAEtC,GAAIpF,KAAK4E,OAAS,EAChB,OAAO5E,KAAKkF,iBAAiBC,EAAOC,GAEtC,GAAIpF,KAAK6E,MAAQ,EACf,OAAW7E,KAACkF,iBAAiBC,EAAOC,GAGtC,MAAMQ,EAAY5F,KAAKqE,iBAAiBrE,KAAK4E,QAC3CiB,EAAW7F,KAAKqE,iBAAiBrE,KAAK6E,OACtCiB,EAAWF,EAAWb,IAIxB,GAHYc,EAAUd,IACA/E,KAAKgC,cAAckB,aAAalD,KAAK6E,OAE7CM,EAEZ,OAAWnF,KAACkF,iBAAiBC,EAAOC,GAEtC,GAAIU,EAAWV,EAEb,OAAOpF,KAAKkF,iBAAiBC,EAAOC,GAItC,IAAIW,EAAe/F,KAAKgG,cAAgB,EACpCC,GAAQC,IACZ,KAAOD,EAAOd,GAAO,CAEnBc,EADkBjG,KAAKqE,mBAAmB0B,GACxBhB,IAAM/E,KAAKgC,cAAckB,aAAa6C,GAE1D,OAAOA,CACT,CAMAI,eAAAA,GACyB,IAAnBnG,KAAKsF,WAAyC,IAAtBtF,KAAKuF,MAAMC,OACrCxF,KAAKoG,cAELpG,KAAKqG,WAET,CAKAD,WAAAA,GACEpG,KAAK4E,QAAU,EACf5E,KAAK6E,OAAS,EACd7E,KAAKsG,aAAe,EACpBtG,KAAKuG,aAAe,EACpB,MAAMhB,EAAQvF,KAAK2D,kBACnB3D,KAAK2D,kBAAoB3D,KAAK0D,eAC9B1D,KAAK2D,kBAAkB1C,QACvBjB,KAAK0D,eAAiB6B,EACtBvF,KAAK8D,SAAU,CACjB,CAKAuC,SAAAA,GACE,MAAMd,EAAQvF,KAAK2D,kBAEnB,IAAIwB,EAAOC,EAOX,GARApF,KAAK8D,SAAU,EAQE,OAAb9D,KAAKwG,IAAc,CACrB,MAAMjG,MAACA,GAASP,KAAKwG,IACrBxG,KAAK4D,WAAarD,EAClBP,KAAK6D,WAAa7D,KAAKgF,aAAazE,GAQtC,GAHA4E,EAAQnF,KAAKyG,gBAAkBzG,KAAK0G,UACpCtB,EAAQpF,KAAKyG,gBAAkBzG,KAAKsF,UAAYtF,KAAK0G,UAEjDtB,EAAQ,GAAKD,EAAQnF,KAAKqF,YAE5B,YADArF,KAAKoG,cAOiB,OAApBpG,KAAK4D,YAA2C,OAApB5D,KAAK6D,aACnC7D,KAAK4D,WAAa5D,KAAK2F,WAAWR,EAAOC,GACzCpF,KAAK6D,WAAa7D,KAAKgF,aAAahF,KAAK4D,aAG3C,IAAI+C,EAAa3G,KAAKuE,SAASvE,KAAK4D,iBACjBgD,IAAfD,IACF3G,KAAK8D,SAAU,EACf6C,EAAa3G,KAAKwE,mBAGpB,MAAMqC,EACJ7G,KAAKgC,cAAcmB,cAAcnD,KAAK4D,aACtC5D,KAAKgC,cAAce,kBACf+D,EACJ9G,KAAKgC,cAAcmB,cAAcnD,KAAK4D,WAAa,IACnD5D,KAAKgC,cAAce,kBAEG,IAApB/C,KAAK4D,aACP5D,KAAK6D,WAAagD,GAGhB7G,KAAK4D,aAAe5D,KAAKuF,MAAMC,OAAS,IAC1CxF,KAAK6D,WAAa7D,KAAKqF,YAAcyB,EAAuBH,GAK9D,IAAII,EAAY,EAuBhB,IArBI/G,KAAK6D,WAAa8C,EAAaG,EAAuB3B,IACxD4B,EAAY5B,GAASnF,KAAK6D,WAAa8C,EAAaG,IAGlD9G,KAAK6D,WAAagD,EAAsBzB,IAC1C2B,EAAY3B,GAASpF,KAAK6D,WAAagD,IAGrCE,IACF/G,KAAKyG,iBAAmBM,EACxB5B,GAAS4B,EACT3B,GAAS2B,EACT/G,KAAKgH,cAAgBD,GAGvBxB,EAAMjF,IAAIN,KAAK4D,WAAY,CAACmB,IAAK/E,KAAK6D,WAAYjD,KAAM+F,IAExD3G,KAAK4E,OAAS5E,KAAK6E,MAAQ7E,KAAK4D,WAChC5D,KAAKsG,aAAetG,KAAK6D,WAAagD,EACtC7G,KAAKuG,aAAevG,KAAK6D,WAAa8C,EAAaG,EAE5C9G,KAAKsG,aAAenB,GAASnF,KAAK4E,OAAS,GAAG,CACnD,IAAIhE,EAAOZ,KAAKuE,WAAWvE,KAAK4E,aACnBgC,IAAThG,IACFZ,KAAK8D,SAAU,EACflD,EAAOZ,KAAKwE,mBAEd,IAAIyC,EAASjH,KAAKgC,cAAcmB,cAAcnD,KAAK4E,aACpCgC,IAAXK,IACFjH,KAAK8D,SAAU,EACfmD,EAASjH,KAAKgC,cAAce,mBAE9B/C,KAAKsG,cAAgB1F,EACrB,MAAMmE,EAAM/E,KAAKsG,aAGjB,GAFAf,EAAMjF,IAAIN,KAAK4E,OAAQ,CAACG,MAAKnE,SAC7BZ,KAAKsG,cAAgBW,GACA,IAAjBjH,KAAK8D,UAAwC,IAAnB9D,KAAKgE,UACjC,KAIJ,CAAA,KAAOhE,KAAKuG,aAAenB,GAASpF,KAAK6E,MAAQ7E,KAAKuF,MAAMC,OAAS,GAAG,CACtE,IAAI5E,EAAOZ,KAAKuE,WAAWvE,KAAK6E,YACnB+B,IAAThG,IACFZ,KAAK8D,SAAU,EACflD,EAAOZ,KAAKwE,mBAEd,IAAIyC,EAASjH,KAAKgC,cAAcmB,cAAcnD,KAAK6E,YACpC+B,IAAXK,IACFjH,KAAK8D,SAAU,EACfmD,EAASjH,KAAKgC,cAAce,mBAE9B,MAAMgC,EAAM/E,KAAKuG,aAGjB,GAFAhB,EAAMjF,IAAIN,KAAK6E,MAAO,CAACE,MAAKnE,SAC5BZ,KAAKuG,cAAgB3F,EAAOqG,GACvBjH,KAAK8D,UAAY9D,KAAKgE,UACzB,KAIJ,CACA,MAAMkD,EAAYlH,KAAKmH,kBACnBD,IACFlH,KAAKsG,cAAgBY,EACrBlH,KAAKuG,cAAgBW,EACrBlH,KAAK6D,YAAcqD,EACnBlH,KAAKyG,iBAAmBS,EACxB3B,EAAMhD,SAAS0C,GAAUA,EAAKF,KAAOmC,IACrClH,KAAKgH,cAAgBE,GAGnBlH,KAAK8D,UACP9D,KAAK2D,kBAAoB3D,KAAK0D,eAC9B1D,KAAK2D,kBAAkB1C,QACvBjB,KAAK0D,eAAiB6B,EAE1B,CAEA4B,eAAAA,GACE,OAAoB,IAAhBnH,KAAK4E,OACA5E,KAAKsG,aACHtG,KAAKsG,cAAgB,EACvBtG,KAAKsG,aAAetG,KAAK4E,OAAS5E,KAAK0F,OACrC1F,KAAK6E,QAAU7E,KAAKuF,MAAMC,OAAS,EACrCxF,KAAKuG,aAAevG,KAAKqF,YACvBrF,KAAKuG,cAAgBvG,KAAKqF,YAEjCrF,KAAKuG,aACLvG,KAAKqF,aACJrF,KAAKuF,MAAMC,OAAS,EAAIxF,KAAK6E,OAAS7E,KAAK0F,OAGzC,CACT,CAES0B,OAAAA,GACP,MAAMxC,OAACA,EAAMC,MAAEA,GAAS7E,KACxBqH,MAAMD,YAEc,IAAjBpH,KAAK4E,SAAgC,GAAf5E,KAAK6E,OAC3B7E,KAAK4E,SAAWA,GAAU5E,KAAK6E,QAAUA,IAE1C7E,KAAKsH,mBAET,CAEAA,iBAAAA,GACEtH,KAAK4D,WAAa,KAClB5D,KAAK6D,WAAa,KAClB7D,KAAK8D,SAAU,CACjB,CAEAyD,iBAAAA,GACE,MAAMxE,kBAACA,GAAqB/C,KAAKgC,cACjChC,KAAKqF,YAAcvE,KAAKc,IACtB,EACA5B,KAAKuF,MAAMC,QAAUzC,EAAoB/C,KAAKwE,mBAC5CzB,EAEN,CAMA,UAAc2C,GACZ,MAAM3C,kBAACA,GAAqB/C,KAAKgC,cACjC,OAAWhC,KAACwE,kBAAoBzB,CAClC,CAKAyE,gBAAAA,CAAiBlD,GACf,MAAO,CACL,CAACtE,KAAKyH,cAAezH,KAAKgF,aAAaV,GACvC,CAACtE,KAAK0H,uBAAwB,EAC9B,CAACrG,EAAOrB,KAAKmB,cACXnB,KAAKgC,cAAciB,sBAAsBqB,EAAKtE,KAAKmB,YACnDnB,KAAKgC,cAAce,mBAGzB,CAKA4E,YAAAA,CAAarD,GACX,MAAO,CACL,CAACtE,KAAKyE,UAAWzE,KAAKuE,SAASD,IAAQtE,KAAKwE,kBAC5C,CAACxE,KAAK4H,mBAAoB5H,KAAKuD,UAAUvD,KAAK4H,mBAElD,CAEAC,gBAAAA,GACE7H,KAAKgC,cAAcf,QACnBjB,KAAKoE,iBACP","x_google_ignoreList":[0,1]}