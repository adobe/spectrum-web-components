{
  "version": 3,
  "sources": ["test.ts"],
  "sourcesContent": ["/*\nCopyright 2020 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\n/**\n * Visual Regression Test Framework for Spectrum Web Components\n *\n * This file provides utilities to run visual regression tests across multiple\n * themes, scales, and directions. It renders components in various states and\n * compares them against baseline screenshots.\n */\n\nimport {\n    elementUpdated,\n    fixture,\n    nextFrame,\n    waitUntil,\n} from '@open-wc/testing';\nimport { html, TemplateResult } from '@spectrum-web-components/base';\nimport { StoryDecorator } from '@spectrum-web-components/story-decorator';\nimport '@spectrum-web-components/story-decorator/sp-story-decorator.js';\nimport { Color, Scale } from '@spectrum-web-components/theme';\nimport { emulateMedia, sendKeys } from '@web/test-runner-commands';\nimport { visualDiff } from '@web/test-runner-visual-regression';\nimport { render } from 'lit';\nimport { ignoreResizeObserverLoopError } from '../testing-helpers.js';\n\n// Suppress ResizeObserver errors which can occur during testing\nignoreResizeObserverLoopError(before, after);\n\n/**\n * Creates a story decorator element to wrap component tests\n * This provides a consistent container for all visual tests\n */\nconst wrap = () => html`\n    <sp-story-decorator\n        reduce-motion\n        screenshot\n        tabindex=\"0\"\n    ></sp-story-decorator>\n`;\n\n/**\n * Interface for story functions that render components with specific props\n * Similar to Storybook story format\n */\ninterface Story<T> {\n    (args: T): TemplateResult;\n    args?: Partial<T>;\n    argTypes?: Record<string, unknown>;\n    decorators?: (() => TemplateResult)[];\n    swc_vrt?: {\n        skip: boolean;\n    };\n}\n\n/**\n * Type representing a collection of related stories for a component\n */\ntype StoriesType = {\n    [name: string]: Story<object>;\n};\n\n/**\n * Extended type that includes default settings and metadata for the test suite\n */\nexport type TestsType = StoriesType & {\n    default: {\n        title: string;\n        swc_vrt?: {\n            preload?: () => void;\n        };\n    };\n};\n\n/**\n * Waits for the story decorator to be ready before taking screenshots\n *\n * @param test - The StoryDecorator instance\n * @param retry - Current retry attempt number\n */\nasync function testReady(test: StoryDecorator, retry = 0): Promise<void> {\n    await waitUntil(\n        () => test.ready,\n        `Wait for decorator to become ready on try number ${retry + 1}`,\n        {\n            timeout: 20000,\n        }\n    );\n}\n\n/**\n * Ensures component rendering is stable before taking screenshots\n * Waits for layout, animations, and pending renders to complete\n *\n * @param root - The root element containing the component under test\n */\nasync function ensureComponentStable(root: Element): Promise<void> {\n    // Force a layout computation\n    root.getBoundingClientRect();\n\n    // First frame to process attribute changes\n    await nextFrame();\n\n    // Wait for all animations to complete\n    try {\n        const animations = root.getAnimations({ subtree: true });\n        if (animations.length > 0) {\n            await Promise.all(\n                animations.map((a) =>\n                    a.finished.catch((error) => {\n                        console.warn('Animation failed:', error);\n                        return undefined;\n                    })\n                )\n            );\n        }\n    } catch (error) {\n        // Ignore errors in animation handling\n        console.warn('Error while waiting for animations', error);\n    }\n\n    // Additional frame to ensure everything is painted\n    await nextFrame();\n}\n\n/**\n * Core test function that runs a single story through visual regression testing\n *\n * @param tests - Collection of stories to test\n * @param name - Name of the component being tested\n * @param color - Theme color (lightest, light, dark, darkest)\n * @param scale - Component scale (medium, large)\n * @param dir - Text direction (ltr, rtl)\n */\nexport const test = (\n    tests: TestsType,\n    name: string,\n    color: Color,\n    scale: Scale,\n    dir: 'ltr' | 'rtl'\n) => {\n    Object.keys(tests).map((story) => {\n        if (story !== 'default' && !tests[story].swc_vrt?.skip) {\n            it(story, async () => {\n                // Create and setup the test fixture\n                let test = await fixture<StoryDecorator>(wrap());\n                await elementUpdated(test);\n                test.focus();\n                await sendKeys({ press: 'ArrowUp' });\n                await sendKeys({ press: 'ArrowDown' });\n\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const testsDefault = (tests as any).default;\n\n                // Merge default args with story-specific args\n                const args = {\n                    ...(testsDefault.args || {}),\n                    ...(tests[story].args || {}),\n                };\n\n                // Combine decorators from both default and story\n                const decorators = [\n                    ...(tests[story].decorators || []),\n                    ...(testsDefault.decorators || []),\n                ];\n\n                // Create the base story render function\n                let decoratedStory: () => TemplateResult = () => html`\n                    ${tests[story](args)}\n                `;\n\n                // Helper to apply decorators to the story\n                const decorate = (\n                    story: () => TemplateResult,\n                    decorator: (\n                        story: () => TemplateResult,\n                        { args }: { args: unknown }\n                    ) => TemplateResult\n                ) => {\n                    return () => decorator(story, { args });\n                };\n\n                // Apply all decorators\n                while (decorators.length) {\n                    const decorator = decorators.shift();\n                    decoratedStory = decorate(decoratedStory, decorator);\n                }\n\n                // Render the story to the test fixture\n                render(decoratedStory(), test);\n                await testReady(test);\n\n                // Ensure component is fully rendered and stable before screenshot\n                await ensureComponentStable(test);\n\n                // Format the test name with all parameters for unique identification\n                const testName = `${color} - ${scale} - ${dir} - ${name} - ${story}`;\n\n                // Implementation of retry logic for flaky visual tests\n                const allowedRetries = 4;\n                let retries = allowedRetries;\n                let passed = false;\n\n                while (retries && !passed) {\n                    retries -= 1;\n                    const retry = allowedRetries - retries;\n                    try {\n                        // Take screenshot and compare with baseline\n                        await visualDiff(test, testName);\n                        passed = true;\n                    } catch (error) {\n                        if (\n                            (error as { message: string }).message &&\n                            (error as { message: string }).message.search(\n                                'There was no baseline image to compare against.'\n                            ) > -1\n                        ) {\n                            retries = 0;\n                            // Don't retry \"no baseline image\" errors.\n                            throw error;\n                        } else {\n                            // For rendering differences, try again with a fresh fixture\n                            test.remove();\n                            /**\n                             * _Sometimes_ the browser will fail on weird renderings of rounded edges.\n                             * This retry allows it another change to render the test from scratch before\n                             * actually failing on this story.\n                             **/\n                            test = await fixture<StoryDecorator>(wrap());\n                            await elementUpdated(test);\n                            render(decoratedStory(), test);\n                            await testReady(test, retry);\n\n                            // Ensure stability before retrying screenshot\n                            await ensureComponentStable(test);\n\n                            // On last try, let the error propagate if it still fails\n                            if (!retries) {\n                                try {\n                                    await visualDiff(test, testName);\n                                } catch (error) {\n                                    // eslint-disable-next-line no-console\n                                    console.log(\n                                        `Tried ${\n                                            allowedRetries - retries\n                                        } times. ${testName}`\n                                    );\n                                    throw error;\n                                }\n                            }\n                        }\n                    }\n                }\n                // Log successful test with retry count\n                // eslint-disable-next-line no-console\n                console.log(\n                    `Tried ${allowedRetries - retries} times. ${testName}`\n                );\n            });\n        }\n    });\n};\n\n/**\n * Main function to run visual regression tests for a component across all\n * supported themes, scales, and directions.\n *\n * @param name - Component name being tested\n * @param stories - Collection of stories to test\n */\nexport const regressVisuals = async (name: string, stories: TestsType) => {\n    describe(`${name} Visual Regressions`, () => {\n        const {\n            defaultColor: color,\n            defaultScale: scale,\n            defaultDirection: dir,\n            hcm,\n        } = window.__swc_hack_knobs__;\n\n        before(async () => {\n            // Run any preload functions defined in the stories\n            if (stories.default?.swc_vrt?.preload) {\n                await stories.default.swc_vrt.preload();\n            }\n\n            // Enable high contrast mode if specified\n            if (hcm) {\n                await emulateMedia({\n                    forcedColors: 'active',\n                    colorScheme: 'dark',\n                });\n            }\n        });\n\n        after(async () => {\n            // Restore normal mode after tests\n            if (hcm) {\n                await emulateMedia({\n                    forcedColors: 'none',\n                    colorScheme: 'no-preference',\n                });\n            }\n        });\n\n        afterEach(() => {\n            // Clean up any remaining overlays after each test\n            const overlays = [\n                ...(document.querySelectorAll('active-overlay') || []),\n            ];\n            overlays.map((overlay) => overlay.remove());\n        });\n\n        // If specific theme parameters provided, only test that combination\n        if (color && scale && dir) {\n            test(stories, name, color, scale, dir);\n        } else {\n            // Otherwise test all combinations\n            const colors: Color[] = ['lightest', 'light', 'dark', 'darkest'];\n            const scales: Scale[] = ['medium', 'large'];\n            const directions: ('ltr' | 'rtl')[] = ['ltr', 'rtl'];\n\n            // Generate tests for every combination of color, scale and direction\n            colors.forEach((color: Color) => {\n                scales.forEach((scale: Scale) => {\n                    directions.forEach((dir) => {\n                        test(stories, name, color, scale, dir);\n                    });\n                });\n            });\n        }\n    });\n};\n"],
  "mappings": "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",
  "names": ["test", "story", "error", "color", "scale", "dir"]
}
