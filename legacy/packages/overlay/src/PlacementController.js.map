{
  "version": 3,
  "sources": ["PlacementController.ts"],
  "sourcesContent": ["/*\nCopyright 2022 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\n\nimport type {\n    ReactiveController,\n    ReactiveElement,\n} from '@spectrum-web-components/base';\nimport {\n    arrow,\n    autoUpdate,\n    computePosition,\n    flip,\n    offset,\n    Placement,\n    shift,\n    size,\n} from '@floating-ui/dom';\nimport type { VirtualTrigger } from './VirtualTrigger.js';\nimport type { OpenableElement } from './overlay-types.js';\nimport type { Overlay } from './Overlay.js';\n\ntype OverlayOptionsV1 = {\n    abortPromise?: Promise<boolean>;\n    delayed?: boolean;\n    offset?: number | [number, number]; // supporting multi-axis\n    placement: Placement;\n    notImmediatelyClosable?: boolean; // rename or place behind other API options\n    receivesFocus?: 'auto';\n    root?: HTMLElement;\n    tipPadding?: number;\n    trigger: HTMLElement | VirtualTrigger;\n    type?: 'modal' | 'page' | 'hint' | 'auto' | 'manual';\n};\n\n/**\n * Rounds a number by the device pixel ratio (DPR).\n *\n * @param {number} [num] - The number to round.\n * @returns {number} The rounded number.\n */\nfunction roundByDPR(num?: number): number {\n    if (typeof num === 'undefined') return 0;\n    const dpr = window.devicePixelRatio || 1;\n    return Math.round(num * dpr) / dpr;\n}\n\n// Minimum distance required between the overlay and the edge of the container.\n// See: https://spectrum.adobe.com/page/popover/#Container-padding\nconst REQUIRED_DISTANCE_TO_EDGE = 8;\n// Minimum height for the overlay.\n// See: https://github.com/adobe/spectrum-web-components/issues/910\nconst MIN_OVERLAY_HEIGHT = 100;\n\n/**\n * Gets fallback placements for the overlay based on the initial placement.\n *\n * @param {Placement} placement - The initial placement of the overlay.\n * @returns {Placement[]} An array of fallback placements.\n */\nconst getFallbackPlacements = (placement: Placement): Placement[] => {\n    const fallbacks: Record<Placement, Placement[]> = {\n        left: ['right', 'bottom', 'top'],\n        'left-start': ['right-start', 'bottom', 'top'],\n        'left-end': ['right-end', 'bottom', 'top'],\n        right: ['left', 'bottom', 'top'],\n        'right-start': ['left-start', 'bottom', 'top'],\n        'right-end': ['left-end', 'bottom', 'top'],\n        top: ['bottom', 'left', 'right'],\n        'top-start': ['bottom-start', 'left', 'right'],\n        'top-end': ['bottom-end', 'left', 'right'],\n        bottom: ['top', 'left', 'right'],\n        'bottom-start': ['top-start', 'left', 'right'],\n        'bottom-end': ['top-end', 'left', 'right'],\n    };\n    return fallbacks[placement] ?? [placement];\n};\n\n/**\n * Symbol used to indicate that the placement has been updated.\n */\nexport const placementUpdatedSymbol = Symbol('placement updated');\n\n/**\n * Controller for managing the placement of an overlay.\n *\n * This class implements the ReactiveController interface and provides methods\n * for managing the positioning and constraints of an overlay element.\n */\nexport class PlacementController implements ReactiveController {\n    /**\n     * Function to clean up resources when the controller is no longer needed.\n     *\n     * @private\n     */\n    private cleanup?: () => void;\n\n    /**\n     * Initial height of the overlay.\n     *\n     * @type {number}\n     */\n    initialHeight?: number;\n\n    /**\n     * Indicates whether the overlay is constrained by available space.\n     *\n     * @type {boolean}\n     */\n    isConstrained?: boolean;\n\n    /**\n     * The host element that uses this controller.\n     *\n     * @private\n     * @type {ReactiveElement & { elements: OpenableElement[] }}\n     */\n    private host!: ReactiveElement & { elements: OpenableElement[] };\n\n    /**\n     * Options for configuring the overlay placement.\n     *\n     * @private\n     * @type {OverlayOptionsV1}\n     */\n    private options!: OverlayOptionsV1;\n\n    /**\n     * A WeakMap to store the original placements of overlay elements.\n     *\n     * @private\n     * @type {WeakMap<HTMLElement, Placement>}\n     */\n    private originalPlacements = new WeakMap<HTMLElement, Placement>();\n\n    /**\n     * The target element for the overlay.\n     *\n     * @private\n     * @type {HTMLElement}\n     */\n    private target!: HTMLElement;\n\n    /**\n     * Creates an instance of the PlacementController.\n     *\n     * @param {ReactiveElement & { elements: OpenableElement[] }} host - The host element that uses this controller.\n     */\n    constructor(host: ReactiveElement & { elements: OpenableElement[] }) {\n        this.host = host;\n        // Add the controller after the MutationObserver has been created in preparation\n        // for the `hostConnected`/`hostDisconnected` callbacks to be run.\n        this.host.addController(this);\n    }\n\n    /**\n     * Places the overlay relative to the target element.\n     *\n     * This method sets up the necessary configurations and event listeners to manage the\n     * positioning and constraints of the overlay element.\n     *\n     * @param {HTMLElement} [target=this.target] - The target element for the overlay.\n     * @param {OverlayOptionsV1} [options=this.options] - The options for configuring the overlay placement.\n     * @returns {Promise<void>} A promise that resolves when the overlay has been placed.\n     */\n    public async placeOverlay(\n        target: HTMLElement = this.target,\n        options: OverlayOptionsV1 = this.options\n    ): Promise<void> {\n        // Set the target and options for the overlay.\n        this.target = target;\n        this.options = options;\n        if (!target || !options) return;\n\n        // Set up auto-update for ancestor resize events.\n        const cleanupAncestorResize = autoUpdate(\n            options.trigger,\n            target,\n            this.closeForAncestorUpdate,\n            {\n                ancestorResize: false,\n                elementResize: false,\n                layoutShift: false,\n            }\n        );\n\n        // Set up auto-update for element resize events.\n        const cleanupElementResize = autoUpdate(\n            options.trigger,\n            target,\n            this.updatePlacement,\n            {\n                ancestorScroll: false,\n            }\n        );\n\n        // Define the cleanup function to remove event listeners and reset placements.\n        this.cleanup = () => {\n            this.host.elements?.forEach((element) => {\n                element.addEventListener(\n                    'sp-closed',\n                    () => {\n                        const placement = this.originalPlacements.get(element);\n\n                        if (placement) {\n                            element.setAttribute('placement', placement);\n                        }\n\n                        this.originalPlacements.delete(element);\n                    },\n                    { once: true }\n                );\n            });\n            cleanupAncestorResize();\n            cleanupElementResize();\n        };\n    }\n\n    /**\n     * Flag to allow or disallow placement updates.\n     *\n     * @type {boolean}\n     */\n    public allowPlacementUpdate = false;\n\n    /**\n     * Closes the overlay if an ancestor element is updated.\n     *\n     * This method checks if placement updates are allowed and if the overlay type is not 'modal'.\n     * If these conditions are met and a cleanup function is defined, it dispatches a 'close' event\n     * on the target element to close the overlay.\n     */\n    closeForAncestorUpdate = (): void => {\n        if (\n            !this.allowPlacementUpdate &&\n            this.options.type !== 'modal' &&\n            this.cleanup\n        ) {\n            // Dispatch a 'close' event to close the overlay.\n            this.target.dispatchEvent(new Event('close', { bubbles: true }));\n        }\n\n        // Reset the flag to disallow placement updates.\n        this.allowPlacementUpdate = false;\n    };\n\n    /**\n     * Updates the placement of the overlay.\n     *\n     * This method calls the computePlacement method to recalculate the overlay's position.\n     *\n     * @private\n     */\n    private updatePlacement = (): void => {\n        this.computePlacement();\n    };\n\n    /**\n     * Computes the placement of the overlay relative to the target element.\n     *\n     * This method calculates the necessary positioning and constraints for the overlay element\n     * using various middleware functions. It updates the overlay's style and attributes based\n     * on the computed position.\n     *\n     * @returns {Promise<void>} A promise that resolves when the placement has been computed.\n     */\n    async computePlacement(): Promise<void> {\n        const { options, target } = this;\n\n        // Wait for document fonts to be ready before computing placement.\n        await (document.fonts ? document.fonts.ready : Promise.resolve());\n\n        // Determine the flip middleware based on the type of trigger element.\n        const flipMiddleware = !(options.trigger instanceof HTMLElement)\n            ? flip({\n                  padding: REQUIRED_DISTANCE_TO_EDGE,\n                  fallbackPlacements: getFallbackPlacements(options.placement),\n              })\n            : flip();\n\n        // Extract main axis and cross axis offsets from options.\n        const [mainAxis = 0, crossAxis = 0] = Array.isArray(options?.offset)\n            ? options.offset\n            : [options.offset, 0];\n\n        // Find the tip element within the host elements.\n        const tipElement = this.host.elements.find(\n            (el) => el.tipElement\n        )?.tipElement;\n\n        // Define middleware functions for positioning and constraints.\n        const middleware = [\n            offset({\n                mainAxis,\n                crossAxis,\n            }),\n            shift({ padding: REQUIRED_DISTANCE_TO_EDGE }),\n            flipMiddleware,\n            size({\n                padding: REQUIRED_DISTANCE_TO_EDGE,\n                apply: ({\n                    availableWidth,\n                    availableHeight,\n                    rects: { floating },\n                }) => {\n                    const maxHeight = Math.max(\n                        MIN_OVERLAY_HEIGHT,\n                        Math.floor(availableHeight)\n                    );\n                    const actualHeight = floating.height;\n                    this.initialHeight = !this.isConstrained // && !this.virtualTrigger\n                        ? actualHeight\n                        : this.initialHeight || actualHeight;\n                    this.isConstrained =\n                        actualHeight < this.initialHeight ||\n                        maxHeight <= actualHeight;\n                    const appliedHeight = this.isConstrained\n                        ? `${maxHeight}px`\n                        : '';\n                    Object.assign(target.style, {\n                        maxWidth: `${Math.floor(availableWidth)}px`,\n                        maxHeight: appliedHeight,\n                    });\n                },\n            }),\n            ...(tipElement\n                ? [\n                      arrow({\n                          element: tipElement,\n                          padding:\n                              options.tipPadding || REQUIRED_DISTANCE_TO_EDGE,\n                      }),\n                  ]\n                : []),\n        ];\n\n        // Compute the position of the overlay using the defined middleware.\n        const { x, y, placement, middlewareData } = await computePosition(\n            options.trigger,\n            target,\n            {\n                placement: options.placement,\n                middleware,\n                strategy: 'fixed',\n            }\n        );\n\n        // Update the overlay's style with the computed position.\n        Object.assign(target.style, {\n            top: '0px',\n            left: '0px',\n            translate: `${roundByDPR(x)}px ${roundByDPR(y)}px`,\n        });\n\n        // Set the 'actual-placement' attribute on the target element.\n        target.setAttribute('actual-placement', placement);\n\n        // Update the placement attribute for each host element.\n        this.host.elements?.forEach((element) => {\n            if (!this.originalPlacements.has(element)) {\n                this.originalPlacements.set(\n                    element,\n                    element.getAttribute('placement') as Placement\n                );\n            }\n            element.setAttribute('placement', placement);\n        });\n\n        // Update the tip element's style with the computed arrow position.\n        if (tipElement && middlewareData.arrow) {\n            const { x: arrowX, y: arrowY } = middlewareData.arrow;\n\n            Object.assign(tipElement.style, {\n                top:\n                    placement.startsWith('right') ||\n                    placement.startsWith('left')\n                        ? '0px'\n                        : '',\n                left:\n                    placement.startsWith('bottom') ||\n                    placement.startsWith('top')\n                        ? '0px'\n                        : '',\n                translate: `${roundByDPR(arrowX)}px ${roundByDPR(arrowY)}px`,\n            });\n        }\n    }\n\n    /**\n     * Clears the overlay's position styles.\n     *\n     * This method removes the max-height and max-width styles from the target element,\n     * and resets the initial height and constrained state of the overlay.\n     */\n    public clearOverlayPosition(): void {\n        if (!this.target) {\n            return;\n        }\n        // Remove max-height and max-width styles from the target element.\n        this.target.style.removeProperty('max-height');\n        this.target.style.removeProperty('max-width');\n        // Reset the initial height and constrained state.\n        this.initialHeight = undefined;\n        this.isConstrained = false;\n    }\n\n    /**\n     * Resets the overlay's position.\n     *\n     * This method clears the overlay's position, forces a reflow, and recomputes the placement.\n     */\n    public resetOverlayPosition = (): void => {\n        if (!this.target || !this.options) return;\n        // Clear the overlay's position.\n        this.clearOverlayPosition();\n\n        // Force a reflow.\n        this.host.offsetHeight;\n        // Recompute the placement.\n        this.computePlacement();\n    };\n\n    /**\n     * Lifecycle method called when the host element is connected to the DOM.\n     *\n     * This method sets up an event listener to reset the overlay's position when the 'sp-update-overlays' event is dispatched.\n     */\n    hostConnected(): void {\n        document.addEventListener(\n            'sp-update-overlays',\n            this.resetOverlayPosition\n        );\n    }\n\n    /**\n     * Lifecycle method called when the host element is updated.\n     *\n     * This method cleans up resources if the overlay is not open.\n     */\n    hostUpdated(): void {\n        if (!(this.host as Overlay).open) {\n            // Clean up resources if the overlay is not open.\n            this.cleanup?.();\n            this.cleanup = undefined;\n        }\n    }\n\n    /**\n     * Lifecycle method called when the host element is disconnected from the DOM.\n     *\n     * This method removes the event listener and cleans up resources.\n     */\n    hostDisconnected(): void {\n        // Clean up resources.\n        this.cleanup?.();\n        this.cleanup = undefined;\n        // Remove the event listener.\n        document.removeEventListener(\n            'sp-update-overlays',\n            this.resetOverlayPosition\n        );\n    }\n}\n"],
  "mappings": "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",
  "names": ["arrow", "autoUpdate", "computePosition", "flip", "offset", "shift", "size", "roundByDPR", "num", "dpr", "REQUIRED_DISTANCE_TO_EDGE", "MIN_OVERLAY_HEIGHT", "getFallbackPlacements", "placement", "_a", "host", "target", "options", "cleanupAncestorResize", "cleanupElementResize", "element", "_b", "flipMiddleware", "mainAxis", "crossAxis", "tipElement", "el", "middleware", "availableWidth", "availableHeight", "floating", "maxHeight", "actualHeight", "appliedHeight", "x", "y", "middlewareData", "arrowX", "arrowY"]
}
