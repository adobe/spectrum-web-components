{
  "version": 3,
  "sources": ["HandleController.ts"],
  "sourcesContent": ["/*\nCopyright 2021 Adobe. All rights reserved.\nThis file is licensed to you under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License. You may obtain a copy\nof the License at http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under\nthe License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\nOF ANY KIND, either express or implied. See the License for the specific language\ngoverning permissions and limitations under the License.\n*/\nimport { html, TemplateResult } from '@spectrum-web-components/base';\nimport {\n    classMap,\n    ifDefined,\n    styleMap,\n} from '@spectrum-web-components/base/src/directives.js';\nimport { MutationController } from '@lit-labs/observers/mutation-controller.js';\nimport { Slider } from './Slider.dev.js'\nimport { SliderHandle, SliderNormalization } from './SliderHandle.dev.js'\n\ninterface HandleReference {\n    handle: HTMLElement;\n    input: HTMLInputElement;\n}\n\ninterface HandleComponents extends HandleReference {\n    model: SliderHandle;\n}\n\ninterface RangeAndClamp {\n    range: { min: number; max: number };\n    clamp: { min: number; max: number };\n}\ninterface ModelValue extends RangeAndClamp {\n    name: string;\n    value: number;\n    normalizedValue: number;\n    step: number;\n    highlight: boolean;\n    ariaLabel?: string;\n    normalization: SliderNormalization;\n    handle: SliderHandle;\n}\n\ninterface InputWithModel extends HTMLInputElement {\n    model: ModelValue;\n}\n\ninterface DataFromPointerEvent {\n    resolvedInput: boolean;\n    input: InputWithModel;\n    model?: ModelValue;\n}\n\nexport interface HandleValueDictionary {\n    [key: string]: number;\n}\n\nexport class HandleController {\n    private host!: Slider;\n    private handles: Map<string, SliderHandle> = new Map();\n    private model: ModelValue[] = [];\n    private handleOrder: string[] = [];\n    private draggingHandle?: SliderHandle;\n    private handleRefMap?: WeakMap<SliderHandle, HandleReference>;\n\n    constructor(host: Slider) {\n        this.host = host;\n\n        new MutationController(this.host, {\n            config: {\n                subtree: true,\n                childList: true,\n            },\n            callback: () => {\n                this.extractModelFromLightDom();\n            },\n        });\n\n        this.extractModelFromLightDom();\n    }\n\n    public get values(): HandleValueDictionary {\n        const result: HandleValueDictionary = {};\n        for (const model of this.handles.values()) {\n            result[model.handleName] = model.value;\n        }\n        return result;\n    }\n\n    public get size(): number {\n        return this.handles.size;\n    }\n\n    public inputForHandle(handle: SliderHandle): HTMLInputElement | undefined {\n        if (this.handles.has(handle.handleName)) {\n            const { input } = this.getHandleElements(handle) || {};\n            return input;\n        }\n        /* c8 ignore next 2 */\n        throw new Error(`No input for handle \"${handle.name}\"`);\n    }\n\n    public requestUpdate(): void {\n        if (this.host.hasUpdated) {\n            this.host.requestUpdate();\n        }\n    }\n\n    /**\n     * It is possible for value attributes to be set programmatically. The <input>\n     * for a particular slider needs to have an opportunity to validate any such\n     * values\n     *\n     * @param handle Handle who's value needs validation\n     */\n    public setValueFromHandle(handle: SliderHandle): void {\n        const elements = this.getHandleElements(handle);\n        /* c8 ignore next */\n        if (!elements) return;\n\n        const { input } = elements;\n        if (input.valueAsNumber === handle.value) {\n            if (handle.dragging) {\n                handle.dispatchInputEvent();\n            }\n        } else {\n            input.valueAsNumber = handle.value;\n            this.requestUpdate();\n        }\n        handle.value = input.valueAsNumber;\n    }\n\n    public handleHasChanged(handle: SliderHandle): void {\n        if (handle !== this.host) {\n            this.requestUpdate();\n        }\n    }\n\n    public formattedValueForHandle(model: ModelValue): string {\n        const { handle } = model;\n        const numberFormat = handle.numberFormat ?? this.host.numberFormat;\n        const _forcedUnit =\n            handle._forcedUnit === ''\n                ? this.host._forcedUnit\n                : handle._forcedUnit;\n        return (\n            handle.getAriaHandleText(model.value, numberFormat) + _forcedUnit\n        );\n    }\n\n    public get formattedValues(): Map<string, string> {\n        const result = new Map<string, string>();\n        for (const model of this.model) {\n            result.set(model.name, this.formattedValueForHandle(model));\n        }\n        return result;\n    }\n\n    public get focusElement(): HTMLElement {\n        const { input } = this.getActiveHandleElements();\n        if (\n            !input ||\n            (this.host.editable &&\n                !(input as InputWithModel).model.handle.dragging)\n        ) {\n            return this.host.numberField;\n        }\n        return input;\n    }\n\n    protected handleOrientation = (): void => {\n        this.updateBoundingRect();\n    };\n\n    public hostConnected(): void {\n        if ('orientation' in screen) {\n            screen.orientation.addEventListener(\n                'change',\n                this.handleOrientation\n            );\n        } else {\n            window.addEventListener(\n                'orientationchange',\n                this.handleOrientation\n            );\n        }\n    }\n\n    public hostDisconnected(): void {\n        if ('orientation' in screen) {\n            screen.orientation.removeEventListener(\n                'change',\n                this.handleOrientation\n            );\n        } else {\n            window.removeEventListener(\n                'orientationchange',\n                this.handleOrientation\n            );\n        }\n    }\n\n    public hostUpdate(): void {\n        this.updateModel();\n    }\n\n    // Since extractModelFromLightDom bails on the first un-upgraded handle,\n    // a maximum of one listener will be set up per extraction attempt.\n    private waitForUpgrade(handle: HTMLElement): boolean {\n        if (handle instanceof SliderHandle) {\n            return false;\n        }\n        handle.addEventListener(\n            'sp-slider-handle-ready',\n            () => this.extractModelFromLightDom(),\n            { once: true, passive: true }\n        );\n        return true;\n    }\n\n    private extractModelFromLightDom = (): void => {\n        let handles = [\n            ...this.host.querySelectorAll('[slot=\"handle\"]'),\n        ] as SliderHandle[];\n        if (handles.length === 0) {\n            handles = [this.host as SliderHandle];\n        }\n        // extractModelFromLightDom depends on slotted handles already having been upgraded\n        if (handles.some((h) => this.waitForUpgrade(h))) {\n            return;\n        }\n        this.handles = new Map();\n        this.handleOrder = [];\n        handles.forEach((handle, index) => {\n            /* c8 ignore next */\n            if (!handle.handleName?.length) {\n                handle.name = `handle${index + 1}`;\n            }\n            this.handles.set(handle.handleName, handle);\n            this.handleOrder.push(handle.handleName);\n            handle.handleController = this;\n        });\n        this.requestUpdate();\n    };\n\n    public get activeHandle(): string {\n        return this.handleOrder[this.handleOrder.length - 1];\n    }\n\n    public get activeHandleInputId(): string {\n        const active = this.activeHandle;\n        const index = this.model.findIndex((model) => model.name === active);\n        return `input-${index}`;\n    }\n\n    public activateHandle(name: string): void {\n        const index = this.handleOrder.findIndex((item) => item === name);\n        if (index >= 0) {\n            this.handleOrder.splice(index, 1);\n        }\n        this.handleOrder.push(name);\n    }\n\n    public get activeHandleModel(): ModelValue {\n        const active = this.activeHandle;\n        return this.model.find((model) => model.name === active)!;\n    }\n\n    private getActiveHandleElements(): HandleComponents {\n        const name = this.activeHandle;\n        const handleSlider = this.handles.get(name) as SliderHandle;\n        const elements = this.getHandleElements(\n            handleSlider\n        ) as HandleReference;\n        return { model: handleSlider, ...elements };\n    }\n\n    private getHandleElements(sliderHandle: SliderHandle): HandleReference {\n        if (!this.handleRefMap) {\n            this.handleRefMap = new WeakMap();\n\n            const inputNodes =\n                this.host.shadowRoot.querySelectorAll('.handle > input');\n            for (const inputNode of inputNodes) {\n                const input = inputNode as HTMLInputElement;\n                const handle = input.parentElement as HTMLElement;\n                const model = this.handles.get(\n                    handle.getAttribute('name') as string\n                );\n                if (model) {\n                    this.handleRefMap.set(model, { input, handle });\n                }\n            }\n        }\n\n        const components = this.handleRefMap.get(\n            sliderHandle\n        ) as HandleReference;\n        return components;\n    }\n\n    private clearHandleComponentCache(): void {\n        delete this.handleRefMap;\n    }\n\n    private _boundingClientRect?: DOMRect;\n\n    private get boundingClientRect(): DOMRect {\n        if (!this._boundingClientRect) {\n            this._boundingClientRect = this.host.track.getBoundingClientRect();\n        }\n        return this._boundingClientRect;\n    }\n\n    private updateBoundingRect(): void {\n        delete this._boundingClientRect;\n    }\n\n    /**\n     * Return the `input` and `model` associated with the event and\n     * whether the `input` is a `resolvedInput` meaning it was acquired\n     * from the `model` rather than the event.\n     */\n    protected extractDataFromEvent(event: PointerEvent): DataFromPointerEvent {\n        if (!this._activePointerEventData) {\n            let input = (event.target as Element).querySelector(\n                ':scope > .input'\n            ) as InputWithModel;\n            const resolvedInput = !input;\n            const model = input\n                ? input.model\n                : this.model.find((item) => item.name === this.activeHandle);\n            if (!input && !!model) {\n                input = model.handle.focusElement as InputWithModel;\n            }\n            this._activePointerEventData = {\n                input,\n                model,\n                resolvedInput,\n            };\n        }\n        return this._activePointerEventData;\n    }\n\n    private _activePointerEventData!: DataFromPointerEvent | undefined;\n\n    /**\n     * @description check for defaultvalue(value) property in sp-slider and reset on double click on sliderHandle\n     * @param event\n     */\n    public handleDoubleClick(event: PointerEvent): void {\n        const input = (event.target as Element).querySelector(\n            '.input'\n        ) as InputWithModel;\n\n        if (input.model?.handle.defaultValue !== undefined) {\n            input.model.handle.value = input.model.handle.defaultValue;\n            this.dispatchChangeEvent(input, input.model.handle);\n            input.model.handle.dispatchInputEvent();\n            this.requestUpdate();\n        }\n    }\n\n    public handlePointerdown(event: PointerEvent): void {\n        const { resolvedInput, model } = this.extractDataFromEvent(event);\n        if (!model || this.host.disabled || event.button !== 0) {\n            event.preventDefault();\n            return;\n        }\n        this.host.track.setPointerCapture(event.pointerId);\n        this.updateBoundingRect();\n        if (event.pointerType === 'mouse') {\n            this.host.labelEl.click();\n        }\n        this.draggingHandle = model.handle;\n        model.handle.dragging = true;\n        this.activateHandle(model.name);\n        if (resolvedInput) {\n            // When the input is resolved forward the pointer event to\n            // `handlePointermove` in order to update the value/UI becuase\n            // the pointer event was on the track not a handle\n            this.handlePointermove(event);\n        }\n        this.requestUpdate();\n    }\n\n    public handlePointerup(event: PointerEvent): void {\n        const { input, model } = this.extractDataFromEvent(event);\n        delete this._activePointerEventData;\n        if (!model) return;\n        if (event.pointerType === 'mouse') {\n            this.host.labelEl.click();\n        }\n        this.cancelDrag(model);\n        this.requestUpdate();\n        this.host.track.releasePointerCapture(event.pointerId);\n        this.dispatchChangeEvent(input, model.handle);\n    }\n\n    public handlePointermove(event: PointerEvent): void {\n        const { input, model } = this.extractDataFromEvent(event);\n        if (!model) return;\n        /* c8 ignore next 3 */\n        if (!this.draggingHandle) {\n            return;\n        }\n        input.value = this.calculateHandlePosition(event, model).toString();\n        model.handle.value = parseFloat(input.value);\n        this.host.indeterminate = false;\n        this.requestUpdate();\n    }\n\n    public cancelDrag(model?: ModelValue): void {\n        model =\n            model || this.model.find((item) => item.name === this.activeHandle);\n        if (!model) return;\n        model.handle.highlight = false;\n        delete this.draggingHandle;\n        model.handle.dragging = false;\n    }\n\n    /**\n     * Keep the slider value property in sync with the input element's value\n     */\n    private onInputChange = (event: Event): void => {\n        const input = event.target as InputWithModel;\n        input.model.handle.value = input.valueAsNumber;\n\n        this.requestUpdate();\n        this.dispatchChangeEvent(input, input.model.handle);\n    };\n\n    private onInputFocus = (event: Event): void => {\n        const input = event.target as InputWithModel;\n        let isFocusVisible;\n        try {\n            isFocusVisible =\n                input.matches(':focus-visible') ||\n                this.host.matches('.focus-visible');\n            /* c8 ignore next 3 */\n        } catch (error) {\n            isFocusVisible = this.host.matches('.focus-visible');\n        }\n        input.model.handle.highlight = isFocusVisible;\n        this.requestUpdate();\n    };\n\n    private onInputBlur = (event: Event): void => {\n        const input = event.target as InputWithModel;\n        input.model.handle.highlight = false;\n        this.requestUpdate();\n    };\n\n    private onInputKeydown = (event: KeyboardEvent): void => {\n        if (event.key == 'Escape') {\n            const input = event.target as InputWithModel;\n            if (\n                input.model.handle?.defaultValue !== undefined &&\n                input.model.handle.value !== input.model.handle.defaultValue\n            ) {\n                input.model.handle.value = input.model.handle.defaultValue;\n                input.model.handle.dispatchInputEvent();\n                this.dispatchChangeEvent(input, input.model.handle);\n                this.requestUpdate();\n                event.preventDefault();\n                event.stopPropagation();\n            }\n            return;\n        }\n        const input = event.target as InputWithModel;\n        input.model.handle.highlight = true;\n        this.requestUpdate();\n    };\n\n    private dispatchChangeEvent(\n        input: HTMLInputElement,\n        handle: SliderHandle\n    ): void {\n        input.valueAsNumber = handle.value;\n\n        const changeEvent = new Event('change', {\n            bubbles: true,\n            composed: true,\n        });\n\n        handle.dispatchEvent(changeEvent);\n    }\n\n    /**\n     * Returns the value under the cursor\n     * @param: PointerEvent on slider\n     * @return: Slider value that correlates to the position under the pointer\n     */\n    private calculateHandlePosition(\n        event: PointerEvent | MouseEvent,\n        model: ModelValue\n    ): number {\n        const rect = this.boundingClientRect;\n        const minOffset = rect.left;\n        const offset = event.clientX;\n        const size = rect.width;\n\n        const directionalOffset = this.host.isLTR\n            ? offset - minOffset\n            : size - (offset - minOffset);\n        const normalized = directionalOffset / size;\n\n        return model.normalization.fromNormalized(\n            normalized,\n            model.range.min,\n            model.range.max\n        );\n    }\n\n    public renderHandle(\n        model: ModelValue,\n        index: number,\n        zIndex: number,\n        isMultiHandle: boolean\n    ): TemplateResult {\n        const classes = {\n            handle: true,\n            dragging: this.draggingHandle?.handleName === model.name,\n            'handle-highlight': model.highlight,\n        };\n        const style = {\n            [this.host.isLTR ? 'left' : 'right']: `${\n                model.normalizedValue * 100\n            }%`,\n            'z-index': zIndex.toString(),\n            ...(isMultiHandle && {\n                'background-color': `var(--spectrum-slider-handle-background-color-${index}, var(--spectrum-slider-handle-background-color))`,\n                'border-color': `var(--spectrum-slider-handle-border-color-${index}, var(--spectrum-slider-handle-border-color))`,\n            }),\n        };\n        const ariaLabelledBy = isMultiHandle ? `label input-${index}` : 'label';\n        return html`\n            <div\n                class=${classMap(classes)}\n                name=${model.name}\n                style=${styleMap(style)}\n                role=\"presentation\"\n            >\n                <input\n                    type=\"range\"\n                    class=\"input\"\n                    id=\"input-${index}\"\n                    min=${model.clamp.min}\n                    max=${model.clamp.max}\n                    step=${model.step}\n                    value=${model.value}\n                    aria-disabled=${ifDefined(\n                        this.host.disabled ? 'true' : undefined\n                    )}\n                    tabindex=${ifDefined(this.host.editable ? -1 : undefined)}\n                    aria-label=${ifDefined(model.ariaLabel)}\n                    aria-labelledby=${ariaLabelledBy}\n                    aria-valuetext=${this.formattedValueForHandle(model)}\n                    aria-describedby=\"slider-description\"\n                    @change=${this.onInputChange}\n                    @focus=${this.onInputFocus}\n                    @blur=${this.onInputBlur}\n                    @keydown=${this.onInputKeydown}\n                    .model=${model}\n                />\n                <span id=\"slider-description\">\n                    Press escape or double click to reset the slider to its\n                    default value.\n                </span>\n            </div>\n        `;\n    }\n\n    public render(): TemplateResult[] {\n        this.clearHandleComponentCache();\n        return this.model.map((model, index) => {\n            const zIndex = this.handleOrder.indexOf(model.name) + 2;\n            return this.renderHandle(\n                model,\n                index,\n                zIndex,\n                this.model.length > 1\n            );\n        });\n    }\n\n    /**\n     * Returns a list of track segment [start, end] tuples where the values are\n     * normalized to be between 0 and 1.\n     * @returns A list of track segment tuples [start, end]\n     */\n    public trackSegments(): [number, number][] {\n        const values = this.model.map((model) => model.normalizedValue);\n        values.sort((a, b) => a - b);\n\n        // The first segment always starts at 0\n        values.unshift(0);\n        return values.map((value, index, array) => [\n            value,\n            array[index + 1] ?? 1,\n        ]);\n    }\n\n    private updateModel(): void {\n        const handles = [...this.handles.values()];\n\n        const getRangeAndClamp = (index: number): RangeAndClamp => {\n            const handle = handles[index];\n            const previous = handles[index - 1];\n            const next = handles[index + 1];\n\n            const min =\n                typeof handle.min === 'number'\n                    ? handle.min\n                    : (this.host.min as number);\n            const max =\n                typeof handle.max === 'number'\n                    ? handle.max\n                    : (this.host.max as number);\n\n            const result: RangeAndClamp = {\n                range: { min: min, max: max },\n                clamp: { min: min, max: max },\n            };\n\n            if (handle.min === 'previous') {\n                if (previous) {\n                    for (let j = index - 1; j >= 0; j--) {\n                        const item = handles[j];\n                        if (typeof item.min === 'number') {\n                            result.range.min = item.min;\n                            break;\n                        }\n                    }\n                    result.clamp.min = Math.max(\n                        previous.value,\n                        result.range.min\n                    );\n                }\n                if (window.__swc.DEBUG) {\n                    if (!previous) {\n                        window.__swc.warn(\n                            this.host,\n                            '<sp-slider-handle> elements that are the first child of an <sp-slider> element cannot have attribute \"min=\\'previous\\'\"`',\n                            'https://opensource.adobe.com/spectrum-web-components/components/slider-handle/#multi-handle-slider-with-ordered-handles'\n                        );\n                    }\n                }\n            }\n            if (handle.max === 'next') {\n                if (next) {\n                    for (let j = index + 1; j < handles.length; j++) {\n                        const item = handles[j];\n                        if (typeof item.max === 'number') {\n                            result.range.max = item.max;\n                            break;\n                        }\n                    }\n                    result.clamp.max = Math.min(next.value, result.range.max);\n                }\n                if (window.__swc.DEBUG) {\n                    if (!next) {\n                        window.__swc.warn(\n                            this.host,\n                            '<sp-slider-handle> elements that are the last child of an <sp-slider> element cannot have attribute \"max=\\'next\\'\"',\n                            'https://opensource.adobe.com/spectrum-web-components/components/slider-handle/#multi-handle-slider-with-ordered-handles'\n                        );\n                    }\n                }\n            }\n            return result;\n        };\n\n        const modelValues = handles.map((handle, index) => {\n            const rangeAndClamp = getRangeAndClamp(index);\n            const { toNormalized } = handle.normalization;\n            const clampedValue = Math.max(\n                Math.min(handle.value, rangeAndClamp.clamp.max),\n                rangeAndClamp.clamp.min\n            );\n            const normalizedValue = toNormalized(\n                clampedValue,\n                rangeAndClamp.range.min,\n                rangeAndClamp.range.max\n            );\n            const model = {\n                name: handle.handleName,\n                value: clampedValue,\n                normalizedValue,\n                highlight: handle.highlight,\n                step: handle.step ?? this.host.step,\n                normalization: handle.normalization,\n                handle,\n                ariaLabel:\n                    handle !== this.host && handle?.label.length > 0\n                        ? handle.label\n                        : undefined,\n                ...rangeAndClamp,\n            };\n            return model;\n        });\n\n        this.model = modelValues;\n    }\n\n    public async handleUpdatesComplete(): Promise<void> {\n        const updates = [...this.handles.values()]\n            .filter((handle) => handle !== this.host)\n            .map((handle) => handle.updateComplete);\n        await Promise.all(updates);\n    }\n}\n"],
  "mappings": ";AAWA,SAAS,YAA4B;AACrC;AAAA,EACI;AAAA,EACA;AAAA,EACA;AAAA,OACG;AACP,SAAS,0BAA0B;AAEnC,SAAS,oBAAyC;AAwC3C,aAAM,iBAAiB;AAAA,EAQ1B,YAAY,MAAc;AAN1B,SAAQ,UAAqC,oBAAI,IAAI;AACrD,SAAQ,QAAsB,CAAC;AAC/B,SAAQ,cAAwB,CAAC;AA6GjC,SAAU,oBAAoB,MAAY;AACtC,WAAK,mBAAmB;AAAA,IAC5B;AAgDA,SAAQ,2BAA2B,MAAY;AAC3C,UAAI,UAAU;AAAA,QACV,GAAG,KAAK,KAAK,iBAAiB,iBAAiB;AAAA,MACnD;AACA,UAAI,QAAQ,WAAW,GAAG;AACtB,kBAAU,CAAC,KAAK,IAAoB;AAAA,MACxC;AAEA,UAAI,QAAQ,KAAK,CAAC,MAAM,KAAK,eAAe,CAAC,CAAC,GAAG;AAC7C;AAAA,MACJ;AACA,WAAK,UAAU,oBAAI,IAAI;AACvB,WAAK,cAAc,CAAC;AACpB,cAAQ,QAAQ,CAAC,QAAQ,UAAU;AA3O3C;AA6OY,YAAI,GAAC,YAAO,eAAP,mBAAmB,SAAQ;AAC5B,iBAAO,OAAO,SAAS,QAAQ,CAAC;AAAA,QACpC;AACA,aAAK,QAAQ,IAAI,OAAO,YAAY,MAAM;AAC1C,aAAK,YAAY,KAAK,OAAO,UAAU;AACvC,eAAO,mBAAmB;AAAA,MAC9B,CAAC;AACD,WAAK,cAAc;AAAA,IACvB;AAqLA;AAAA;AAAA;AAAA,SAAQ,gBAAgB,CAAC,UAAuB;AAC5C,YAAM,QAAQ,MAAM;AACpB,YAAM,MAAM,OAAO,QAAQ,MAAM;AAEjC,WAAK,cAAc;AACnB,WAAK,oBAAoB,OAAO,MAAM,MAAM,MAAM;AAAA,IACtD;AAEA,SAAQ,eAAe,CAAC,UAAuB;AAC3C,YAAM,QAAQ,MAAM;AACpB,UAAI;AACJ,UAAI;AACA,yBACI,MAAM,QAAQ,gBAAgB,KAC9B,KAAK,KAAK,QAAQ,gBAAgB;AAAA,MAE1C,SAAS,OAAO;AACZ,yBAAiB,KAAK,KAAK,QAAQ,gBAAgB;AAAA,MACvD;AACA,YAAM,MAAM,OAAO,YAAY;AAC/B,WAAK,cAAc;AAAA,IACvB;AAEA,SAAQ,cAAc,CAAC,UAAuB;AAC1C,YAAM,QAAQ,MAAM;AACpB,YAAM,MAAM,OAAO,YAAY;AAC/B,WAAK,cAAc;AAAA,IACvB;AAEA,SAAQ,iBAAiB,CAAC,UAA+B;AAvc7D;AAwcQ,UAAI,MAAM,OAAO,UAAU;AACvB,cAAMA,SAAQ,MAAM;AACpB,cACI,KAAAA,OAAM,MAAM,WAAZ,mBAAoB,kBAAiB,UACrCA,OAAM,MAAM,OAAO,UAAUA,OAAM,MAAM,OAAO,cAClD;AACE,UAAAA,OAAM,MAAM,OAAO,QAAQA,OAAM,MAAM,OAAO;AAC9C,UAAAA,OAAM,MAAM,OAAO,mBAAmB;AACtC,eAAK,oBAAoBA,QAAOA,OAAM,MAAM,MAAM;AAClD,eAAK,cAAc;AACnB,gBAAM,eAAe;AACrB,gBAAM,gBAAgB;AAAA,QAC1B;AACA;AAAA,MACJ;AACA,YAAM,QAAQ,MAAM;AACpB,YAAM,MAAM,OAAO,YAAY;AAC/B,WAAK,cAAc;AAAA,IACvB;AAtZI,SAAK,OAAO;AAEZ,QAAI,mBAAmB,KAAK,MAAM;AAAA,MAC9B,QAAQ;AAAA,QACJ,SAAS;AAAA,QACT,WAAW;AAAA,MACf;AAAA,MACA,UAAU,MAAM;AACZ,aAAK,yBAAyB;AAAA,MAClC;AAAA,IACJ,CAAC;AAED,SAAK,yBAAyB;AAAA,EAClC;AAAA,EAEA,IAAW,SAAgC;AACvC,UAAM,SAAgC,CAAC;AACvC,eAAW,SAAS,KAAK,QAAQ,OAAO,GAAG;AACvC,aAAO,MAAM,UAAU,IAAI,MAAM;AAAA,IACrC;AACA,WAAO;AAAA,EACX;AAAA,EAEA,IAAW,OAAe;AACtB,WAAO,KAAK,QAAQ;AAAA,EACxB;AAAA,EAEO,eAAe,QAAoD;AACtE,QAAI,KAAK,QAAQ,IAAI,OAAO,UAAU,GAAG;AACrC,YAAM,EAAE,MAAM,IAAI,KAAK,kBAAkB,MAAM,KAAK,CAAC;AACrD,aAAO;AAAA,IACX;AAEA,UAAM,IAAI,MAAM,wBAAwB,OAAO,IAAI,GAAG;AAAA,EAC1D;AAAA,EAEO,gBAAsB;AACzB,QAAI,KAAK,KAAK,YAAY;AACtB,WAAK,KAAK,cAAc;AAAA,IAC5B;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,mBAAmB,QAA4B;AAClD,UAAM,WAAW,KAAK,kBAAkB,MAAM;AAE9C,QAAI,CAAC,SAAU;AAEf,UAAM,EAAE,MAAM,IAAI;AAClB,QAAI,MAAM,kBAAkB,OAAO,OAAO;AACtC,UAAI,OAAO,UAAU;AACjB,eAAO,mBAAmB;AAAA,MAC9B;AAAA,IACJ,OAAO;AACH,YAAM,gBAAgB,OAAO;AAC7B,WAAK,cAAc;AAAA,IACvB;AACA,WAAO,QAAQ,MAAM;AAAA,EACzB;AAAA,EAEO,iBAAiB,QAA4B;AAChD,QAAI,WAAW,KAAK,MAAM;AACtB,WAAK,cAAc;AAAA,IACvB;AAAA,EACJ;AAAA,EAEO,wBAAwB,OAA2B;AA5I9D;AA6IQ,UAAM,EAAE,OAAO,IAAI;AACnB,UAAM,gBAAe,YAAO,iBAAP,YAAuB,KAAK,KAAK;AACtD,UAAM,cACF,OAAO,gBAAgB,KACjB,KAAK,KAAK,cACV,OAAO;AACjB,WACI,OAAO,kBAAkB,MAAM,OAAO,YAAY,IAAI;AAAA,EAE9D;AAAA,EAEA,IAAW,kBAAuC;AAC9C,UAAM,SAAS,oBAAI,IAAoB;AACvC,eAAW,SAAS,KAAK,OAAO;AAC5B,aAAO,IAAI,MAAM,MAAM,KAAK,wBAAwB,KAAK,CAAC;AAAA,IAC9D;AACA,WAAO;AAAA,EACX;AAAA,EAEA,IAAW,eAA4B;AACnC,UAAM,EAAE,MAAM,IAAI,KAAK,wBAAwB;AAC/C,QACI,CAAC,SACA,KAAK,KAAK,YACP,CAAE,MAAyB,MAAM,OAAO,UAC9C;AACE,aAAO,KAAK,KAAK;AAAA,IACrB;AACA,WAAO;AAAA,EACX;AAAA,EAMO,gBAAsB;AACzB,QAAI,iBAAiB,QAAQ;AACzB,aAAO,YAAY;AAAA,QACf;AAAA,QACA,KAAK;AAAA,MACT;AAAA,IACJ,OAAO;AACH,aAAO;AAAA,QACH;AAAA,QACA,KAAK;AAAA,MACT;AAAA,IACJ;AAAA,EACJ;AAAA,EAEO,mBAAyB;AAC5B,QAAI,iBAAiB,QAAQ;AACzB,aAAO,YAAY;AAAA,QACf;AAAA,QACA,KAAK;AAAA,MACT;AAAA,IACJ,OAAO;AACH,aAAO;AAAA,QACH;AAAA,QACA,KAAK;AAAA,MACT;AAAA,IACJ;AAAA,EACJ;AAAA,EAEO,aAAmB;AACtB,SAAK,YAAY;AAAA,EACrB;AAAA;AAAA;AAAA,EAIQ,eAAe,QAA8B;AACjD,QAAI,kBAAkB,cAAc;AAChC,aAAO;AAAA,IACX;AACA,WAAO;AAAA,MACH;AAAA,MACA,MAAM,KAAK,yBAAyB;AAAA,MACpC,EAAE,MAAM,MAAM,SAAS,KAAK;AAAA,IAChC;AACA,WAAO;AAAA,EACX;AAAA,EA2BA,IAAW,eAAuB;AAC9B,WAAO,KAAK,YAAY,KAAK,YAAY,SAAS,CAAC;AAAA,EACvD;AAAA,EAEA,IAAW,sBAA8B;AACrC,UAAM,SAAS,KAAK;AACpB,UAAM,QAAQ,KAAK,MAAM,UAAU,CAAC,UAAU,MAAM,SAAS,MAAM;AACnE,WAAO,SAAS,KAAK;AAAA,EACzB;AAAA,EAEO,eAAe,MAAoB;AACtC,UAAM,QAAQ,KAAK,YAAY,UAAU,CAAC,SAAS,SAAS,IAAI;AAChE,QAAI,SAAS,GAAG;AACZ,WAAK,YAAY,OAAO,OAAO,CAAC;AAAA,IACpC;AACA,SAAK,YAAY,KAAK,IAAI;AAAA,EAC9B;AAAA,EAEA,IAAW,oBAAgC;AACvC,UAAM,SAAS,KAAK;AACpB,WAAO,KAAK,MAAM,KAAK,CAAC,UAAU,MAAM,SAAS,MAAM;AAAA,EAC3D;AAAA,EAEQ,0BAA4C;AAChD,UAAM,OAAO,KAAK;AAClB,UAAM,eAAe,KAAK,QAAQ,IAAI,IAAI;AAC1C,UAAM,WAAW,KAAK;AAAA,MAClB;AAAA,IACJ;AACA,WAAO,EAAE,OAAO,cAAc,GAAG,SAAS;AAAA,EAC9C;AAAA,EAEQ,kBAAkB,cAA6C;AACnE,QAAI,CAAC,KAAK,cAAc;AACpB,WAAK,eAAe,oBAAI,QAAQ;AAEhC,YAAM,aACF,KAAK,KAAK,WAAW,iBAAiB,iBAAiB;AAC3D,iBAAW,aAAa,YAAY;AAChC,cAAM,QAAQ;AACd,cAAM,SAAS,MAAM;AACrB,cAAM,QAAQ,KAAK,QAAQ;AAAA,UACvB,OAAO,aAAa,MAAM;AAAA,QAC9B;AACA,YAAI,OAAO;AACP,eAAK,aAAa,IAAI,OAAO,EAAE,OAAO,OAAO,CAAC;AAAA,QAClD;AAAA,MACJ;AAAA,IACJ;AAEA,UAAM,aAAa,KAAK,aAAa;AAAA,MACjC;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EAEQ,4BAAkC;AACtC,WAAO,KAAK;AAAA,EAChB;AAAA,EAIA,IAAY,qBAA8B;AACtC,QAAI,CAAC,KAAK,qBAAqB;AAC3B,WAAK,sBAAsB,KAAK,KAAK,MAAM,sBAAsB;AAAA,IACrE;AACA,WAAO,KAAK;AAAA,EAChB;AAAA,EAEQ,qBAA2B;AAC/B,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOU,qBAAqB,OAA2C;AACtE,QAAI,CAAC,KAAK,yBAAyB;AAC/B,UAAI,QAAS,MAAM,OAAmB;AAAA,QAClC;AAAA,MACJ;AACA,YAAM,gBAAgB,CAAC;AACvB,YAAM,QAAQ,QACR,MAAM,QACN,KAAK,MAAM,KAAK,CAAC,SAAS,KAAK,SAAS,KAAK,YAAY;AAC/D,UAAI,CAAC,SAAS,CAAC,CAAC,OAAO;AACnB,gBAAQ,MAAM,OAAO;AAAA,MACzB;AACA,WAAK,0BAA0B;AAAA,QAC3B;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AACA,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,kBAAkB,OAA2B;AAhWxD;AAiWQ,UAAM,QAAS,MAAM,OAAmB;AAAA,MACpC;AAAA,IACJ;AAEA,UAAI,WAAM,UAAN,mBAAa,OAAO,kBAAiB,QAAW;AAChD,YAAM,MAAM,OAAO,QAAQ,MAAM,MAAM,OAAO;AAC9C,WAAK,oBAAoB,OAAO,MAAM,MAAM,MAAM;AAClD,YAAM,MAAM,OAAO,mBAAmB;AACtC,WAAK,cAAc;AAAA,IACvB;AAAA,EACJ;AAAA,EAEO,kBAAkB,OAA2B;AAChD,UAAM,EAAE,eAAe,MAAM,IAAI,KAAK,qBAAqB,KAAK;AAChE,QAAI,CAAC,SAAS,KAAK,KAAK,YAAY,MAAM,WAAW,GAAG;AACpD,YAAM,eAAe;AACrB;AAAA,IACJ;AACA,SAAK,KAAK,MAAM,kBAAkB,MAAM,SAAS;AACjD,SAAK,mBAAmB;AACxB,QAAI,MAAM,gBAAgB,SAAS;AAC/B,WAAK,KAAK,QAAQ,MAAM;AAAA,IAC5B;AACA,SAAK,iBAAiB,MAAM;AAC5B,UAAM,OAAO,WAAW;AACxB,SAAK,eAAe,MAAM,IAAI;AAC9B,QAAI,eAAe;AAIf,WAAK,kBAAkB,KAAK;AAAA,IAChC;AACA,SAAK,cAAc;AAAA,EACvB;AAAA,EAEO,gBAAgB,OAA2B;AAC9C,UAAM,EAAE,OAAO,MAAM,IAAI,KAAK,qBAAqB,KAAK;AACxD,WAAO,KAAK;AACZ,QAAI,CAAC,MAAO;AACZ,QAAI,MAAM,gBAAgB,SAAS;AAC/B,WAAK,KAAK,QAAQ,MAAM;AAAA,IAC5B;AACA,SAAK,WAAW,KAAK;AACrB,SAAK,cAAc;AACnB,SAAK,KAAK,MAAM,sBAAsB,MAAM,SAAS;AACrD,SAAK,oBAAoB,OAAO,MAAM,MAAM;AAAA,EAChD;AAAA,EAEO,kBAAkB,OAA2B;AAChD,UAAM,EAAE,OAAO,MAAM,IAAI,KAAK,qBAAqB,KAAK;AACxD,QAAI,CAAC,MAAO;AAEZ,QAAI,CAAC,KAAK,gBAAgB;AACtB;AAAA,IACJ;AACA,UAAM,QAAQ,KAAK,wBAAwB,OAAO,KAAK,EAAE,SAAS;AAClE,UAAM,OAAO,QAAQ,WAAW,MAAM,KAAK;AAC3C,SAAK,KAAK,gBAAgB;AAC1B,SAAK,cAAc;AAAA,EACvB;AAAA,EAEO,WAAW,OAA0B;AACxC,YACI,SAAS,KAAK,MAAM,KAAK,CAAC,SAAS,KAAK,SAAS,KAAK,YAAY;AACtE,QAAI,CAAC,MAAO;AACZ,UAAM,OAAO,YAAY;AACzB,WAAO,KAAK;AACZ,UAAM,OAAO,WAAW;AAAA,EAC5B;AAAA,EAuDQ,oBACJ,OACA,QACI;AACJ,UAAM,gBAAgB,OAAO;AAE7B,UAAM,cAAc,IAAI,MAAM,UAAU;AAAA,MACpC,SAAS;AAAA,MACT,UAAU;AAAA,IACd,CAAC;AAED,WAAO,cAAc,WAAW;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,wBACJ,OACA,OACM;AACN,UAAM,OAAO,KAAK;AAClB,UAAM,YAAY,KAAK;AACvB,UAAM,SAAS,MAAM;AACrB,UAAM,OAAO,KAAK;AAElB,UAAM,oBAAoB,KAAK,KAAK,QAC9B,SAAS,YACT,QAAQ,SAAS;AACvB,UAAM,aAAa,oBAAoB;AAEvC,WAAO,MAAM,cAAc;AAAA,MACvB;AAAA,MACA,MAAM,MAAM;AAAA,MACZ,MAAM,MAAM;AAAA,IAChB;AAAA,EACJ;AAAA,EAEO,aACH,OACA,OACA,QACA,eACc;AAzgBtB;AA0gBQ,UAAM,UAAU;AAAA,MACZ,QAAQ;AAAA,MACR,YAAU,UAAK,mBAAL,mBAAqB,gBAAe,MAAM;AAAA,MACpD,oBAAoB,MAAM;AAAA,IAC9B;AACA,UAAM,QAAQ;AAAA,MACV,CAAC,KAAK,KAAK,QAAQ,SAAS,OAAO,GAAG,GAClC,MAAM,kBAAkB,GAC5B;AAAA,MACA,WAAW,OAAO,SAAS;AAAA,MAC3B,GAAI,iBAAiB;AAAA,QACjB,oBAAoB,iDAAiD,KAAK;AAAA,QAC1E,gBAAgB,6CAA6C,KAAK;AAAA,MACtE;AAAA,IACJ;AACA,UAAM,iBAAiB,gBAAgB,eAAe,KAAK,KAAK;AAChE,WAAO;AAAA;AAAA,wBAES,SAAS,OAAO,CAAC;AAAA,uBAClB,MAAM,IAAI;AAAA,wBACT,SAAS,KAAK,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gCAMP,KAAK;AAAA,0BACX,MAAM,MAAM,GAAG;AAAA,0BACf,MAAM,MAAM,GAAG;AAAA,2BACd,MAAM,IAAI;AAAA,4BACT,MAAM,KAAK;AAAA,oCACH;AAAA,MACZ,KAAK,KAAK,WAAW,SAAS;AAAA,IAClC,CAAC;AAAA,+BACU,UAAU,KAAK,KAAK,WAAW,KAAK,MAAS,CAAC;AAAA,iCAC5C,UAAU,MAAM,SAAS,CAAC;AAAA,sCACrB,cAAc;AAAA,qCACf,KAAK,wBAAwB,KAAK,CAAC;AAAA;AAAA,8BAE1C,KAAK,aAAa;AAAA,6BACnB,KAAK,YAAY;AAAA,4BAClB,KAAK,WAAW;AAAA,+BACb,KAAK,cAAc;AAAA,6BACrB,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQ9B;AAAA,EAEO,SAA2B;AAC9B,SAAK,0BAA0B;AAC/B,WAAO,KAAK,MAAM,IAAI,CAAC,OAAO,UAAU;AACpC,YAAM,SAAS,KAAK,YAAY,QAAQ,MAAM,IAAI,IAAI;AACtD,aAAO,KAAK;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,QACA,KAAK,MAAM,SAAS;AAAA,MACxB;AAAA,IACJ,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,gBAAoC;AACvC,UAAM,SAAS,KAAK,MAAM,IAAI,CAAC,UAAU,MAAM,eAAe;AAC9D,WAAO,KAAK,CAAC,GAAG,MAAM,IAAI,CAAC;AAG3B,WAAO,QAAQ,CAAC;AAChB,WAAO,OAAO,IAAI,CAAC,OAAO,OAAO,UAAO;AAvlBhD;AAulBmD;AAAA,QACvC;AAAA,SACA,WAAM,QAAQ,CAAC,MAAf,YAAoB;AAAA,MACxB;AAAA,KAAC;AAAA,EACL;AAAA,EAEQ,cAAoB;AACxB,UAAM,UAAU,CAAC,GAAG,KAAK,QAAQ,OAAO,CAAC;AAEzC,UAAM,mBAAmB,CAAC,UAAiC;AACvD,YAAM,SAAS,QAAQ,KAAK;AAC5B,YAAM,WAAW,QAAQ,QAAQ,CAAC;AAClC,YAAM,OAAO,QAAQ,QAAQ,CAAC;AAE9B,YAAM,MACF,OAAO,OAAO,QAAQ,WAChB,OAAO,MACN,KAAK,KAAK;AACrB,YAAM,MACF,OAAO,OAAO,QAAQ,WAChB,OAAO,MACN,KAAK,KAAK;AAErB,YAAM,SAAwB;AAAA,QAC1B,OAAO,EAAE,KAAU,IAAS;AAAA,QAC5B,OAAO,EAAE,KAAU,IAAS;AAAA,MAChC;AAEA,UAAI,OAAO,QAAQ,YAAY;AAC3B,YAAI,UAAU;AACV,mBAAS,IAAI,QAAQ,GAAG,KAAK,GAAG,KAAK;AACjC,kBAAM,OAAO,QAAQ,CAAC;AACtB,gBAAI,OAAO,KAAK,QAAQ,UAAU;AAC9B,qBAAO,MAAM,MAAM,KAAK;AACxB;AAAA,YACJ;AAAA,UACJ;AACA,iBAAO,MAAM,MAAM,KAAK;AAAA,YACpB,SAAS;AAAA,YACT,OAAO,MAAM;AAAA,UACjB;AAAA,QACJ;AACA,YAAI,MAAoB;AACpB,cAAI,CAAC,UAAU;AACX,mBAAO,MAAM;AAAA,cACT,KAAK;AAAA,cACL;AAAA,cACA;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,OAAO,QAAQ,QAAQ;AACvB,YAAI,MAAM;AACN,mBAAS,IAAI,QAAQ,GAAG,IAAI,QAAQ,QAAQ,KAAK;AAC7C,kBAAM,OAAO,QAAQ,CAAC;AACtB,gBAAI,OAAO,KAAK,QAAQ,UAAU;AAC9B,qBAAO,MAAM,MAAM,KAAK;AACxB;AAAA,YACJ;AAAA,UACJ;AACA,iBAAO,MAAM,MAAM,KAAK,IAAI,KAAK,OAAO,OAAO,MAAM,GAAG;AAAA,QAC5D;AACA,YAAI,MAAoB;AACpB,cAAI,CAAC,MAAM;AACP,mBAAO,MAAM;AAAA,cACT,KAAK;AAAA,cACL;AAAA,cACA;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AAEA,UAAM,cAAc,QAAQ,IAAI,CAAC,QAAQ,UAAU;AAnqB3D;AAoqBY,YAAM,gBAAgB,iBAAiB,KAAK;AAC5C,YAAM,EAAE,aAAa,IAAI,OAAO;AAChC,YAAM,eAAe,KAAK;AAAA,QACtB,KAAK,IAAI,OAAO,OAAO,cAAc,MAAM,GAAG;AAAA,QAC9C,cAAc,MAAM;AAAA,MACxB;AACA,YAAM,kBAAkB;AAAA,QACpB;AAAA,QACA,cAAc,MAAM;AAAA,QACpB,cAAc,MAAM;AAAA,MACxB;AACA,YAAM,QAAQ;AAAA,QACV,MAAM,OAAO;AAAA,QACb,OAAO;AAAA,QACP;AAAA,QACA,WAAW,OAAO;AAAA,QAClB,OAAM,YAAO,SAAP,YAAe,KAAK,KAAK;AAAA,QAC/B,eAAe,OAAO;AAAA,QACtB;AAAA,QACA,WACI,WAAW,KAAK,SAAQ,iCAAQ,MAAM,UAAS,IACzC,OAAO,QACP;AAAA,QACV,GAAG;AAAA,MACP;AACA,aAAO;AAAA,IACX,CAAC;AAED,SAAK,QAAQ;AAAA,EACjB;AAAA,EAEA,MAAa,wBAAuC;AAChD,UAAM,UAAU,CAAC,GAAG,KAAK,QAAQ,OAAO,CAAC,EACpC,OAAO,CAAC,WAAW,WAAW,KAAK,IAAI,EACvC,IAAI,CAAC,WAAW,OAAO,cAAc;AAC1C,UAAM,QAAQ,IAAI,OAAO;AAAA,EAC7B;AACJ;",
  "names": ["input"]
}
